/*
 * Copyright (c) 2018, William L Baker
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *
 *     * Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following disclaimer
 * in the documentation and/or other materials provided with the
 * distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*! \file
 * \mainpage Introduction
 *
 * This is [PISTA], a C implementation of communications drivers for medical
 * devices with bindings for other languages.
 *
 * This file defines the public API for the `libpista` communication library.
 * This API includes interfaces that can be used directly by client code.
 * <hr/>
 * \section pageTOC Content
 *   -# [Building]
 *   -# \ref [Installing]
 *   -# \ref Using
 *   -# \ref Support
 *   -# \ref Sponsor
 *
 * \authors William L Baker
 *
 * \copyright 2018. Licensed under the terms of the [BSD-2-Clause] license.
 *
 * [PISTA]:            https://softhorizons.com/IDEA/PISTA
 * [Building]:         https://softhorizons.com/IDEA/PISTA
 * [Installing]:       https://softhorizons.com/IDEA/PISTA
 * [BSD-2-Clause]:     http://opensource.org/licenses/BSD-2-Clause
 *
 * \page tutorial00 First Tutorial
 * \includedoc ../../doc/tutorial-00.md
 * \page gencode Generated Code
 *
 * For each enum, we generate a C enum. For each message, we generate a C
 * structure which can be cast to a `ProtobufCMessage`.
 *
 * For each enum and message, we generate a descriptor object that allows us to
 * implement a kind of reflection on the structures.
 *
 * First, some naming conventions:
 *
 * - The name of the type for enums and messages and services is camel case
 *   (meaning WordsAreCrammedTogether) except that double underscores are used
 *   to delimit scopes. For example, the following `.proto` file:
 *
~~~{.proto}
        package foo.bar;
        message BazBah {
            optional int32 val = 1;
        }
~~~
 *
 * would generate a C type `Foo__Bar__BazBah`.
 *
 * - Identifiers for functions and globals are all lowercase, with camel case
 *   words separated by single underscores. For example, one of the function
 *   prototypes generated by `protoc-c` for the above example:
 *
~~~{.c}
Foo__Bar__BazBah *
       foo__bar__baz_bah__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
~~~
 *
 * - Identifiers for enum values contain an uppercase prefix which embeds the
 *   package name and the enum type name.
 *
 * - A double underscore is used to separate further components of identifier
 *   names.
 *
 * For example, in the name of the unpack function above, the package name
 * `foo.bar` has become `foo__bar`, the message name BazBah has become
 * `baz_bah`, and the method name is `unpack`. These are all joined with double
 * underscores to form the C identifier `foo__bar__baz_bah__unpack`.
 *
 * We also generate descriptor objects for messages and enums. These are
 * declared in the `.pb-c.h` files:
 *
~~~{.c}
extern const ProtobufCMessageDescriptor foo__bar__baz_bah__descriptor;
~~~
 *
 * The message structures all begin with `ProtobufCMessageDescriptor *` which is
 * sufficient to allow them to be cast to `ProtobufCMessage`.
 *
 * For each message defined in a `.proto` file, we generate a number of
 * functions. Each function name contains a prefix based on the package name and
 * message name in order to make it a unique C identifier.
 *
 * - `unpack()`. Unpacks data for a particular message format. Note that the
 *   `allocator` parameter is usually `NULL` to indicate that the system's
 *   `malloc()` and `free()` functions should be used for dynamically allocating
 *   memory.
 *
~~~{.c}
Foo__Bar__BazBah *
       foo__bar__baz_bah__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
~~~
 *
 * - `free_unpacked()`. Frees a message object obtained with the `unpack()`
 *   method.
 *
~~~{.c}
void   foo__bar__baz_bah__free_unpacked
                     (Foo__Bar__BazBah *message,
                      ProtobufCAllocator *allocator);
~~~
 *
 * - `get_packed_size()`. Calculates the length in bytes of the serialized
 *   representation of the message object.
 *
~~~{.c}
size_t foo__bar__baz_bah__get_packed_size
                     (const Foo__Bar__BazBah   *message);
~~~
 *
 * - `pack()`. Pack a message object into a preallocated buffer. Assumes that
 *   the buffer is large enough. (Use `get_packed_size()` first.)
 *
~~~{.c}
size_t foo__bar__baz_bah__pack
                     (const Foo__Bar__BazBah   *message,
                      uint8_t             *out);
~~~
 *
 * - `pack_to_buffer()`. Packs a message into a "virtual buffer". This is an
 *   object which defines an "append bytes" callback to consume data as it is
 *   serialized.
 *
~~~{.c}
size_t foo__bar__baz_bah__pack_to_buffer
                     (const Foo__Bar__BazBah   *message,
                      ProtobufCBuffer     *buffer);
~~~
 *
 * \page pack Packing and unpacking messages
 *
 * To pack a message, first compute the packed size of the message with
 * protobuf_c_message_get_packed_size(), then allocate a buffer of at least
 * that size, then call protobuf_c_message_pack().
 *
 * Alternatively, a message can be serialized without calculating the final size
 * first. Use the protobuf_c_message_pack_to_buffer() function and provide a
 * ProtobufCBuffer object which implements an "append" method that consumes
 * data.
 *
 * To unpack a message, call the protobuf_c_message_unpack() function. The
 * result can be cast to an object of the type that matches the descriptor for
 * the message.
 *
 * The result of unpacking a message should be freed with
 * protobuf_c_message_free_unpacked().
 */


#ifndef PISTA_CORE_H
#define PISTA_CORE_H

#include <stdlib.h> // size_t
#include <stdint.h>
#include <stdbool.h>
#include <inttypes.h>

#ifdef WIN32
#else
#include <sys/time.h>
#endif

#ifdef __cplusplus
extern "C" {
#endif

/*
 * All possible return codes of pista functions must be listed here.
 * Functions should never return hardcoded numbers as status, but rather
 * use these enum values. All error codes are negative numbers.
 *
 * The error codes are globally unique in pista, i.e. if one of the
 * pista functions returns a "malloc error" it must be exactly the same
 * return value as used by all other functions to indicate "malloc error".
 * There must be no functions which indicate two different errors via the
 * same return code.
 *
 */

/** Status/error codes returned by pista functions. */
typedef enum __pista_error_code {
    PISTA_OK_CONTINUE       =  1, /**< Keep going. */
    PISTA_OK                =  0, /**< No error. */
    PISTA_ERR               = -1, /**< Generic/unspecified error. */
    PISTA_ERR_MALLOC        = -2, /**< Malloc/calloc/realloc error. */
    PISTA_ERR_ARG           = -3, /**< Function argument error. */
    PISTA_ERR_NA            = -6, /**< Not applicable. */
    PISTA_ERR_DEV_CLOSED    = -7, /**< Device is closed, but must be open. */
    PISTA_ERR_TIMEOUT       = -8, /**< A timeout occurred. */
    PISTA_ERR_DATA          =-10, /**< Data is invalid.  */
    PISTA_ERR_IO            =-11, /**< Input/output error. */

} pista_error_code;


typedef enum __pista_dump_flags {
    PISTA_DUMP_CONFIG       =  1, /** configs. */
    PISTA_DUMP_STREAMS      =  2, /** streams. */
} pista_dump_flags;

/** pista loglevels: default to logging via log4c */
enum pista_loglevel {
    PISTA_LOG_NONE = 0, /**< Output no messages at all. */
    PISTA_LOG_ERR  = 1, /**< Output error messages. */
    PISTA_LOG_WARN = 2, /**< Output warnings. */
    PISTA_LOG_INFO = 3, /**< Output informational messages. */
    PISTA_LOG_DBG  = 4, /**< Output debug messages. */
    PISTA_LOG_SPEW = 5, /**< Output very noisy debug messages. */
};


enum pista_datatyp {
    INT_TYP = 1,
    LONG_TYP = 2,
    DOUBLE_TYP = 3,
    BYTE_TYP = 4,
    STRING_TYP = 5,
    OBJ_TYP = 6,
    FLOAT_TYP = 7,
    INT_ARR_TYP = 14,
    BYTE_ARR_TYP = 15,
    OBJ_ARR_TYP = 16,
    DOUBLE_ARR_TYP = 19,
    FLOAT_ARR_TYP = 23,
    INVALID_ARR_TYP = 0xff,
    INVALID_TYP = 0xfe,
    BOOLEAN_TYP = 0x20,
};


/** Value for pista_packet.type. */
enum pista_packettype {
    PISTA_DF_MEASUREMENT = 'M',
    PISTA_DF_SETTINGS = 'S',
    PISTA_DF_DEMOGRAPHICS = 'D',
    PISTA_DF_WAVEFORM = 'W',
    PISTA_DF_ANNOTATION = 'A',
    PISTA_DF_CAPABILITIES = 'C',
    PISTA_DF_CONNECTION = 'N',
    PISTA_DF_DISPLAY = 'X',
    PISTA_DF_IDENT = 'I',
    PISTA_DF_MGMT = 'Y',
    PISTA_DF_SECURITY = 'Z',
    PISTA_DF_M2 = '2',
    PISTA_DF_M3 = '3',
    PISTA_DF_TRACE = 't',
    PISTA_DF_ALARM = 'a',
};

/*
 * Use PISTA_API to mark public API symbols, and PISTA_PRIV for private symbols.
 *
 * Variables and functions marked 'static' are private already and don't
 * need PISTA_PRIV. However, functions which are not static (because they need
 * to be used in other pista-internal files) but are also not meant to
 * be part of the public pista API, must use PISTA_PRIV.
 *
 * This uses the 'visibility' feature of gcc (requires gcc >= 4.0).
 *
 * This feature is not available on MinGW/Windows, as it is a feature of
 * ELF files and MinGW/Windows uses PE files.
 *
 * Details: http://gcc.gnu.org/wiki/Visibility
 */

/* Marks public pista API symbols. */
#if defined(SWIG)

#define PISTA_API

#elif defined(_WIN32)

/* if static lib */
#define PISTA_API

/* if using dynamic lib
#if defined(DLL_BUILD)
#define PISTA_API __declspec(dllexport)
#else
#define PISTA_API __declspec(dllimport)
#endif
*/


#else

#define PISTA_API __attribute__((visibility("default")))

#endif

/* Marks private, non-public pista symbols (not part of the API). */
#ifndef _WIN32
#define PISTA_PRIV __attribute__((visibility("hidden")))
#else
#define PISTA_PRIV
#endif


/** Packet layout . */
//struct pista_packet {
    //uint16_t type;
    //const void *payload;
//};

//struct pista_meta {
    //int *FIXME_LISTconfig; //
//};

/** Device instance status, struct pista_dev_inst.status */
enum pista_dev_status {
    	/** Nothing is known about this device, nor requested from it. */
	PISTA_ST_NOT_CONNECTED = 0x0001, //
    	/** Attempting to communicate with the device. */
	PISTA_ST_NEGOTIATING = 0x0011, // both connected and not connected flags set
    	/** The device is connecting and working, but in a standby state. */
	PISTA_ST_STANDBY = 0x0211, // needs to be applied to Infinity
    	/** The device is connected and working in normal operating mode. */
	PISTA_ST_CONNECTED = 0x0010, //
    	/** The device is connected and working though an error appears to exist on the server side of the connection. */
	PISTA_ST_SERVER_ERROR = 0x1010,
	PISTA_ST_DATA_AVAILABLE = 0x0110, // ??
	PISTA_ST_DATA_NOT_AVAIL = 0x0210, // ??
    	/** The device is connected and working in an error state. */
	PISTA_ST_ERROR = 0x2010,

};

/** Discovery management */
enum pista_discovery_event {
	PISTA_DEV_DISCOVER = 0x0001, //
	PISTA_DEV_LOST     = 0x0002, //
};

struct pista_context;  // opaque struct

/**
 * Opaque structure representing a pista device instance.
 *
 * None of the fields of this structure are meant to be accessed directly.
 */
struct pista_dev_inst;

struct pista_data_packet {
    int64_t tm;  /* this may be redundant with the payload...that's OK..dont want to parse the payload to get tm */
    char source_name[16];
    int32_t stream_id;
    int32_t payload_sz;
    void   *payload;

    /*
     * used for enumerating streams...
     */
    struct pista_data_packet *next_stream;
};

struct pista_discovery_info {
    int64_t tm;
    int32_t event_type;         /// discovered, lost, ...
    const char *name;         //
    const char *url;         //
    // struct pista_dev_driver *driver;
};


/** Callback for notification of discovered devices. */
typedef void (*discoveryfunc_t)( const void *priv, const struct pista_discovery_info *pdi );

/** Callback function to send/receive data. */
typedef int (*commfunc_t)( const void *priv, const char *buf, int len);

/** Callback function for data reception. */
typedef int (*pista_receive_data_callback)(int fd, int revents, void *cb_data);
/** Callback function used by a device instance to notify listeners that a data packet is ready. */
typedef int (*eventfunc_t)(
            void *priv, /// private data supplied to the device instance when this callback is registered
            struct pista_data_packet  *cb_data  /// structured data packet of decoded data
            );

#if HAVE_LIBSERIALPORT
int pista_install_libserialport();
#endif

/** Device driver data. */
struct pista_discovery_service {

        /* Driver-specific */
        /** Driver name. Lowercase a-z, 0-9 and dashes (-) only. */
        char *name;
        /** Long name. Verbose driver name shown to user. */
        char *longname;
        /** API version (currently 1).  */
        int api_version;


        /** Called when service is loaded, e.g. program startup. */
        struct pista_discovery_service *(*init) ( struct pista_context *ctx );

        /** Called before service is destroyed. Service must free all resouces held by it. */
        int (*cleanup) (const struct pista_discovery_service *drv);

        // int (*set_option) ( const struct pista_dev_inst *dri, const char *key, const void *arg);
        // void * (*get_option) ( const struct pista_dev_inst *dri, const char *key );
        
        // FIXME: no longer needed.  Can use a non-service-specific method and add to PRIV data using the same -fms-extensions
        // method already in use for similar situations
        int (*set_discovery_handler) (const struct pista_discovery_service *svc, discoveryfunc_t handler, void *priv);


        /** Begin communication. */
        int (*start) (const struct pista_discovery_service *svc);
        /** End communication. */
        int (*stop) (const struct pista_discovery_service *svc);

        /** Tick is called by the framework for each device at the rate of approximately once/second. */
        int (*tick) (const struct pista_discovery_service *svc);

        /** Device driver private data. Initialized by init(). */
        void *priv;
};

struct pista_dev_driver {
        /* Driver-specific */
        /** Driver name. Lowercase a-z, 0-9 and dashes (-) only. */
        char *name;
        /** Long name. Verbose driver name shown to user. */
        char *longname;
        /** API version (currently 1).  */
        int api_version;


        /** Called when driver is loaded, e.g. program startup. */
        struct pista_dev_driver *(*init) ( struct pista_context *ctx );

        /** Called before driver is unloaded. Driver must free all resouces held by it. */
        int (*cleanup) (struct pista_dev_driver *drv);

        /** 
	     * Discovery is handled by a poll/test pair.  The driver can send probe data to the device
         * and test the reply (if any) to verify if the reply complies with the expected answer.
         */
        int (*probe) ( commfunc_t out, void *commfunc_priv );
        int (*verify) (const char data[], size_t len);

        /** Called for each device instance to allocate instance specific data. */
        int (*allocate) ( struct pista_dev_inst *di );

        /** Set value of a configuration option (referenced by "key") either in th driver or a given device instance.
         *  @see pista_config_set(). */
        int (*config_set) ( const struct pista_dev_inst *dri, const char *key, const void *arg);

        /** Get value of a configuration option either in the driver or a given device instance.
         *  @see pista_config_set(). */
        void * (*config_get) ( const struct pista_dev_inst *dri, const char *key );


		/** Dump human readable device information.
          * @see pista_dump().
          */
        int (*dump) ( const struct pista_dev_inst *dri, pista_dump_flags flags );
#ifdef DO_CONFIG_API_XPERIMENTAL
	/**
 	 * make changes to config after connection...such as updating a set of analog output values
	 */
        int (*config_commit) (const struct pista_dev_inst *sdi);
#endif

        /** Release device specific data.  Handle is invalid after this call. */
        int (*destroy) ( struct pista_dev_inst *pdi);

        /** Handle device specific data received by host, such as serial data to be 
 	     * injected into the device data stream and decoded. 
 	     */
        int (*handle) (const struct pista_dev_inst *sdi, const char *dat, int len);

        /** Begin communication. */
        int (*connect) (struct pista_dev_inst *sdi);
        /** End communication. */
        int (*disconnect) (struct pista_dev_inst *sdi);

        /** Tick is called by the framework for each device at the rate of approximately once/second. */
        int (*tick) (const struct pista_dev_inst *sdi);

        /** Devices may be run synchronously or asynchronously. To run synchronously, the poll() method is used.
	 * This method takes one argument, the stream id to be polled.  
	 */
        struct pista_data_packet *(*poll) (const struct pista_dev_inst *di, int sid);

        /** Device driver private data. Initialized by init(). */
        void *priv;
};

struct pista_dev_inst {
        /** Device driver -- backlink */
        struct pista_dev_driver *driver;
        struct pista_dev_inst *next;

        /** Index of device in driver. */
        // int index;
        /** Device instance status: connected, negotiating, not connected. */
        enum pista_dev_status status;
        /** Device model. */
        char *model;
        /** Device version. */
        char *version;

        void *comm_priv;
        void *event_priv;

	    struct pista_data_packet *stream_head;   ///< LL of packets used as stream descs

        /** Device connection information -- serial handle, usb, socket used for driver-to-device communication */
	    commfunc_t comm_func;
        /** Device connection information -- serial handle, usb, socket used for driver-to-application event notification. */
        eventfunc_t event_handler;

        /** Device instance private data */
        void *priv;
};


PISTA_API int pista_init(struct pista_context **ctx);  
PISTA_API int pista_run(struct pista_context *ctx);
PISTA_API int pista_tick( struct pista_context *ctx );
PISTA_API int pista_exit(struct pista_context *ctx);
PISTA_API const char *pista_get_version();

PISTA_API int pista_install_driver(struct pista_context *ctx, struct pista_dev_driver *dev );
PISTA_API struct pista_dev_driver *pista_first_driver( struct pista_context *ctx );
PISTA_API struct pista_dev_driver *pista_next_driver( struct pista_context *ctx, struct pista_dev_driver *dev );
PISTA_API struct pista_dev_driver *pista_find_driver( struct pista_context *ctx, const char *name);
PISTA_API int                      pista_dev_count( struct pista_context *ctx );
PISTA_API struct pista_dev_driver *pista_dev_by_idx( struct pista_context *ctx, int idx );

PISTA_API int pista_allocate( struct pista_dev_driver *dev, struct pista_dev_inst *di );
PISTA_API int pista_set_event_handler( struct pista_dev_inst *di, eventfunc_t handler, void *cb_data);
PISTA_API int pista_set_comm_handler( struct pista_dev_inst *di, commfunc_t handler, void *cb_data);
PISTA_API enum pista_dev_status pista_get_status( struct pista_dev_inst *di );
PISTA_API int pista_connect( struct pista_dev_inst *di );
PISTA_API int pista_disconnect( struct pista_dev_inst *di );
PISTA_API int pista_release( struct pista_dev_inst *di );

PISTA_API int pista_get_stream_count( const struct pista_dev_inst *di );
PISTA_API const struct pista_data_packet *pista_get_stream_by_idx( const struct pista_dev_inst *di, int idx );
PISTA_API const struct pista_data_packet *pista_get_stream_by_sid( const struct pista_dev_inst *di, int stream_id );

PISTA_API struct pista_data_packet *pista_poll( struct pista_dev_inst *di, int sid );

PISTA_API int pista_dump(struct pista_dev_inst *di, pista_dump_flags flags);
PISTA_API int pista_set_dev_option( struct pista_dev_inst *di, const char *key, const void *value );
PISTA_API void *pista_get_dev_option( struct pista_dev_inst *di, const char *key );

PISTA_API struct pista_dev_inst *pista_first_inst( struct pista_dev_driver *dev );
PISTA_API struct pista_dev_inst *pista_next_inst( struct pista_dev_driver *dev, struct pista_dev_inst *di );

//wlb 12-03-18 Functions found in hardware support
PISTA_API int pista_init_data_packet( struct pista_data_packet *pkt, long tm, char *driver_name, int stream_id, int payload_sz, void *payload );
PISTA_API void pista_util_send_connection( struct pista_dev_inst *h, int code );
PISTA_API int64_t pista_get_current_time_with_ms (void);
PISTA_API void pista_set_current_time_delta( int64_t delta );

#ifdef HAVE_LIBSERIALPORT

PISTA_API int pista_attach_lspIO( struct pista_dev_inst *di, 
	const char *port_name);

PISTA_API int pista_config_lspIO(  
	struct pista_dev_inst *di, 
	int baud, char parity, int datab, int stopb, int flow );

// void lspIO_test( struct pista_dev_inst *di );
PISTA_API int pista_detach_lspIO( struct pista_dev_inst *di );
PISTA_API int pista_poll_lspIO( struct pista_dev_inst *di );

#endif

// service management
PISTA_API int pista_service_start( struct pista_discovery_service *service );
PISTA_API int pista_service_tick( struct pista_discovery_service *service );
PISTA_API int pista_service_stop( struct pista_discovery_service *service );
PISTA_API int pista_set_discovery_handler( struct pista_discovery_service *service, discoveryfunc_t discoveryfunc, void *discovery_priv );

// service enumeration
PISTA_API struct pista_discovery_service *pista_first_service( struct pista_context *ctx );
PISTA_API struct pista_discovery_service *pista_find_service( struct pista_context *ctx, const char *name);
PISTA_API int pista_service_count( struct pista_context *ctx);
PISTA_API struct pista_discovery_service *pista_service_by_idx( struct pista_context *ctx, int idx);
PISTA_API struct pista_discovery_service *pista_next_service( struct pista_context *ctx, struct pista_discovery_service *service );


// device probing
PISTA_API int pista_probe( struct pista_dev_driver *dev, commfunc_t writefunc, void *writefunc_priv );
PISTA_API int pista_verify( struct pista_dev_driver *dev, const char data[], size_t len );

// plugin instance management
/**
 * Inputs:
 *  s_name: name used to find plugin
 *  s_lib:  the shared library of the plugin. If NULL, the plugin directory is searched with a name
 *  derived from s_name.
 */
PISTA_API int pista_load_plugin(struct pista_context *pctx, const char *s_name, const char *s_lib );


// device instance management
PISTA_API int pista_dev_inst_count( struct pista_dev_driver *dev );
PISTA_API struct pista_dev_inst *pista_dev_inst_from_idx( struct pista_dev_driver *dev, int idx );
PISTA_API int pista_dev_register_inst( struct pista_dev_driver *dev, struct pista_dev_inst *di );
PISTA_API int pista_dev_unregister_inst( struct pista_dev_driver *dev, struct pista_dev_inst *di );
PISTA_API int pista_dev_register_stream( struct pista_dev_inst *di, struct pista_data_packet *pkt );

// PISTA_API int pista_stream_get_desc_count( const struct pista_stream_desc *str );
// PISTA_API const struct pista_stream_desc *pista_get_stream( const struct pista_dev_inst *di, int streamId );
// PISTA_API const struct pista_item_desc *pista_stream_get_desc( const struct pista_stream_desc *str, int idx );

PISTA_API void pista_dump_packet( const struct pista_data_packet *pkt );
PISTA_API void pista_dump_java( const struct pista_data_packet *pkt );

typedef struct ProtobufCMessage ProtobufCMessage;
typedef struct ProtobufCMessageDescriptor ProtobufCMessageDescriptor;
typedef struct ProtobufCFieldDescriptor ProtobufCFieldDescriptor;

PISTA_API const char * pista_get_field_loc( const ProtobufCFieldDescriptor *fd );
PISTA_API int pista_get_field_offset( const ProtobufCFieldDescriptor *fd );
PISTA_API int pista_get_field_count( const struct pista_data_packet *pkt );
PISTA_API int pista_get_field_spp( const ProtobufCFieldDescriptor *fd);
PISTA_API int pista_get_field_freq( const ProtobufCFieldDescriptor *fd);
PISTA_API int pista_get_field_subtyp( const ProtobufCFieldDescriptor *fd );
PISTA_API int pista_get_field_quantifier( const struct pista_data_packet *pkt, const ProtobufCFieldDescriptor *fd );

PISTA_API int pista_set_named_field_spp( ProtobufCMessage *base, const char *nm, int spp);
PISTA_API int pista_set_named_field_freq( ProtobufCMessage *base, const char *nm, int freq);

PISTA_API const ProtobufCMessageDescriptor *pista_get_message_descriptor( const struct pista_data_packet *pkt );
PISTA_API const ProtobufCFieldDescriptor *pista_get_field_descriptor( const struct pista_data_packet *pkt, int idx );


#ifdef __cplusplus
}
#endif

#endif
