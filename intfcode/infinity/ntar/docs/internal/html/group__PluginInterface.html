<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Network Trace And Retrieval (NTAR) library: Block plugins callbacks</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.1 -->
<h1>Block plugins callbacks</h1><hr><a name="_details"></a><h2>Detailed Description</h2>

<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct__ntar__data__chunk.html">_ntar_data_chunk</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Element of a list representing a generic blob (block of bytes) that have to be written to a trace file, or have been read out of it.  <a href="struct__ntar__data__chunk.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct__ntar__plugin__data.html">_ntar_plugin_data</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This structure is used to uniquely identify a given plugin. It contains the unique identifier of a block, as well as all the pointers to the plugin callbacks.  <a href="struct__ntar__plugin__data.html#_details">More...</a><br></td></tr>
<tr><td colspan="2"><br><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="struct__ntar__data__chunk.html">_ntar_data_chunk</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PluginInterface.html#ga0">ntar_data_chunk</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Element of a list representing a generic blob (block of bytes) that have to be written to a trace file, or have been read out of it.  <a href="#ga0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PluginInterface.html#ga1">plugin_init</a> )(void **plugin_state)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initializes a given plugin state.  <a href="#ga1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PluginInterface.html#ga2">plugin_destroy</a> )(void *plugin_state)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destroys a given plugin state.  <a href="#ga2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PluginInterface.html#ga3">plugin_write_data</a> )(void *plugin_state, void *data, void *data_buffer, size_t *pbuffer_size)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Formats the data of a block in order to be written to some storage.  <a href="#ga3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PluginInterface.html#ga4">plugin_write_option</a> )(void *plugin_state, <a class="el" href="struct__ntar__option.html">ntar_option</a> *option, void *opt_buffer, size_t *pbuffer_size)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Formats the option data of a block option in order to be written to some storage.  <a href="#ga4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PluginInterface.html#ga5">plugin_validate_option</a> )(void *plugin_state, <a class="el" href="struct__ntar__option.html">ntar_option</a> *option)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Verifies that a given option is compatible with a given block.  <a href="#ga5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PluginInterface.html#ga6">plugin_read_data</a> )(void *plugin_state, int byte_order, void *raw_data, size_t raw_data_size, void **data_buffer, size_t *pbuffer_size, size_t *poption_start)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function should decode the data of a block to a library provided memory buffer.  <a href="#ga6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PluginInterface.html#ga7">plugin_read_option</a> )(void *plugin_state, option_header *opt_header, int byte_order, void *opt_buffer, size_t *pbuffer_size)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function should decode the option data of a block to a library provided memory buffer.  <a href="#ga7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="struct__ntar__plugin__data.html">_ntar_plugin_data</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PluginInterface.html#ga8">ntar_plugin_data</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This structure is used to uniquely identify a given plugin. It contains the unique identifier of a block, as well as all the pointers to the plugin callbacks.  <a href="#ga8"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="struct__ntar__plugin__data.html">ntar_plugin_data</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PluginInterface.html#ga10">get_plugin_data</a> (u_int32 block_id)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function returns a pointer to a <a class="el" href="group__PluginInterface.html#ga8">ntar_plugin_data</a> structure uniquely identifying the callbacks of a given block.  <a href="#ga10"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Variables</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="struct__ntar__plugin__data.html">ntar_plugin_data</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PluginInterface.html#ga9">ntar_plugins</a> []</td></tr>

</table>
<hr><h2>Typedef Documentation</h2>
<a class="anchor" name="ga0" doxytag="plugins_int.h::ntar_data_chunk"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">typedef struct <a class="el" href="struct__ntar__data__chunk.html">_ntar_data_chunk</a>
	 <a class="el" href="struct__ntar__data__chunk.html">ntar_data_chunk</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Element of a list representing a generic blob (block of bytes) that have to be written to a trace file, or have been read out of it. 
<p>
A NULL terminated list of such blocks is dumped to disk without any further modification, and no checks are performed on the contents of the internal buffer.     </td>
  </tr>
</table>
<a class="anchor" name="ga8" doxytag="plugins_int.h::ntar_plugin_data"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">typedef struct <a class="el" href="struct__ntar__plugin__data.html">_ntar_plugin_data</a>
	 <a class="el" href="struct__ntar__plugin__data.html">ntar_plugin_data</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This structure is used to uniquely identify a given plugin. It contains the unique identifier of a block, as well as all the pointers to the plugin callbacks. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="ga2" doxytag="plugins_int.h::plugin_destroy"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">typedef int(* <a class="el" href="group__PluginInterface.html#ga2">plugin_destroy</a>)(void *plugin_state)          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Destroys a given plugin state. 
<p>
This callback is called when a block is closed.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>plugin_state</em>&nbsp;</td><td>state of the plugin, as returned by <a class="el" href="group__PluginInterface.html#ga1">plugin_init</a>. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li><a class="el" href="group__ExportedErrorCodes.html#ga0">NTAR_SUCCESS</a></li><li><a class="el" href="group__ExportedErrorCodes.html#ga1">NTAR_FAILURE</a></li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>Each plugin is initialized and destroyed for each read/written block (if the block type matches the plugin type). </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga1" doxytag="plugins_int.h::plugin_init"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">typedef int(* <a class="el" href="group__PluginInterface.html#ga1">plugin_init</a>)(void **plugin_state)          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Initializes a given plugin state. 
<p>
This callback is called whenever the data of a block whose type matches with the given plugin is retrieved (i.e. through <a class="el" href="group__ExportedFuncs.html#ga15">ntar_get_block_data</a> or <a class="el" href="group__ExportedFuncs.html#ga16">ntar_get_block_options</a>) The plugin can initialize its internal structures and return a handle to such data in the parameter plugin_state<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>plugin_state</em>&nbsp;</td><td>Address of a library defined void pointer. On return, the plugin can set the value of this pointer to the state of its internal variables. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li><a class="el" href="group__ExportedErrorCodes.html#ga0">NTAR_SUCCESS</a></li><li><a class="el" href="group__ExportedErrorCodes.html#ga1">NTAR_FAILURE</a></li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>Each plugin is initialized and destroyed for each read/written block (if the block type matches the plugin type). </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga6" doxytag="plugins_int.h::plugin_read_data"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">typedef int(* <a class="el" href="group__PluginInterface.html#ga6">plugin_read_data</a>)(void *plugin_state, int byte_order, void *raw_data, size_t raw_data_size, void **data_buffer, size_t *pbuffer_size, size_t *poption_start)          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This function should decode the data of a block to a library provided memory buffer. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>plugin_state</em>&nbsp;</td><td>State of the plugin, set by <a class="el" href="group__PluginInterface.html#ga1">plugin_init</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>byte_order</em>&nbsp;</td><td>Byte order of the current section. Possible values are HOST_BYTE_ORDER and SWAPPED_HOST_BYTE_ORDER. The callback must always return data in host byte order. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>raw_data</em>&nbsp;</td><td>Raw data of the block, as written to file. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>raw_data_size</em>&nbsp;</td><td>On input, it contains the length of the raw_data buffer, on output the plugin should fill it with the number of bytes actually read from the raw_data buffer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>data_buffer</em>&nbsp;</td><td>Address of the pointer to a library provided buffer that has to be used to return the decoded block data. This address can contain the same pointer passed on input, a pointer to an address in the raw_data buffer, or a pointer to some memory allocated by the plugin in the plugin_init phase. In this last case, such memory should be considered owned by the library up to the next call of plugin_read_data or plugin_destroy. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pbuffer_size</em>&nbsp;</td><td>On input, it points to an integer containing the length of parameter data_buffer. On output, it contains the number of bytes actually used in data_buffer (if the buffer was big enough) or the number of needed bytes, if the data_buffer was too small. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The callback should return one of the following codes:<ul>
<li><a class="el" href="group__ExportedErrorCodes.html#ga0">NTAR_SUCCESS</a></li><li><a class="el" href="group__ExportedErrorCodes.html#ga17">NTAR_FAILURE_SMALLBUFFER</a></li><li><a class="el" href="group__ExportedErrorCodes.html#ga14">NTAR_FAILURE_MALFORMED_BLOCK</a> </li></ul>
</dd></dl>
<dl compact><dt><b><a class="el" href="todo.html#_todo000007">Todo:</a></b></dt><dd>The note on data_buffer in [out] is again confusing. Is it possible that the library calls this function twice (when the fcn succeeds)? I don't think so. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga7" doxytag="plugins_int.h::plugin_read_option"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">typedef int(* <a class="el" href="group__PluginInterface.html#ga7">plugin_read_option</a>)(void *plugin_state, option_header *opt_header, int byte_order, void *opt_buffer, size_t *pbuffer_size)          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This function should decode the option data of a block to a library provided memory buffer. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>plugin_state</em>&nbsp;</td><td>State of the plugin, set by <a class="el" href="group__PluginInterface.html#ga1">plugin_init</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>opt_header</em>&nbsp;</td><td>Header of the option, already converted in host byte order. The data of the option immediately follow the option header. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>byte_order</em>&nbsp;</td><td>Byte order of the current section. Possible values are HOST_BYTE_ORDER and SWAPPED_HOST_BYTE_ORDER. The callback must always return data in host byte order. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>opt_buffer</em>&nbsp;</td><td>Address of the pointer to a library provided buffer that has to be used to return the decoded option data. This address can contain the same pointer passed on input, a pointer to an address in the opt_header buffer, or a pointer to some memory allocated by the plugin in the plugin_init phase. In this last case, such memory should be considered owned by the library up to the next call of plugin_read_option or plugin_destroy. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pbuffer_size</em>&nbsp;</td><td>On input, it points to an integer containing the length of parameter opt_buffer. On output, it contains the number of bytes actually used in opt_buffer (if the buffer was big enough) or the number of needed bytes, if the opt_buffer was too small. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The callback should return one of the following codes:<ul>
<li><a class="el" href="group__ExportedErrorCodes.html#ga0">NTAR_SUCCESS</a></li><li><a class="el" href="group__ExportedErrorCodes.html#ga17">NTAR_FAILURE_SMALLBUFFER</a></li><li><a class="el" href="group__ExportedErrorCodes.html#ga2">NTAR_FAILURE_INVALID_ID</a> if the option code is not supported/recognized by the block plugin.</li><li><a class="el" href="group__ExportedErrorCodes.html#ga1">NTAR_FAILURE</a> in any other case.</li></ul>
</dd></dl>
<p>
<dl compact><dt><b><a class="el" href="todo.html#_todo000008">Todo:</a></b></dt><dd>The note on opt_buffer in [out] is again confusing. Is it possible that the library calls this function twice (when the fcn succeeds)? I don't think so. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga5" doxytag="plugins_int.h::plugin_validate_option"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">typedef int(* <a class="el" href="group__PluginInterface.html#ga5">plugin_validate_option</a>)(void *plugin_state, <a class="el" href="struct__ntar__option.html">ntar_option</a> *option)          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Verifies that a given option is compatible with a given block. 
<p>
This plugin callback is called by the library when the user tries to add an option to a block using <a class="el" href="group__ExportedFuncs.html#ga8">ntar_add_block_option</a>. It should return success only if the option is actually supported by the block *and* the data associated with the option have a proper format.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>plugin_state</em>&nbsp;</td><td>State of the plugin, set by <a class="el" href="group__PluginInterface.html#ga1">plugin_init</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>option</em>&nbsp;</td><td>Pointer to a <a class="el" href="group__ExportedStructs.html#ga0">ntar_option</a>, as passed to <a class="el" href="group__ExportedFuncs.html#ga8">ntar_add_block_option</a>. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The callback should return one of the following codes:<ul>
<li><a class="el" href="group__ExportedErrorCodes.html#ga0">NTAR_SUCCESS</a> if the option is supported and verified.</li><li><a class="el" href="group__ExportedErrorCodes.html#ga2">NTAR_FAILURE_INVALID_ID</a> in every other case. </li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>The library does not request the verification for the standard options COMMENT and END_OF_OPTIONS.<ul>
<li>The plugin should create a NULL terminated linked list of <a class="el" href="group__PluginInterface.html#ga0">ntar_data_chunk</a> elements, using the memory provided in data_buffer. </li></ul>
</dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga3" doxytag="plugins_int.h::plugin_write_data"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">typedef int(* <a class="el" href="group__PluginInterface.html#ga3">plugin_write_data</a>)(void *plugin_state, void *data, void *data_buffer, size_t *pbuffer_size)          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Formats the data of a block in order to be written to some storage. 
<p>
This plugin callback is called by the library when a block should be written to some storage. This callback should format the buffer provided by the user through <a class="el" href="group__ExportedFuncs.html#ga6">ntar_create_block</a> in the correct format that should be written to some storage.. In particular, this function should write the data of a block to a library provided memory buffer.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>plugin_state</em>&nbsp;</td><td>State of the plugin, set by <a class="el" href="group__PluginInterface.html#ga1">plugin_init</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>data</em>&nbsp;</td><td>Data of the block to be written. This is the data that the user provided with <a class="el" href="group__ExportedFuncs.html#ga6">ntar_create_block</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>data_buffer</em>&nbsp;</td><td>Library provided buffer that has to be used to create a linked list of <a class="el" href="group__PluginInterface.html#ga0">ntar_data_chunk</a> elements. The first element in the list should reside at the very beginning of this buffer. The library will write these blocks to the storage. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pbuffer_size</em>&nbsp;</td><td>On input, it points to an integer containing the length of the data_buffer. On output, it contains the number of bytes actually used in data_buffer (if the buffer was big enough) or the number of needed bytes, if the data_buffer was too small. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The callback should return one of the following codes:<ul>
<li><a class="el" href="group__ExportedErrorCodes.html#ga0">NTAR_SUCCESS</a></li><li><a class="el" href="group__ExportedErrorCodes.html#ga17">NTAR_FAILURE_SMALLBUFFER</a> if data_buffer was not big enough</li><li><a class="el" href="group__ExportedErrorCodes.html#ga1">NTAR_FAILURE</a> in every other case. </li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd><ul>
<li>The plugin should create a NULL terminated linked list of <a class="el" href="group__PluginInterface.html#ga0">ntar_data_chunk</a> elements, using the memory provided in data_buffer.</li><li>The plugin can fill the linked list with chunks of memory taken from the data_buffer, or from the data parameter, or from some memory allocated in the <a class="el" href="group__PluginInterface.html#ga1">plugin_init</a> phase. In this last case, such memory should be considered owned by the library up to the next call of <a class="el" href="group__PluginInterface.html#ga3">plugin_write_data</a> or <a class="el" href="group__PluginInterface.html#ga2">plugin_destroy</a>. </li></ul>
</dd></dl>
<dl compact><dt><b><a class="el" href="todo.html#_todo000005">Todo:</a></b></dt><dd>The last note is confusing. Is this callback suposed to be called more than once (supposing it succeeds) for one single block. I don't think so. And this should be clearly stated. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga4" doxytag="plugins_int.h::plugin_write_option"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">typedef int(* <a class="el" href="group__PluginInterface.html#ga4">plugin_write_option</a>)(void *plugin_state, <a class="el" href="struct__ntar__option.html">ntar_option</a> *option, void *opt_buffer, size_t *pbuffer_size)          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Formats the option data of a block option in order to be written to some storage. 
<p>
This plugin callback is called by the library when a block option should be written to some storage. This callback should format the buffer provided by the user through <a class="el" href="group__ExportedFuncs.html#ga8">ntar_add_block_option</a> in the correct format that should be written to some storage.. In particular, this function should write the data of a block option to a library provided memory buffer. <dl compact><dt><b>Note:</b></dt><dd><ul>
<li>The library takes care of writing the two standard options (COMMENT and END_OF_OPTIONS) without calling the specific block option writer call.</li><li>The library provides a set of optimized functions to save the most common option types:<ul>
<li><a class="el" href="group__InternalFuncs.html#ga3">write_option_uint32</a> writes an unsigned 32bit integer to the caller provided buffer.</li><li><a class="el" href="group__InternalFuncs.html#ga2">write_option_uint64</a> writes an unsigned 64bit integer to the caller provided buffer.</li><li><a class="el" href="group__InternalFuncs.html#ga0">write_option_string</a> writes a NULL terminated ANSI string to the caller provided buffer.</li><li><a class="el" href="group__InternalFuncs.html#ga1">write_option_raw</a> writes a blob (with a provided size) to the caller provided buffer, without any further modification.</li></ul>
</li></ul>
</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>plugin_state</em>&nbsp;</td><td>State of the plugin, set by <a class="el" href="group__PluginInterface.html#ga1">plugin_init</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>option</em>&nbsp;</td><td>Pointer to a<a class="el" href="group__ExportedStructs.html#ga0">ntar_option</a>, as passed to <a class="el" href="group__ExportedFuncs.html#ga8">ntar_add_block_option</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>data_buffer</em>&nbsp;</td><td>Library provided buffer that has to be used to create a linked list of <a class="el" href="group__PluginInterface.html#ga0">ntar_data_chunk</a> elements. The first element in the list should reside at the very beginning of this buffer. The library will write these blocks to the storage. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pbuffer_size</em>&nbsp;</td><td>On input, it points to an integer containing the length of the data_buffer. On output, it contains the number of bytes actually used in data_buffer (if the buffer was big enough) or the number of needed bytes, if the data_buffer was too small. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The callback should return one of the following codes:<ul>
<li><a class="el" href="group__ExportedErrorCodes.html#ga0">NTAR_SUCCESS</a></li><li><a class="el" href="group__ExportedErrorCodes.html#ga17">NTAR_FAILURE_SMALLBUFFER</a> if data_buffer was not big enough</li><li><a class="el" href="group__ExportedErrorCodes.html#ga1">NTAR_FAILURE</a> in every other case. </li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd><ul>
<li>The plugin should create a NULL terminated linked list of <a class="el" href="group__PluginInterface.html#ga0">ntar_data_chunk</a> elements, using the memory provided in data_buffer.</li><li>The plugin can fill the linked list with chunks of memory taken from the data_buffer, or from the data parameter, or from some memory allocated in the <a class="el" href="group__PluginInterface.html#ga1">plugin_init</a> phase. In this last case, such memory should be considered owned by the library up to the next call of <a class="el" href="group__PluginInterface.html#ga4">plugin_write_option</a> or <a class="el" href="group__PluginInterface.html#ga2">plugin_destroy</a>. </li></ul>
</dd></dl>
<dl compact><dt><b><a class="el" href="todo.html#_todo000006">Todo:</a></b></dt><dd>The last note is confusing. Is this callback suposed to be called more than once (supposing it succeeds) for one single block. I don't think so. And this should be clearly stated. </dd></dl>
    </td>
  </tr>
</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="ga10" doxytag="plugins_int.h::get_plugin_data"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="struct__ntar__plugin__data.html">ntar_plugin_data</a>* get_plugin_data           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">u_int32&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>block_id</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This function returns a pointer to a <a class="el" href="group__PluginInterface.html#ga8">ntar_plugin_data</a> structure uniquely identifying the callbacks of a given block. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>block_id</em>&nbsp;</td><td>Identifier of the block. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>A pointer to a <a class="el" href="group__PluginInterface.html#ga8">ntar_plugin_data</a> structure uniquely identified by the block ID, or NULL. </dd></dl>
    </td>
  </tr>
</table>
<hr><h2>Variable Documentation</h2>
<a class="anchor" name="ga9" doxytag="plugins_int.h::ntar_plugins"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="struct__ntar__plugin__data.html">ntar_plugin_data</a> <a class="el" href="group__PluginInterface.html#ga9">ntar_plugins</a>[]          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<dl compact><dt><b><a class="el" href="todo.html#_todo000009">Todo:</a></b></dt><dd>The definition of this list here is non-sense, as each source including this file will have its own copy of this array. This does not cause any problem, since all the values in the structures are constant, however it's a waste of memory (and it's not elegant!!). </dd></dl>
    </td>
  </tr>
</table>

<hr>
<p align="right"><font size="2">NTAR documentation. Copyright (c) 2004 - 2005 
Condor Engineering, Inc. All rights reserved.</font></p>
