/**
 * @file intellivue_utils.cxx
 *
 * Reference:
 * 	Data Export Interface Programming Guide
 * 	IntelliVue Patient Monitor
 * 	MP70
 *
 * 	Philips Reorder Part Number: 451261001426
 *
 * @author Michael Szwaja
 */
//=============================================================================

#include "intellivue_utils.h"
#include <ndds/ndds_namespace_cpp.h>
#include <netinet/in.h>
#include <log4cplus/loggingmacros.h>
#include <log4cplus/configurator.h>
#include "PhilipsIntellivueMP70ReturnCodes.h"
#include "intellivue.h"
#include "x73_nomenclature_medical_scada.h"

static const int kAsciiMax = 255;
//  NaN (Not a Number), which has a mantissa of +(2 23 -1) (0x7fffff)
//  NRes (Not at this resolution), which has a mantissa of -(2 23 ) (0x800000)
//  +/- INFINITY, which have mantissa of +/- (2 23 -2) (0x7ffffe, 0x800002).
const int kNaN = 0x7fffff;
const int kNRes = 0x800000;
const int kPlusInfinity = 0x7ffffe;
const int kMinusInfinity = 0x800002;
static const uint16_t kUnicodeDelta = 0x0394;
static const uint16_t kUnicodeSubscriptTwo = 0x2082;
static const char kAsciiUnknown = '!';
static const char kAsciiSubscriptCapitalE = 'E';
static const char kAsciiSubscriptCapitalL = 'L';
static const char kAsciiVWithADotAbove = 'V';
static const char kAsciiDelta = 'd';
static const char kAsciiSubscript2 = '2';
static const char kAsciiStar = '*';
static log4cplus::Logger root_logger = log4cplus::Logger::getRoot();

static const std::vector<std::pair<intellivue::TextId, std::string>> kTextIdToStringVector
{
  {NLS_NOM_EEG_PWR_SPEC_ALPHA_REL_LEFT, "NLS_NOM_EEG_PWR_SPEC_ALPHA_REL_LEFT"},
  {NLS_NOM_EEG_PWR_SPEC_ALPHA_REL_RIGHT, "NLS_NOM_EEG_PWR_SPEC_ALPHA_REL_RIGHT"},
  {NLS_NOM_EEG_PWR_SPEC_BETA_REL_LEFT, "NLS_NOM_EEG_PWR_SPEC_BETA_REL_LEFT"},
  {NLS_NOM_EEG_PWR_SPEC_BETA_REL_RIGHT, "NLS_NOM_EEG_PWR_SPEC_BETA_REL_RIGHT"},
  {NLS_NOM_EEG_PWR_SPEC_DELTA_REL_LEFT, "NLS_NOM_EEG_PWR_SPEC_DELTA_REL_LEFT"},
  {NLS_NOM_EEG_PWR_SPEC_DELTA_REL_RIGHT, "NLS_NOM_EEG_PWR_SPEC_DELTA_REL_RIGHT"},
  {NLS_NOM_EEG_PWR_SPEC_THETA_REL_LEFT, "NLS_NOM_EEG_PWR_SPEC_THETA_REL_LEFT"},
  {NLS_NOM_EEG_PWR_SPEC_THETA_REL_RIGHT, "NLS_NOM_EEG_PWR_SPEC_THETA_REL_RIGHT"},
  {NLS_NOM_CONC_PROT_SER, "NLS_NOM_CONC_PROT_SER"},
  {NLS_NOM_CONC_PRO_URINE, "NLS_NOM_CONC_PRO_URINE"},
  {NLS_NOM_SAT_O2_GEN_1, "NLS_NOM_SAT_O2_GEN_1"},
  {NLS_VUELINK_FLX1_NPS_TEXT_NUM1, "NLS_VUELINK_FLX1_NPS_TEXT_NUM1"},
  {NLS_NOM_RATIO_IE, "NLS_NOM_RATIO_IE"},
  {NLS_NOM_SETT_RATIO_IE, "NLS_NOM_SETT_RATIO_IE"},
  {NLS_VUELINK_FLX1_NPS_TEXT_NUM10, "NLS_VUELINK_FLX1_NPS_TEXT_NUM10"},
  {NLS_VUELINK_FLX1_NPS_TEXT_NUM11, "NLS_VUELINK_FLX1_NPS_TEXT_NUM11"},
  {NLS_VUELINK_FLX1_NPS_TEXT_NUM12, "NLS_VUELINK_FLX1_NPS_TEXT_NUM12"},
  {NLS_VUELINK_FLX1_NPS_TEXT_NUM13, "NLS_VUELINK_FLX1_NPS_TEXT_NUM13"},
  {NLS_VUELINK_FLX1_NPS_TEXT_NUM14, "NLS_VUELINK_FLX1_NPS_TEXT_NUM14"},
  {NLS_VUELINK_FLX1_NPS_TEXT_NUM15, "NLS_VUELINK_FLX1_NPS_TEXT_NUM15"},
  {NLS_VUELINK_FLX1_NPS_TEXT_NUM16, "NLS_VUELINK_FLX1_NPS_TEXT_NUM16"},
  {NLS_VUELINK_FLX1_NPS_TEXT_NUM17, "NLS_VUELINK_FLX1_NPS_TEXT_NUM17"},
  {NLS_VUELINK_FLX1_NPS_TEXT_NUM18, "NLS_VUELINK_FLX1_NPS_TEXT_NUM18"},
  {NLS_VUELINK_FLX1_NPS_TEXT_NUM19, "NLS_VUELINK_FLX1_NPS_TEXT_NUM19"},
  {NLS_NOM_SAT_O2_GEN_2, "NLS_NOM_SAT_O2_GEN_2"},
  {NLS_VUELINK_FLX1_NPS_TEXT_NUM2, "NLS_VUELINK_FLX1_NPS_TEXT_NUM2"},
  {NLS_VUELINK_FLX1_NPS_TEXT_NUM20, "NLS_VUELINK_FLX1_NPS_TEXT_NUM20"},
  {NLS_VUELINK_FLX1_NPS_TEXT_NUM21, "NLS_VUELINK_FLX1_NPS_TEXT_NUM21"},
  {NLS_VUELINK_FLX1_NPS_TEXT_NUM22, "NLS_VUELINK_FLX1_NPS_TEXT_NUM22"},
  {NLS_VUELINK_FLX1_NPS_TEXT_NUM23, "NLS_VUELINK_FLX1_NPS_TEXT_NUM23"},
  {NLS_VUELINK_FLX1_NPS_TEXT_NUM24, "NLS_VUELINK_FLX1_NPS_TEXT_NUM24"},
  {NLS_NOM_SAT_O2_GEN_3, "NLS_NOM_SAT_O2_GEN_3"},
  {NLS_VUELINK_FLX1_NPS_TEXT_NUM3, "NLS_VUELINK_FLX1_NPS_TEXT_NUM3"},
  {NLS_NOM_SAT_O2_GEN_4, "NLS_NOM_SAT_O2_GEN_4"},
  {NLS_VUELINK_FLX1_NPS_TEXT_NUM4, "NLS_VUELINK_FLX1_NPS_TEXT_NUM4"},
  {NLS_VUELINK_FLX1_NPS_TEXT_NUM5, "NLS_VUELINK_FLX1_NPS_TEXT_NUM5"},
  {NLS_VUELINK_FLX1_NPS_TEXT_NUM6, "NLS_VUELINK_FLX1_NPS_TEXT_NUM6"},
  {NLS_VUELINK_FLX1_NPS_TEXT_NUM7, "NLS_VUELINK_FLX1_NPS_TEXT_NUM7"},
  {NLS_VUELINK_FLX1_NPS_TEXT_NUM8, "NLS_VUELINK_FLX1_NPS_TEXT_NUM8"},
  {NLS_VUELINK_FLX1_NPS_TEXT_NUM9, "NLS_VUELINK_FLX1_NPS_TEXT_NUM9"},
  {NLS_NOM_OUTPUT_CARD_INDEX_ACCEL, "NLS_NOM_OUTPUT_CARD_INDEX_ACCEL"},
  {NLS_NOM_TIME_PD_ACT, "NLS_NOM_TIME_PD_ACT"},
  {NLS_NOM_RATIO_TIME_PD_PTT, "NLS_NOM_RATIO_TIME_PD_PTT"},
  {NLS_NOM_AGE, "NLS_NOM_AGE"},
  {NLS_NOM_CONC_PO2_ART_ADJ, "NLS_NOM_CONC_PO2_ART_ADJ"},
  {NLS_NOM_CONC_PO2_CAP_ADJ, "NLS_NOM_CONC_PO2_CAP_ADJ"},
  {NLS_NOM_CONC_PH_GEN_ADJ, "NLS_NOM_CONC_PH_GEN_ADJ"},
  {NLS_NOM_CONC_PH_ART_ADJ, "NLS_NOM_CONC_PH_ART_ADJ"},
  {NLS_NOM_CONC_PH_CAP_ADJ, "NLS_NOM_CONC_PH_CAP_ADJ"},
  {NLS_NOM_CONC_PH_VEN_ADJ, "NLS_NOM_CONC_PH_VEN_ADJ"},
  {NLS_NOM_CONC_PO2_GEN_ADJ, "NLS_NOM_CONC_PO2_GEN_ADJ"},
  {NLS_NOM_CONC_PO2_VEN_ADJ, "NLS_NOM_CONC_PO2_VEN_ADJ"},
  {NLS_NOM_TEMP_AIR_INCUB, "NLS_NOM_TEMP_AIR_INCUB"},
  {NLS_NOM_VENT_CONC_AWAY_CO2_INSP, "NLS_NOM_VENT_CONC_AWAY_CO2_INSP"},
  {NLS_NOM_VENT_FLOW_INSP, "NLS_NOM_VENT_FLOW_INSP"},
  {NLS_NOM_CONC_AWAY_SUM_MAC, "NLS_NOM_CONC_AWAY_SUM_MAC"},
  {NLS_NOM_VOL_MINUTE_AWAY, "NLS_NOM_VOL_MINUTE_AWAY"},
  {NLS_NOM_PRESS_AWAY_MIN, "NLS_NOM_PRESS_AWAY_MIN"},
  {NLS_NOM_PRESS_AWAY, "NLS_NOM_PRESS_AWAY"},
  {NLS_NOM_PRESS_AWAY_INSP, "NLS_NOM_PRESS_AWAY_INSP"},
  {NLS_NOM_AWAY_RESP_RATE, "NLS_NOM_AWAY_RESP_RATE"},
  {NLS_NOM_VENT_RESP_RATE, "NLS_NOM_VENT_RESP_RATE"},
  {NLS_NOM_TEMP_AWAY, "NLS_NOM_TEMP_AWAY"},
  {NLS_NOM_EEG_PWR_SPEC_ALPHA_ABS_LEFT, "NLS_NOM_EEG_PWR_SPEC_ALPHA_ABS_LEFT"},
  {NLS_NOM_EEG_PWR_SPEC_ALPHA_ABS_RIGHT, "NLS_NOM_EEG_PWR_SPEC_ALPHA_ABS_RIGHT"},
  {NLS_NOM_SETT_VENT_CONC_AWAY_O2_LIMIT_HI, "NLS_NOM_SETT_VENT_CONC_AWAY_O2_LIMIT_HI"},
  {NLS_NOM_SETT_VENT_VOL_MINUTE_AWAY_LIMIT_HI, "NLS_NOM_SETT_VENT_VOL_MINUTE_AWAY_LIMIT_HI"},
  {NLS_NOM_SETT_VENT_PRESS_AWAY_LIMIT_HI, "NLS_NOM_SETT_VENT_PRESS_AWAY_LIMIT_HI"},
  {NLS_NOM_SETT_VENT_VOL_TIDAL_LIMIT_HI, "NLS_NOM_SETT_VENT_VOL_TIDAL_LIMIT_HI"},
  {NLS_NOM_SETT_VENT_VOL_MINUTE_AWAY_LIMIT_LO, "NLS_NOM_SETT_VENT_VOL_MINUTE_AWAY_LIMIT_LO"},
  {NLS_NOM_SETT_VENT_CONC_AWAY_O2_LIMIT_LO, "NLS_NOM_SETT_VENT_CONC_AWAY_O2_LIMIT_LO"},
  {NLS_NOM_VENT_PRESS_AWAY_END_EXP_POS_LIMIT_LO, "NLS_NOM_VENT_PRESS_AWAY_END_EXP_POS_LIMIT_LO"},
  {NLS_NOM_SETT_VENT_VOL_TIDAL_LIMIT_LO, "NLS_NOM_SETT_VENT_VOL_TIDAL_LIMIT_LO"},
  {NLS_NOM_SETT_VENT_PRESS_AWAY_SUST_LIMIT_HI, "NLS_NOM_SETT_VENT_PRESS_AWAY_SUST_LIMIT_HI"},
  {NLS_NOM_CONC_ALB_SER, "NLS_NOM_CONC_ALB_SER"},
  {NLS_NOM_ELEC_EVOK_POTL_CRTX_ACOUSTIC_AAI, "NLS_NOM_ELEC_EVOK_POTL_CRTX_ACOUSTIC_AAI"},
  {NLS_NOM_CONC_AP, "NLS_NOM_CONC_AP"},
  {NLS_NOM_CONC_ALPHA_AMYLASE, "NLS_NOM_CONC_ALPHA_AMYLASE"},
  {NLS_NOM_SAT_DIFF_O2_ART_ALV, "NLS_NOM_SAT_DIFF_O2_ART_ALV"},
  {NLS_NOM_VENT_VOL_LUNG_ALV, "NLS_NOM_VENT_VOL_LUNG_ALV"},
  {NLS_NOM_CONC_ALP, "NLS_NOM_CONC_ALP"},
  {NLS_NOM_TEMP_AMBIENT, "NLS_NOM_TEMP_AMBIENT"},
  {NLS_NOM_TIME_PD_APNEA, "NLS_NOM_TIME_PD_APNEA"},
  {NLS_NOM_TIME_PD_aPTT_PE, "NLS_NOM_TIME_PD_aPTT_PE"},
  {NLS_NOM_TIME_PD_aPTT_WB, "NLS_NOM_TIME_PD_aPTT_WB"},
  {NLS_NOM_TEMP_ART, "NLS_NOM_TEMP_ART"},
  {NLS_NOM_PRESS_BLD_ART_ABP, "NLS_NOM_PRESS_BLD_ART_ABP"},
  {NLS_NOM_PRESS_BLD_ART, "NLS_NOM_PRESS_BLD_ART"},
  {NLS_NOM_PRESS_BLD_AORT, "NLS_NOM_PRESS_BLD_AORT"},
  {NLS_NOM_PULS_OXIM_SAT_O2, "NLS_NOM_PULS_OXIM_SAT_O2"},
  {NLS_NOM_CONC_HB_O2_ART, "NLS_NOM_CONC_HB_O2_ART"},
  {NLS_NOM_CONC_DIFF_HB_O2_ATR_VEN, "NLS_NOM_CONC_DIFF_HB_O2_ATR_VEN"},
  {NLS_NOM_CONC_AST, "NLS_NOM_CONC_AST"},
  {NLS_NOM_FLOW_PUMP_HEART_LUNG_AUX, "NLS_NOM_FLOW_PUMP_HEART_LUNG_AUX"},
  {NLS_NOM_VOL_DELIV_PUMP_HEART_LUNG_AUX, "NLS_NOM_VOL_DELIV_PUMP_HEART_LUNG_AUX"},
  {NLS_NOM_TIME_PD_PUMP_HEART_LUNG_AUX_SINCE_STOP, "NLS_NOM_TIME_PD_PUMP_HEART_LUNG_AUX_SINCE_STOP"},
  {NLS_NOM_TIME_PD_PUMP_HEART_LUNG_AUX_SINCE_START, "NLS_NOM_TIME_PD_PUMP_HEART_LUNG_AUX_SINCE_START"},
  {NLS_NOM_TIME_PD_PLEGIA_PUMP_HEART_LUNG_AUX, "NLS_NOM_TIME_PD_PLEGIA_PUMP_HEART_LUNG_AUX"},
  {NLS_NOM_VOL_DELIV_TOTAL_PUMP_HEART_LUNG_AUX, "NLS_NOM_VOL_DELIV_TOTAL_PUMP_HEART_LUNG_AUX"},
  {NLS_NOM_BASE_EXCESS_BLD_ART_CALC, "NLS_NOM_BASE_EXCESS_BLD_ART_CALC"},
  {NLS_NOM_PRESS_AIR_AMBIENT, "NLS_NOM_PRESS_AIR_AMBIENT"},
  {NLS_NOM_BASE_EXCESS_BLD_ART, "NLS_NOM_BASE_EXCESS_BLD_ART"},
  {NLS_NOM_CONC_BASE_EXCESS_ECF, "NLS_NOM_CONC_BASE_EXCESS_ECF"},
  {NLS_NOM_EEG_PWR_SPEC_BETA_ABS_LEFT, "NLS_NOM_EEG_PWR_SPEC_BETA_ABS_LEFT"},
  {NLS_NOM_EEG_PWR_SPEC_BETA_ABS_RIGHT, "NLS_NOM_EEG_PWR_SPEC_BETA_ABS_RIGHT"},
  {NLS_NOM_EEG_BISPECTRAL_INDEX, "NLS_NOM_EEG_BISPECTRAL_INDEX"},
  {NLS_NOM_PRESS_BLD_DIFF, "NLS_NOM_PRESS_BLD_DIFF"},
  {NLS_NOM_PRESS_BLD_DIFF_GEN_1, "NLS_NOM_PRESS_BLD_DIFF_GEN_1"},
  {NLS_NOM_PRESS_BLD_DIFF_GEN_2, "NLS_NOM_PRESS_BLD_DIFF_GEN_2"},
  {NLS_NOM_CONC_BLD_UREA_NITROGEN, "NLS_NOM_CONC_BLD_UREA_NITROGEN"},
  {NLS_NOM_AREA_BODY_SURFACE, "NLS_NOM_AREA_BODY_SURFACE"},
  {NLS_NOM_PRESS_BLD_ART_BRACHIAL, "NLS_NOM_PRESS_BLD_ART_BRACHIAL"},
  {NLS_NOM_AREA_BODY_SURFACE_ACTUAL_BOYD, "NLS_NOM_AREA_BODY_SURFACE_ACTUAL_BOYD"},
  {NLS_NOM_AREA_BODY_SURFACE_ACTUAL_DUBOIS, "NLS_NOM_AREA_BODY_SURFACE_ACTUAL_DUBOIS"},
  {NLS_NOM_ECG_TIME_PD_QT_BASELINE, "NLS_NOM_ECG_TIME_PD_QT_BASELINE"},
  {NLS_NOM_RATIO_BUN_CREA, "NLS_NOM_RATIO_BUN_CREA"},
  {NLS_NOM_EEG_BURST_SUPPRN_INDEX, "NLS_NOM_EEG_BURST_SUPPRN_INDEX"},
  {NLS_NOM_CONC_CA_SER, "NLS_NOM_CONC_CA_SER"},
  {NLS_NOM_CONC_AN_GAP_CALC, "NLS_NOM_CONC_AN_GAP_CALC"},
  {NLS_NOM_CONC_BASE_EXCESS_ECF_CALC, "NLS_NOM_CONC_BASE_EXCESS_ECF_CALC"},
  {NLS_NOM_CONC_HCO3_GEN_CALC, "NLS_NOM_CONC_HCO3_GEN_CALC"},
  {NLS_NOM_CONC_HB_ART_CALC, "NLS_NOM_CONC_HB_ART_CALC"},
  {NLS_NOM_SAT_O2_ART_CALC, "NLS_NOM_SAT_O2_ART_CALC"},
  {NLS_NOM_SAT_O2_CAP_CALC, "NLS_NOM_SAT_O2_CAP_CALC"},
  {NLS_NOM_SAT_O2_CALC, "NLS_NOM_SAT_O2_CALC"},
  {NLS_NOM_SAT_O2_VEN_CALC, "NLS_NOM_SAT_O2_VEN_CALC"},
  {NLS_NOM_CONC_CO2_TOT_CALC, "NLS_NOM_CONC_CO2_TOT_CALC"},
  {NLS_NOM_CONC_CA_URINE, "NLS_NOM_CONC_CA_URINE"},
  {NLS_NOM_CONC_HB_CO_GEN, "NLS_NOM_CONC_HB_CO_GEN"},
  {NLS_NOM_ECG_CARD_BEAT_RATE_BTB, "NLS_NOM_ECG_CARD_BEAT_RATE_BTB"},
  {NLS_NOM_BNP, "NLS_NOM_BNP"},
  {NLS_NOM_CARD_FUNC_INDEX, "NLS_NOM_CARD_FUNC_INDEX"},
  {NLS_NOM_OUTPUT_CARD_INDEX, "NLS_NOM_OUTPUT_CARD_INDEX"},
  {NLS_NOM_OUTPUT_CARD, "NLS_NOM_OUTPUT_CARD"},
  {NLS_NOM_CARDIAC_TROPONIN_I, "NLS_NOM_CARDIAC_TROPONIN_I"},
  {NLS_NOM_CARDIO_PULMONARY_BYPASS_MODE, "NLS_NOM_CARDIO_PULMONARY_BYPASS_MODE"},
  {NLS_NOM_SAT_O2_VEN_CENT, "NLS_NOM_SAT_O2_VEN_CENT"},
  {NLS_NOM_PRESS_BLD_VEN_CENT, "NLS_NOM_PRESS_BLD_VEN_CENT"},
  {NLS_NOM_PRESS_CEREB_PERF, "NLS_NOM_PRESS_CEREB_PERF"},
  {NLS_NOM_TEMP_CEREBRAL, "NLS_NOM_TEMP_CEREBRAL"},
  {NLS_NOM_CONC_CHLORIDE_GEN, "NLS_NOM_CONC_CHLORIDE_GEN"},
  {NLS_NOM_CONC_CHOLESTEROL, "NLS_NOM_CONC_CHOLESTEROL"},
  {NLS_NOM_CONC_CHE, "NLS_NOM_CONC_CHE"},
  {NLS_NOM_CONC_CHLOR_SER, "NLS_NOM_CONC_CHLOR_SER"},
  {NLS_NOM_CONC_CHLOR_URINE, "NLS_NOM_CONC_CHLOR_URINE"},
  {NLS_NOM_AWAY_CO2, "NLS_NOM_AWAY_CO2"},
  {NLS_NOM_FLOW_CO2_PROD_RESP, "NLS_NOM_FLOW_CO2_PROD_RESP"},
  {NLS_NOM_FLOW_CO2_PROD_RESP_TIDAL, "NLS_NOM_FLOW_CO2_PROD_RESP_TIDAL"},
  {NLS_NOM_TIME_PD_COAGULATION, "NLS_NOM_TIME_PD_COAGULATION"},
  {NLS_NOM_CONC_PCO2_ART_ADJ, "NLS_NOM_CONC_PCO2_ART_ADJ"},
  {NLS_NOM_CONC_PCO2_GEN_ADJ, "NLS_NOM_CONC_PCO2_GEN_ADJ"},
  {NLS_NOM_CONC_PCO2_CAP_ADJ, "NLS_NOM_CONC_PCO2_CAP_ADJ"},
  {NLS_NOM_CONC_PCO2_VEN_ADJ, "NLS_NOM_CONC_PCO2_VEN_ADJ"},
  {NLS_NOM_OUTPUT_CARD_CTS, "NLS_NOM_OUTPUT_CARD_CTS"},
  {NLS_NOM_OUTPUT_CARD_INDEX_CTS, "NLS_NOM_OUTPUT_CARD_INDEX_CTS"},
  {NLS_NOM_PRESS_AWAY_CTS_POS, "NLS_NOM_PRESS_AWAY_CTS_POS"},
  {NLS_NOM_TEMP_CORE, "NLS_NOM_TEMP_CORE"},
  {NLS_NOM_TEMP_CORE_GEN_1, "NLS_NOM_TEMP_CORE_GEN_1"},
  {NLS_NOM_TEMP_CORE_GEN_2, "NLS_NOM_TEMP_CORE_GEN_2"},
  {NLS_NOM_AWAY_CORR_COEF, "NLS_NOM_AWAY_CORR_COEF"},
  {NLS_NOM_COMPL_LUNG_PAV, "NLS_NOM_COMPL_LUNG_PAV"},
  {NLS_NOM_VOL_DELIV_PUMP_HEART_LUNG_CARDIOPLEGIA_MAIN, "NLS_NOM_VOL_DELIV_PUMP_HEART_LUNG_CARDIOPLEGIA_MAIN"},
  {NLS_NOM_TIME_PD_PUMP_HEART_LUNG_CARDIOPLEGIA_MAIN_SINCE_STOP, "NLS_NOM_TIME_PD_PUMP_HEART_LUNG_CARDIOPLEGIA_MAIN_SINCE_STOP"},
  {NLS_NOM_TIME_PD_PUMP_HEART_LUNG_CARDIOPLEGIA_MAIN_SINCE_START, "NLS_NOM_TIME_PD_PUMP_HEART_LUNG_CARDIOPLEGIA_MAIN_SINCE_START"},
  {NLS_NOM_TIME_PD_PLEGIA_PUMP_HEART_LUNG_CARDIOPLEGIA_MAIN, "NLS_NOM_TIME_PD_PLEGIA_PUMP_HEART_LUNG_CARDIOPLEGIA_MAIN"},
  {NLS_NOM_VOL_DELIV_TOTAL_PUMP_HEART_LUNG_CARDIOPLEGIA_MAIN, "NLS_NOM_VOL_DELIV_TOTAL_PUMP_HEART_LUNG_CARDIOPLEGIA_MAIN"},
  {NLS_NOM_CONC_CRP, "NLS_NOM_CONC_CRP"},
  {NLS_NOM_CONC_CREA_KIN_MM, "NLS_NOM_CONC_CREA_KIN_MM"},
  {NLS_NOM_CONC_CREA_KIN_MB, "NLS_NOM_CONC_CREA_KIN_MB"},
  {NLS_NOM_CONC_CREA_KIN_SER, "NLS_NOM_CONC_CREA_KIN_SER"},
  {NLS_NOM_CONC_CREA, "NLS_NOM_CONC_CREA"},
  {NLS_NOM_CONC_CREA_CLR, "NLS_NOM_CONC_CREA_CLR"},
  {NLS_NOM_VOL_DELIV_PUMP_HEART_LUNG_CARDIOPLEGIA_SLAVE, "NLS_NOM_VOL_DELIV_PUMP_HEART_LUNG_CARDIOPLEGIA_SLAVE"},
  {NLS_NOM_CEREB_STATE_INDEX, "NLS_NOM_CEREB_STATE_INDEX"},
  {NLS_NOM_TIME_PD_PUMP_HEART_LUNG_CARDIOPLEGIA_SLAVE_SINCE_STOP, "NLS_NOM_TIME_PD_PUMP_HEART_LUNG_CARDIOPLEGIA_SLAVE_SINCE_STOP"},
  {NLS_NOM_TIME_PD_PUMP_HEART_LUNG_CARDIOPLEGIA_SLAVE_SINCE_START, "NLS_NOM_TIME_PD_PUMP_HEART_LUNG_CARDIOPLEGIA_SLAVE_SINCE_START"},
  {NLS_NOM_TIME_PD_PLEGIA_PUMP_HEART_LUNG_CARDIOPLEGIA_SLAVE, "NLS_NOM_TIME_PD_PLEGIA_PUMP_HEART_LUNG_CARDIOPLEGIA_SLAVE"},
  {NLS_NOM_VOL_DELIV_TOTAL_PUMP_HEART_LUNG_CARDIOPLEGIA_SLAVE, "NLS_NOM_VOL_DELIV_TOTAL_PUMP_HEART_LUNG_CARDIOPLEGIA_SLAVE"},
  {NLS_NOM_VOL_URINE_COL, "NLS_NOM_VOL_URINE_COL"},
  {NLS_NOM_FLOW_URINE_PREV_24HR, "NLS_NOM_FLOW_URINE_PREV_24HR"},
  {NLS_NOM_VENT_VOL_AWAY_DEADSP, "NLS_NOM_VENT_VOL_AWAY_DEADSP"},
  {NLS_NOM_ECG_TIME_PD_QTc_DELTA, "NLS_NOM_ECG_TIME_PD_QTc_DELTA"},
  {NLS_NOM_CARD_BEAT_RATE_EXT, "NLS_NOM_CARD_BEAT_RATE_EXT"},
  {NLS_NOM_FLUID_DENS_URINE, "NLS_NOM_FLUID_DENS_URINE"},
  {NLS_NOM_SETT_TEMP, "NLS_NOM_SETT_TEMP"},
  {NLS_NOM_SAT_DIFF_O2_ART_VEN, "NLS_NOM_SAT_DIFF_O2_ART_VEN"},
  {NLS_NOM_PULS_OXIM_SAT_O2_DIFF, "NLS_NOM_PULS_OXIM_SAT_O2_DIFF"},
  {NLS_NOM_TEMP_DIFF, "NLS_NOM_TEMP_DIFF"},
  {NLS_NOM_CONC_BILI_DIRECT, "NLS_NOM_CONC_BILI_DIRECT"},
  {NLS_NOM_EEG_PWR_SPEC_DELTA_ABS_LEFT, "NLS_NOM_EEG_PWR_SPEC_DELTA_ABS_LEFT"},
  {NLS_NOM_EEG_PWR_SPEC_DELTA_ABS_RIGHT, "NLS_NOM_EEG_PWR_SPEC_DELTA_ABS_RIGHT"},
  {NLS_NOM_VENT_TIME_PD_PPV, "NLS_NOM_VENT_TIME_PD_PPV"},
  {NLS_NOM_COMPL_LUNG_DYN, "NLS_NOM_COMPL_LUNG_DYN"},
  {NLS_NOM_RES_AWAY_DYN, "NLS_NOM_RES_AWAY_DYN"},
  {NLS_NOM_EMG_ELEC_POTL_MUSCL, "NLS_NOM_EMG_ELEC_POTL_MUSCL"},
  {NLS_NOM_VOL_VENT_L_END_DIA, "NLS_NOM_VOL_VENT_L_END_DIA"},
  {NLS_NOM_VOL_VENT_L_END_DIA_INDEX, "NLS_NOM_VOL_VENT_L_END_DIA_INDEX"},
  {NLS_NOM_VOL_VENT_L_END_SYS, "NLS_NOM_VOL_VENT_L_END_SYS"},
  {NLS_NOM_VOL_VENT_L_END_SYS_INDEX, "NLS_NOM_VOL_VENT_L_END_SYS_INDEX"},
  {NLS_NOM_CONC_AWAY_AGENT_ET_SEC, "NLS_NOM_CONC_AWAY_AGENT_ET_SEC"},
  {NLS_NOM_SETT_CONC_AWAY_O2, "NLS_NOM_SETT_CONC_AWAY_O2"},
  {NLS_NOM_ELAS_LUNG_PAV, "NLS_NOM_ELAS_LUNG_PAV"},
  {NLS_NOM_ES_RATE, "NLS_NOM_ES_RATE"},
  {NLS_NOM_TEMP_ESOPH, "NLS_NOM_TEMP_ESOPH"},
  {NLS_NOM_FLOW_AWAY_EXP_MAX, "NLS_NOM_FLOW_AWAY_EXP_MAX"},
  {NLS_NOM_FLOW_AWAY_EXP_ET, "NLS_NOM_FLOW_AWAY_EXP_ET"},
  {NLS_NOM_RES_AWAY_EXP, "NLS_NOM_RES_AWAY_EXP"},
  {NLS_NOM_TIME_PD_EXP, "NLS_NOM_TIME_PD_EXP"},
  {NLS_NOM_VOL_AWAY_EXP_TIDAL, "NLS_NOM_VOL_AWAY_EXP_TIDAL"},
  {NLS_NOM_VOL_LUNG_WATER_EXTRA_VASC, "NLS_NOM_VOL_LUNG_WATER_EXTRA_VASC"},
  {NLS_NOM_VOL_LUNG_WATER_EXTRA_VASC_INDEX, "NLS_NOM_VOL_LUNG_WATER_EXTRA_VASC_INDEX"},
  {NLS_NOM_VOL_THERMO_EXTRA_VASC_INDEX, "NLS_NOM_VOL_THERMO_EXTRA_VASC_INDEX"},
  {NLS_NOM_PRESS_BLD_ART_FEMORAL, "NLS_NOM_PRESS_BLD_ART_FEMORAL"},
  {NLS_NOM_CONC_FE_GEN, "NLS_NOM_CONC_FE_GEN"},
  {NLS_NOM_CONC_HB_FETAL, "NLS_NOM_CONC_HB_FETAL"},
  {NLS_NOM_FRACT_EXCR_NA, "NLS_NOM_FRACT_EXCR_NA"},
  {NLS_NOM_VENT_CONC_AWAY_O2_INSP, "NLS_NOM_VENT_CONC_AWAY_O2_INSP"},
  {NLS_NOM_FREE_WATER_CLR, "NLS_NOM_FREE_WATER_CLR"},
  {NLS_NOM_FLOW_AWAY_DESFL, "NLS_NOM_FLOW_AWAY_DESFL"},
  {NLS_NOM_FLOW_AWAY_ENFL, "NLS_NOM_FLOW_AWAY_ENFL"},
  {NLS_NOM_FLOW_AWAY_HALOTH, "NLS_NOM_FLOW_AWAY_HALOTH"},
  {NLS_NOM_FLOW_AWAY_ISOFL, "NLS_NOM_FLOW_AWAY_ISOFL"},
  {NLS_NOM_FLOW_AWAY_SEVOFL, "NLS_NOM_FLOW_AWAY_SEVOFL"},
  {NLS_NOM_FLOW_AWAY_AGENT, "NLS_NOM_FLOW_AWAY_AGENT"},
  {NLS_NOM_FLOW_AWAY_AIR, "NLS_NOM_FLOW_AWAY_AIR"},
  {NLS_NOM_CONC_GGT, "NLS_NOM_CONC_GGT"},
  {NLS_NOM_CONC_AWAY_AGENT, "NLS_NOM_CONC_AWAY_AGENT"},
  {NLS_GASES_NAMES_CONC_AWAY_AGENT1, "NLS_GASES_NAMES_CONC_AWAY_AGENT1"},
  {NLS_GASES_NAMES_CONC_AWAY_AGENT2, "NLS_GASES_NAMES_CONC_AWAY_AGENT2"},
  {NLS_NOM_CONC_AWAY_DESFL, "NLS_NOM_CONC_AWAY_DESFL"},
  {NLS_NOM_CONC_AWAY_ENFL, "NLS_NOM_CONC_AWAY_ENFL"},
  {NLS_NOM_CONC_AWAY_HALOTH, "NLS_NOM_CONC_AWAY_HALOTH"},
  {NLS_NOM_CONC_AWAY_AGENT_INSP, "NLS_NOM_CONC_AWAY_AGENT_INSP"},
  {NLS_NOM_CONC_AWAY_ISOFL, "NLS_NOM_CONC_AWAY_ISOFL"},
  {NLS_EEG_NAMES_CHAN_FREQ1, "NLS_EEG_NAMES_CHAN_FREQ1"},
  {NLS_EEG_NAMES_CHAN_PCNT1, "NLS_EEG_NAMES_CHAN_PCNT1"},
  {NLS_EEG_NAMES_CHAN_FREQ2, "NLS_EEG_NAMES_CHAN_FREQ2"},
  {NLS_EEG_NAMES_CHAN_PCNT2, "NLS_EEG_NAMES_CHAN_PCNT2"},
  {NLS_NOM_COMPL_LUNG, "NLS_NOM_COMPL_LUNG"},
  {NLS_NOM_CONC_AWAY_N2, "NLS_NOM_CONC_AWAY_N2"},
  {NLS_NOM_CONC_AWAY_N2O, "NLS_NOM_CONC_AWAY_N2O"},
  {NLS_NOM_NUM_CALC_CONST, "NLS_NOM_NUM_CALC_CONST"},
  {NLS_NOM_NUM_CATHETER_CONST, "NLS_NOM_NUM_CATHETER_CONST"},
  {NLS_NOM_CONC_AWAY_O2, "NLS_NOM_CONC_AWAY_O2"},
  {NLS_NOM_PRESS_GEN_1, "NLS_NOM_PRESS_GEN_1"},
  {NLS_NOM_PRESS_GEN_2, "NLS_NOM_PRESS_GEN_2"},
  {NLS_NOM_PRESS_GEN_3, "NLS_NOM_PRESS_GEN_3"},
  {NLS_NOM_PRESS_GEN_4, "NLS_NOM_PRESS_GEN_4"},
  {NLS_NOM_PRESS_GEN_5, "NLS_NOM_PRESS_GEN_5"},
  {NLS_NOM_PRESS_GEN_6, "NLS_NOM_PRESS_GEN_6"},
  {NLS_NOM_PRESS_GEN_7, "NLS_NOM_PRESS_GEN_7"},
  {NLS_NOM_PRESS_GEN_8, "NLS_NOM_PRESS_GEN_8"},
  {NLS_NOM_CONC_AWAY_SEVOFL, "NLS_NOM_CONC_AWAY_SEVOFL"},
  {NLS_NOM_TEMP_GEN_1, "NLS_NOM_TEMP_GEN_1"},
  {NLS_NOM_TEMP_GEN_2, "NLS_NOM_TEMP_GEN_2"},
  {NLS_NOM_TEMP_GEN_3, "NLS_NOM_TEMP_GEN_3"},
  {NLS_NOM_TEMP_GEN_4, "NLS_NOM_TEMP_GEN_4"},
  {NLS_NOM_GAS_TCUT, "NLS_NOM_GAS_TCUT"},
  {NLS_NOM_AGE_GEST, "NLS_NOM_AGE_GEST"},
  {NLS_NOM_SCORE_GLAS_COMA, "NLS_NOM_SCORE_GLAS_COMA"},
  {NLS_NOM_FRACT_EJECT, "NLS_NOM_FRACT_EJECT"},
  {NLS_NOM_VOL_GLOBAL_END_DIA, "NLS_NOM_VOL_GLOBAL_END_DIA"},
  {NLS_NOM_VOL_GLOBAL_END_DIA_INDEX, "NLS_NOM_VOL_GLOBAL_END_DIA_INDEX"},
  {NLS_NOM_CONC_GLO_SER, "NLS_NOM_CONC_GLO_SER"},
  {NLS_NOM_CONC_GLU_GEN, "NLS_NOM_CONC_GLU_GEN"},
  {NLS_NOM_CONC_GLU_SER, "NLS_NOM_CONC_GLU_SER"},
  {NLS_NOM_CONC_GLU_URINE, "NLS_NOM_CONC_GLU_URINE"},
  {NLS_NOM_CONC_GOT, "NLS_NOM_CONC_GOT"},
  {NLS_NOM_CONC_GPT, "NLS_NOM_CONC_GPT"},
  {NLS_NOM_CONC_HCT_GEN, "NLS_NOM_CONC_HCT_GEN"},
  {NLS_NOM_CIRCUM_HEAD, "NLS_NOM_CIRCUM_HEAD"},
  {NLS_NOM_CARD_CONTRACT_HEATHER_INDEX, "NLS_NOM_CARD_CONTRACT_HEATHER_INDEX"},
  {NLS_NOM_ECG_CARD_BEAT_RATE, "NLS_NOM_ECG_CARD_BEAT_RATE"},
  {NLS_NOM_HEATING_PWR_TCUT_SENSOR, "NLS_NOM_HEATING_PWR_TCUT_SENSOR"},
  {NLS_NOM_CONC_HB_URINE, "NLS_NOM_CONC_HB_URINE"},
  {NLS_NOM_CONC_HB_ART, "NLS_NOM_CONC_HB_ART"},
  {NLS_NOM_CONC_HDL, "NLS_NOM_CONC_HDL"},
  {NLS_NOM_VENT_VOL_TIDAL_HFV, "NLS_NOM_VENT_VOL_TIDAL_HFV"},
  {NLS_NOM_COEF_GAS_TRAN, "NLS_NOM_COEF_GAS_TRAN"},
  {NLS_NOM_VENT_AMPL_HFV, "NLS_NOM_VENT_AMPL_HFV"},
  {NLS_NOM_FLOW_PUMP_HEART_LUNG_MAIN, "NLS_NOM_FLOW_PUMP_HEART_LUNG_MAIN"},
  {NLS_NOM_HUMID, "NLS_NOM_HUMID"},
  {NLS_NOM_CONC_HCO3_GEN, "NLS_NOM_CONC_HCO3_GEN"},
  {NLS_NOM_GRAD_PRESS_BLD_AORT_POS_MAX, "NLS_NOM_GRAD_PRESS_BLD_AORT_POS_MAX"},
  {NLS_NOM_TEMP_AXIL_INFRARED, "NLS_NOM_TEMP_AXIL_INFRARED"},
  {NLS_NOM_TEMP_CORE_INFRARED, "NLS_NOM_TEMP_CORE_INFRARED"},
  {NLS_NOM_TEMP_ORAL_INFRARED, "NLS_NOM_TEMP_ORAL_INFRARED"},
  {NLS_NOM_TEMP_RECT_INFRARED, "NLS_NOM_TEMP_RECT_INFRARED"},
  {NLS_NOM_TEMP_TYMP_INFRARED, "NLS_NOM_TEMP_TYMP_INFRARED"},
  {NLS_NOM_VOL_INFUS_ACTUAL_TOTAL, "NLS_NOM_VOL_INFUS_ACTUAL_TOTAL"},
  {NLS_NOM_TEMP_INJ, "NLS_NOM_TEMP_INJ"},
  {NLS_NOM_VOL_INJ, "NLS_NOM_VOL_INJ"},
  {NLS_NOM_PT_INTL_NORM_RATIO, "NLS_NOM_PT_INTL_NORM_RATIO"},
  {NLS_NOM_FLOW_AWAY_INSP_MAX, "NLS_NOM_FLOW_AWAY_INSP_MAX"},
  {NLS_NOM_RES_AWAY_INSP, "NLS_NOM_RES_AWAY_INSP"},
  {NLS_NOM_VENT_CONC_AWAY_AGENT_DELTA, "NLS_NOM_VENT_CONC_AWAY_AGENT_DELTA"},
  {NLS_NOM_VENT_CONC_AWAY_DESFL_DELTA, "NLS_NOM_VENT_CONC_AWAY_DESFL_DELTA"},
  {NLS_NOM_VENT_CONC_AWAY_ENFL_DELTA, "NLS_NOM_VENT_CONC_AWAY_ENFL_DELTA"},
  {NLS_NOM_VENT_CONC_AWAY_HALOTH_DELTA, "NLS_NOM_VENT_CONC_AWAY_HALOTH_DELTA"},
  {NLS_NOM_VENT_CONC_AWAY_ISOFL_DELTA, "NLS_NOM_VENT_CONC_AWAY_ISOFL_DELTA"},
  {NLS_NOM_VENT_CONC_AWAY_N2O_DELTA, "NLS_NOM_VENT_CONC_AWAY_N2O_DELTA"},
  {NLS_NOM_VENT_CONC_AWAY_SEVOFL_DELTA, "NLS_NOM_VENT_CONC_AWAY_SEVOFL_DELTA"},
  {NLS_NOM_VOL_MINUTE_AWAY_INSP_HFV, "NLS_NOM_VOL_MINUTE_AWAY_INSP_HFV"},
  {NLS_NOM_VENT_VOL_AWAY_INSP_TIDAL_HFV, "NLS_NOM_VENT_VOL_AWAY_INSP_TIDAL_HFV"},
  {NLS_NOM_CONC_AWAY_AGENT_INSP_SEC, "NLS_NOM_CONC_AWAY_AGENT_INSP_SEC"},
  {NLS_NOM_VOL_AWAY_INSP_TIDAL, "NLS_NOM_VOL_AWAY_INSP_TIDAL"},
  {NLS_NOM_VENT_MODE_MAND_INTERMIT, "NLS_NOM_VENT_MODE_MAND_INTERMIT"},
  {NLS_NOM_PRESS_INTRA_CRAN, "NLS_NOM_PRESS_INTRA_CRAN"},
  {NLS_NOM_PRESS_INTRA_CRAN_1, "NLS_NOM_PRESS_INTRA_CRAN_1"},
  {NLS_NOM_PRESS_INTRA_CRAN_2, "NLS_NOM_PRESS_INTRA_CRAN_2"},
  {NLS_NOM_VOL_BLD_INTRA_THOR, "NLS_NOM_VOL_BLD_INTRA_THOR"},
  {NLS_NOM_VOL_BLD_INTRA_THOR_INDEX, "NLS_NOM_VOL_BLD_INTRA_THOR_INDEX"},
  {NLS_NOM_PRESS_INTRA_UTERAL, "NLS_NOM_PRESS_INTRA_UTERAL"},
  {NLS_NOM_PRESS_AWAY_END_EXP_POS_INTRINSIC, "NLS_NOM_PRESS_AWAY_END_EXP_POS_INTRINSIC"},
  {NLS_NOM_CONC_CA_GEN, "NLS_NOM_CONC_CA_GEN"},
  {NLS_NOM_CONC_CA_GEN_NORM, "NLS_NOM_CONC_CA_GEN_NORM"},
  {NLS_NOM_CONC_MG_ION, "NLS_NOM_CONC_MG_ION"},
  {NLS_NOM_CONC_K_GEN, "NLS_NOM_CONC_K_GEN"},
  {NLS_NOM_CONC_K_SER, "NLS_NOM_CONC_K_SER"},
  {NLS_NOM_TIME_PD_KAOLIN_CEPHALINE, "NLS_NOM_TIME_PD_KAOLIN_CEPHALINE"},
  {NLS_NOM_PULS_OXIM_SAT_O2_ART_LEFT, "NLS_NOM_PULS_OXIM_SAT_O2_ART_LEFT"},
  {NLS_NOM_SAT_O2_LEFT, "NLS_NOM_SAT_O2_LEFT"},
  {NLS_NOM_PULS_OXIM_PERF_REL_LEFT, "NLS_NOM_PULS_OXIM_PERF_REL_LEFT"},
  {NLS_NOM_CONC_LDH, "NLS_NOM_CONC_LDH"},
  {NLS_NOM_CONC_LACT, "NLS_NOM_CONC_LACT"},
  {NLS_NOM_VENT_VOL_LEAK, "NLS_NOM_VENT_VOL_LEAK"},
  {NLS_NOM_PRESS_BLD_ATR_LEFT, "NLS_NOM_PRESS_BLD_ATR_LEFT"},
  {NLS_NOM_WK_CARD_LEFT, "NLS_NOM_WK_CARD_LEFT"},
  {NLS_NOM_WK_CARD_LEFT_INDEX, "NLS_NOM_WK_CARD_LEFT_INDEX"},
  {NLS_NOM_WK_LV_STROKE, "NLS_NOM_WK_LV_STROKE"},
  {NLS_NOM_WK_LV_STROKE_INDEX, "NLS_NOM_WK_LV_STROKE_INDEX"},
  {NLS_NOM_BIRTH_LENGTH, "NLS_NOM_BIRTH_LENGTH"},
  {NLS_NOM_INTENS_LIGHT, "NLS_NOM_INTENS_LIGHT"},
  {NLS_NOM_VOL_LVL_LIQUID_BOTTLE_AGENT, "NLS_NOM_VOL_LVL_LIQUID_BOTTLE_AGENT"},
  {NLS_NOM_VOL_LVL_LIQUID_BOTTLE_DESFL, "NLS_NOM_VOL_LVL_LIQUID_BOTTLE_DESFL"},
  {NLS_NOM_VOL_LVL_LIQUID_BOTTLE_ENFL, "NLS_NOM_VOL_LVL_LIQUID_BOTTLE_ENFL"},
  {NLS_NOM_VOL_LVL_LIQUID_BOTTLE_HALOTH, "NLS_NOM_VOL_LVL_LIQUID_BOTTLE_HALOTH"},
  {NLS_NOM_VOL_LVL_LIQUID_BOTTLE_ISOFL, "NLS_NOM_VOL_LVL_LIQUID_BOTTLE_ISOFL"},
  {NLS_NOM_VOL_LVL_LIQUID_BOTTLE_SEVOFL, "NLS_NOM_VOL_LVL_LIQUID_BOTTLE_SEVOFL"},
  {NLS_NOM_CONC_LDL, "NLS_NOM_CONC_LDL"},
  {NLS_NOM_VENT_VOL_LUNG_TRAPD, "NLS_NOM_VENT_VOL_LUNG_TRAPD"},
  {NLS_NOM_CONC_MG_SER, "NLS_NOM_CONC_MG_SER"},
  {NLS_NOM_VENT_VOL_MINUTE_AWAY_MAND, "NLS_NOM_VENT_VOL_MINUTE_AWAY_MAND"},
  {NLS_NOM_VENT_RESP_RATE_MAND, "NLS_NOM_VENT_RESP_RATE_MAND"},
  {NLS_NOM_VENT_VOL_TIDAL_MAND, "NLS_NOM_VENT_VOL_TIDAL_MAND"},
  {NLS_NOM_VENT_PRESS_AWAY_INSP_MAX, "NLS_NOM_VENT_PRESS_AWAY_INSP_MAX"},
  {NLS_NOM_EEG_FREQ_PWR_SPEC_CRTX_DOM_MEAN_LEFT, "NLS_NOM_EEG_FREQ_PWR_SPEC_CRTX_DOM_MEAN_LEFT"},
  {NLS_NOM_EEG_FREQ_PWR_SPEC_CRTX_DOM_MEAN_RIGHT, "NLS_NOM_EEG_FREQ_PWR_SPEC_CRTX_DOM_MEAN_RIGHT"},
  {NLS_NOM_PRESS_AWAY_INSP_MEAN, "NLS_NOM_PRESS_AWAY_INSP_MEAN"},
  {NLS_NOM_CONC_HB_CORP_MEAN, "NLS_NOM_CONC_HB_CORP_MEAN"},
  {NLS_NOM_HB_CORP_MEAN, "NLS_NOM_HB_CORP_MEAN"},
  {NLS_NOM_VOL_CORP_MEAN, "NLS_NOM_VOL_CORP_MEAN"},
  {NLS_NOM_EEG_FREQ_PWR_SPEC_CRTX_DOM_MEAN, "NLS_NOM_EEG_FREQ_PWR_SPEC_CRTX_DOM_MEAN"},
  {NLS_NOM_CONC_HB_MET_GEN, "NLS_NOM_CONC_HB_MET_GEN"},
  {NLS_NOM_CONC_AWAY_MAC, "NLS_NOM_CONC_AWAY_MAC"},
  {NLS_NOM_SAT_O2_VEN, "NLS_NOM_SAT_O2_VEN"},
  {NLS_NOM_EEG_FREQ_PWR_SPEC_CRTX_MEDIAN_LEFT, "NLS_NOM_EEG_FREQ_PWR_SPEC_CRTX_MEDIAN_LEFT"},
  {NLS_NOM_EEG_FREQ_PWR_SPEC_CRTX_MEDIAN_RIGHT, "NLS_NOM_EEG_FREQ_PWR_SPEC_CRTX_MEDIAN_RIGHT"},
  {NLS_NOM_FLOW_AWAY_N2O, "NLS_NOM_FLOW_AWAY_N2O"},
  {NLS_NOM_TEMP_NASOPH, "NLS_NOM_TEMP_NASOPH"},
  {NLS_NOM_CONC_NA_GEN, "NLS_NOM_CONC_NA_GEN"},
  {NLS_NOM_CONC_NA_SERUM, "NLS_NOM_CONC_NA_SERUM"},
  {NLS_NOM_CONC_NA_URINE, "NLS_NOM_CONC_NA_URINE"},
  {NLS_NOM_PRESS_AWAY_NEG_MAX, "NLS_NOM_PRESS_AWAY_NEG_MAX"},
  {NLS_NOM_NSLOSS, "NLS_NOM_NSLOSS"},
  {NLS_NOM_PRESS_BLD_NONINV, "NLS_NOM_PRESS_BLD_NONINV"},
  {NLS_NOM_VENT_CONC_AWAY_O2_CIRCUIT, "NLS_NOM_VENT_CONC_AWAY_O2_CIRCUIT"},
  {NLS_NOM_SAT_O2, "NLS_NOM_SAT_O2"},
  {NLS_NOM_SAT_O2_TISSUE, "NLS_NOM_SAT_O2_TISSUE"},
  {NLS_NOM_VENT_PRESS_OCCL, "NLS_NOM_VENT_PRESS_OCCL"},
  {NLS_NOM_CREA_OSM, "NLS_NOM_CREA_OSM"},
  {NLS_NOM_C20_PER_C_INDEX, "NLS_NOM_C20_PER_C_INDEX"},
  {NLS_NOM_PULS_OXIM_SAT_O2_PRE_DUCTAL, "NLS_NOM_PULS_OXIM_SAT_O2_PRE_DUCTAL"},
  {NLS_NOM_PULS_OXIM_SAT_O2_POST_DUCTAL, "NLS_NOM_PULS_OXIM_SAT_O2_POST_DUCTAL"},
  {NLS_NOM_SAT_O2_DELIVER, "NLS_NOM_SAT_O2_DELIVER"},
  {NLS_NOM_SAT_O2_DELIVER_INDEX, "NLS_NOM_SAT_O2_DELIVER_INDEX"},
  {NLS_NOM_FLOW_AWAY_O2, "NLS_NOM_FLOW_AWAY_O2"},
  {NLS_NOM_SAT_O2_CONSUMP_INDEX, "NLS_NOM_SAT_O2_CONSUMP_INDEX"},
  {NLS_NOM_SAT_O2_CONSUMP, "NLS_NOM_SAT_O2_CONSUMP"},
  {NLS_NOM_EXTRACT_O2_INDEX, "NLS_NOM_EXTRACT_O2_INDEX"},
  {NLS_NOM_RATIO_SAT_O2_CONSUMP_DELIVER, "NLS_NOM_RATIO_SAT_O2_CONSUMP_DELIVER"},
  {NLS_NOM_SAT_O2_ART, "NLS_NOM_SAT_O2_ART"},
  {NLS_NOM_RATIO_PaO2_FIO2, "NLS_NOM_RATIO_PaO2_FIO2"},
  {NLS_NOM_VENT_ACTIVE, "NLS_NOM_VENT_ACTIVE"},
  {NLS_NOM_CONC_PCO2_GEN, "NLS_NOM_CONC_PCO2_GEN"},
  {NLS_NOM_CONC_PCO2_CAP, "NLS_NOM_CONC_PCO2_CAP"},
  {NLS_NOM_CONC_PCO2_VEN, "NLS_NOM_CONC_PCO2_VEN"},
  {NLS_NOM_CONC_PO2_ART, "NLS_NOM_CONC_PO2_ART"},
  {NLS_NOM_CONC_PO2_CAP, "NLS_NOM_CONC_PO2_CAP"},
  {NLS_NOM_VENT_AWAY_CO2_EXP, "NLS_NOM_VENT_AWAY_CO2_EXP"},
  {NLS_NOM_CONC_PO2_VEN, "NLS_NOM_CONC_PO2_VEN"},
  {NLS_NOM_CONC_PO2_GEN, "NLS_NOM_CONC_PO2_GEN"},
  {NLS_NOM_CONC_PCO2_ART, "NLS_NOM_CONC_PCO2_ART"},
  {NLS_NOM_TIME_PD_PTT, "NLS_NOM_TIME_PD_PTT"},
  {NLS_NOM_PAT_HEIGHT, "NLS_NOM_PAT_HEIGHT"},
  {NLS_NOM_TEMP_BODY, "NLS_NOM_TEMP_BODY"},
  {NLS_NOM_PAT_WEIGHT, "NLS_NOM_PAT_WEIGHT"},
  {NLS_NOM_TIME_PD_PT_PE, "NLS_NOM_TIME_PD_PT_PE"},
  {NLS_NOM_EEG_FREQ_PWR_SPEC_CRTX_PEAK, "NLS_NOM_EEG_FREQ_PWR_SPEC_CRTX_PEAK"},
  {NLS_NOM_RATIO_ART_VEN_SHUNT, "NLS_NOM_RATIO_ART_VEN_SHUNT"},
  {NLS_NOM_PULS_OXIM_PERF_REL, "NLS_NOM_PULS_OXIM_PERF_REL"},
  {NLS_NOM_CONC_PH_ART, "NLS_NOM_CONC_PH_ART"},
  {NLS_NOM_CONC_PH_GEN, "NLS_NOM_CONC_PH_GEN"},
  {NLS_NOM_CONC_PH_VEN, "NLS_NOM_CONC_PH_VEN"},
  {NLS_NOM_CONC_PH_CAP, "NLS_NOM_CONC_PH_CAP"},
  {NLS_NOM_CONC_PH_URINE, "NLS_NOM_CONC_PH_URINE"},
  {NLS_NOM_CONC_P_SER, "NLS_NOM_CONC_P_SER"},
  {NLS_NOM_PLASMA_OSM, "NLS_NOM_PLASMA_OSM"},
  {NLS_NOM_PRESS_RESP_PLAT, "NLS_NOM_PRESS_RESP_PLAT"},
  {NLS_NOM_TIME_PD_RESP_PLAT, "NLS_NOM_TIME_PD_RESP_PLAT"},
  {NLS_NOM_PLTS_CNT, "NLS_NOM_PLTS_CNT"},
  {NLS_NOM_FLOW_PUMP_HEART_LUNG_CARDIOPLEGIA_MAIN, "NLS_NOM_FLOW_PUMP_HEART_LUNG_CARDIOPLEGIA_MAIN"},
  {NLS_NOM_PULS_OXIM_PLETH_GAIN, "NLS_NOM_PULS_OXIM_PLETH_GAIN"},
  {NLS_NOM_VENT_PRESS_AWAY_END_EXP_POS, "NLS_NOM_VENT_PRESS_AWAY_END_EXP_POS"},
  {NLS_NOM_PRESS_AWAY_INSP_MAX, "NLS_NOM_PRESS_AWAY_INSP_MAX"},
  {NLS_NOM_PTC_CNT, "NLS_NOM_PTC_CNT"},
  {NLS_NOM_HEATING_PWR_INCUBATOR, "NLS_NOM_HEATING_PWR_INCUBATOR"},
  {NLS_NOM_EEG_FREQ_PWR_SPEC_CRTX_PEAK_LEFT, "NLS_NOM_EEG_FREQ_PWR_SPEC_CRTX_PEAK_LEFT"},
  {NLS_NOM_EEG_FREQ_PWR_SPEC_CRTX_PEAK_RIGHT, "NLS_NOM_EEG_FREQ_PWR_SPEC_CRTX_PEAK_RIGHT"},
  {NLS_NOM_TEMP_AXIL_PRED, "NLS_NOM_TEMP_AXIL_PRED"},
  {NLS_NOM_TEMP_ORAL_PRED, "NLS_NOM_TEMP_ORAL_PRED"},
  {NLS_NOM_TEMP_RECT_PRED, "NLS_NOM_TEMP_RECT_PRED"},
  {NLS_NOM_ECG_V_P_C_CNT, "NLS_NOM_ECG_V_P_C_CNT"},
  {NLS_NOM_VENT_PRESS_AWAY_PV, "NLS_NOM_VENT_PRESS_AWAY_PV"},
  {NLS_NOM_CONC_PCT, "NLS_NOM_CONC_PCT"},
  {NLS_NOM_TIME_PD_PT, "NLS_NOM_TIME_PD_PT"},
  {NLS_NOM_RATIO_TIME_PD_PT, "NLS_NOM_RATIO_TIME_PD_PT"},
  {NLS_NOM_PRESS_BLD_ART_PULM, "NLS_NOM_PRESS_BLD_ART_PULM"},
  {NLS_NOM_PRESS_BLD_ART_PULM_WEDGE, "NLS_NOM_PRESS_BLD_ART_PULM_WEDGE"},
  {NLS_NOM_PERM_VASC_PULM_INDEX, "NLS_NOM_PERM_VASC_PULM_INDEX"},
  {NLS_NOM_RES_VASC_PULM, "NLS_NOM_RES_VASC_PULM"},
  {NLS_NOM_RES_VASC_PULM_INDEX, "NLS_NOM_RES_VASC_PULM_INDEX"},
  {NLS_PRESS_NAMES_PULSE_FROM_ABP, "NLS_PRESS_NAMES_PULSE_FROM_ABP"},
  {NLS_PRESS_NAMES_PULSE_FROM_AO, "NLS_PRESS_NAMES_PULSE_FROM_AO"},
  {NLS_PRESS_NAMES_PULSE_FROM_ART, "NLS_PRESS_NAMES_PULSE_FROM_ART"},
  {NLS_PRESS_NAMES_PULSE_FROM_BAP, "NLS_PRESS_NAMES_PULSE_FROM_BAP"},
  {NLS_PRESS_NAMES_PULSE_FROM_CVP, "NLS_PRESS_NAMES_PULSE_FROM_CVP"},
  {NLS_PRESS_NAMES_PULSE_FROM_FAP, "NLS_PRESS_NAMES_PULSE_FROM_FAP"},
  {NLS_PRESS_NAMES_PULSE_FROM_IC1, "NLS_PRESS_NAMES_PULSE_FROM_IC1"},
  {NLS_PRESS_NAMES_PULSE_FROM_IC2, "NLS_PRESS_NAMES_PULSE_FROM_IC2"},
  {NLS_PRESS_NAMES_PULSE_FROM_ICP, "NLS_PRESS_NAMES_PULSE_FROM_ICP"},
  {NLS_PRESS_NAMES_PULSE_FROM_LAP, "NLS_PRESS_NAMES_PULSE_FROM_LAP"},
  {NLS_PRESS_NAMES_PULSE_FROM_P1, "NLS_PRESS_NAMES_PULSE_FROM_P1"},
  {NLS_PRESS_NAMES_PULSE_FROM_P2, "NLS_PRESS_NAMES_PULSE_FROM_P2"},
  {NLS_PRESS_NAMES_PULSE_FROM_P3, "NLS_PRESS_NAMES_PULSE_FROM_P3"},
  {NLS_PRESS_NAMES_PULSE_FROM_P4, "NLS_PRESS_NAMES_PULSE_FROM_P4"},
  {NLS_PRESS_NAMES_PULSE_FROM_PAP, "NLS_PRESS_NAMES_PULSE_FROM_PAP"},
  {NLS_PRESS_NAMES_PULSE_FROM_RAP, "NLS_PRESS_NAMES_PULSE_FROM_RAP"},
  {NLS_PRESS_NAMES_PULSE_FROM_UAP, "NLS_PRESS_NAMES_PULSE_FROM_UAP"},
  {NLS_PRESS_NAMES_PULSE_FROM_P, "NLS_PRESS_NAMES_PULSE_FROM_P"},
  {NLS_PRESS_NAMES_PULSE_FROM_UVP, "NLS_PRESS_NAMES_PULSE_FROM_UVP"},
  {NLS_NOM_PRESS_BLD_NONINV_PULS_RATE, "NLS_NOM_PRESS_BLD_NONINV_PULS_RATE"},
  {NLS_NOM_PULS_OXIM_PULS_RATE_TELE, "NLS_NOM_PULS_OXIM_PULS_RATE_TELE"},
  {NLS_NOM_PULS_PRESS_VAR, "NLS_NOM_PULS_PRESS_VAR"},
  {NLS_NOM_PULS_RATE, "NLS_NOM_PULS_RATE"},
  {NLS_NOM_PULS_OXIM_PULS_RATE, "NLS_NOM_PULS_OXIM_PULS_RATE"},
  {NLS_SPO2_NAMES_PULS_OXIM_PULS_RATE_LEFT, "NLS_SPO2_NAMES_PULS_OXIM_PULS_RATE_LEFT"},
  {NLS_SPO2_NAMES_PULS_OXIM_PULS_RATE_POST_DUCTAL, "NLS_SPO2_NAMES_PULS_OXIM_PULS_RATE_POST_DUCTAL"},
  {NLS_SPO2_NAMES_PULS_OXIM_PULS_RATE_PRE_DUCTAL, "NLS_SPO2_NAMES_PULS_OXIM_PULS_RATE_PRE_DUCTAL"},
  {NLS_SPO2_NAMES_PULS_OXIM_PULS_RATE_RIGHT, "NLS_SPO2_NAMES_PULS_OXIM_PULS_RATE_RIGHT"},
  {NLS_NOM_TIME_PD_PUPIL_REACT_LEFT, "NLS_NOM_TIME_PD_PUPIL_REACT_LEFT"},
  {NLS_NOM_TIME_PD_PUPIL_REACT_RIGHT, "NLS_NOM_TIME_PD_PUPIL_REACT_RIGHT"},
  {NLS_NOM_ECG_TIME_PD_QT_GL, "NLS_NOM_ECG_TIME_PD_QT_GL"},
  {NLS_NOM_ECG_TIME_PD_QT_BASELINE_HEART_RATE, "NLS_NOM_ECG_TIME_PD_QT_BASELINE_HEART_RATE"},
  {NLS_NOM_ECG_TIME_PD_QT_HEART_RATE, "NLS_NOM_ECG_TIME_PD_QT_HEART_RATE"},
  {NLS_NOM_ECG_TIME_PD_QTc, "NLS_NOM_ECG_TIME_PD_QTc"},
  {NLS_NOM_PULS_OXIM_SAT_O2_ART_RIGHT, "NLS_NOM_PULS_OXIM_SAT_O2_ART_RIGHT"},
  {NLS_NOM_SAT_O2_RIGHT, "NLS_NOM_SAT_O2_RIGHT"},
  {NLS_NOM_PULS_OXIM_PERF_REL_RIGHT, "NLS_NOM_PULS_OXIM_PERF_REL_RIGHT"},
  {NLS_NOM_BREATH_RAPID_SHALLOW_INDEX, "NLS_NOM_BREATH_RAPID_SHALLOW_INDEX"},
  {NLS_NOM_RATIO_AWAY_RATE_VOL_AWAY, "NLS_NOM_RATIO_AWAY_RATE_VOL_AWAY"},
  {NLS_NOM_RATIO_CONC_BLD_UREA_NITROGEN_CREA_CALC, "NLS_NOM_RATIO_CONC_BLD_UREA_NITROGEN_CREA_CALC"},
  {NLS_NOM_RATIO_AWAY_DEADSP_TIDAL, "NLS_NOM_RATIO_AWAY_DEADSP_TIDAL"},
  {NLS_NOM_RATIO_CONC_URINE_CREA_CALC, "NLS_NOM_RATIO_CONC_URINE_CREA_CALC"},
  {NLS_NOM_TEMP_RECT, "NLS_NOM_TEMP_RECT"},
  {NLS_NOM_RB_CNT, "NLS_NOM_RB_CNT"},
  {NLS_NOM_VENT_CONC_AWAY_O2_DELTA, "NLS_NOM_VENT_CONC_AWAY_O2_DELTA"},
  {NLS_NOM_VENT_VOL_AWAY_DEADSP_REL, "NLS_NOM_VENT_VOL_AWAY_DEADSP_REL"},
  {NLS_NOM_PULS_OXIM_PERF_REL_PRE_DUCTAL, "NLS_NOM_PULS_OXIM_PERF_REL_PRE_DUCTAL"},
  {NLS_NOM_PULS_OXIM_PERF_REL_POST_DUCTAL, "NLS_NOM_PULS_OXIM_PERF_REL_POST_DUCTAL"},
  {NLS_NOM_TIME_PD_EVOK_REMAIN, "NLS_NOM_TIME_PD_EVOK_REMAIN"},
  {NLS_NOM_VENT_PRESS_RESP_PLAT, "NLS_NOM_VENT_PRESS_RESP_PLAT"},
  {NLS_NOM_RESP_RATE, "NLS_NOM_RESP_RATE"},
  {NLS_NOM_AWAY_RESP_RATE_SPIRO, "NLS_NOM_AWAY_RESP_RATE_SPIRO"},
  {NLS_NOM_RET_CNT, "NLS_NOM_RET_CNT"},
  {NLS_NOM_PRESS_BLD_ATR_RIGHT, "NLS_NOM_PRESS_BLD_ATR_RIGHT"},
  {NLS_NOM_WK_CARD_RIGHT, "NLS_NOM_WK_CARD_RIGHT"},
  {NLS_NOM_WK_CARD_RIGHT_INDEX, "NLS_NOM_WK_CARD_RIGHT_INDEX"},
  {NLS_NOM_RIGHT_HEART_FRACT_EJECT, "NLS_NOM_RIGHT_HEART_FRACT_EJECT"},
  {NLS_NOM_WK_RV_STROKE, "NLS_NOM_WK_RV_STROKE"},
  {NLS_NOM_WK_RV_STROKE_INDEX, "NLS_NOM_WK_RV_STROKE_INDEX"},
  {NLS_NOM_SHUNT_RIGHT_LEFT, "NLS_NOM_SHUNT_RIGHT_LEFT"},
  {NLS_NOM_VENT_TIME_PD_RAMP, "NLS_NOM_VENT_TIME_PD_RAMP"},
  {NLS_NOM_RES_AWAY_PAV, "NLS_NOM_RES_AWAY_PAV"},
  {NLS_NOM_BREATH_RAPID_SHALLOW_INDEX_NORM, "NLS_NOM_BREATH_RAPID_SHALLOW_INDEX_NORM"},
  {NLS_NOM_RES_AWAY_EXP_TOTAL, "NLS_NOM_RES_AWAY_EXP_TOTAL"},
  {NLS_NOM_EEG_ELEC_POTL_CRTX_GAIN_LEFT, "NLS_NOM_EEG_ELEC_POTL_CRTX_GAIN_LEFT"},
  {NLS_NOM_EEG_ELEC_POTL_CRTX_GAIN_RIGHT, "NLS_NOM_EEG_ELEC_POTL_CRTX_GAIN_RIGHT"},
  {NLS_NOM_EEG_FREQ_PWR_SPEC_CRTX_SPECTRAL_EDGE_LEFT, "NLS_NOM_EEG_FREQ_PWR_SPEC_CRTX_SPECTRAL_EDGE_LEFT"},
  {NLS_NOM_EEG_FREQ_PWR_SPEC_CRTX_SPECTRAL_EDGE_RIGHT, "NLS_NOM_EEG_FREQ_PWR_SPEC_CRTX_SPECTRAL_EDGE_RIGHT"},
  {NLS_NOM_TEMP_TCUT_SENSOR, "NLS_NOM_TEMP_TCUT_SENSOR"},
  {NLS_NOM_CONC_CREA_SER, "NLS_NOM_CONC_CREA_SER"},
  {NLS_NOM_UREA_SER, "NLS_NOM_UREA_SER"},
  {NLS_NOM_SETT_VENT_RESP_RATE, "NLS_NOM_SETT_VENT_RESP_RATE"},
  {NLS_NOM_SETT_AWAY_RESP_RATE, "NLS_NOM_SETT_AWAY_RESP_RATE"},
  {NLS_NOM_SETT_VENT_TIME_PD_RAMP_AL, "NLS_NOM_SETT_VENT_TIME_PD_RAMP_AL"},
  {NLS_NOM_SETT_VENT_CONC_AWAY_O2_INSP_APNEA, "NLS_NOM_SETT_VENT_CONC_AWAY_O2_INSP_APNEA"},
  {NLS_NOM_SETT_FLOW_AWAY_INSP_APNEA, "NLS_NOM_SETT_FLOW_AWAY_INSP_APNEA"},
  {NLS_NOM_SETT_VENT_PRESS_AWAY_PV_APNEA, "NLS_NOM_SETT_VENT_PRESS_AWAY_PV_APNEA"},
  {NLS_NOM_SETT_RATIO_IE_EXP_PV_APNEA, "NLS_NOM_SETT_RATIO_IE_EXP_PV_APNEA"},
  {NLS_NOM_SETT_VENT_PRESS_AWAY_MAX_PV_APNEA, "NLS_NOM_SETT_VENT_PRESS_AWAY_MAX_PV_APNEA"},
  {NLS_NOM_SETT_RATIO_IE_INSP_PV_APNEA, "NLS_NOM_SETT_RATIO_IE_INSP_PV_APNEA"},
  {NLS_NOM_SETT_VENT_TIME_PD_INSP_PV_APNEA, "NLS_NOM_SETT_VENT_TIME_PD_INSP_PV_APNEA"},
  {NLS_NOM_SETT_VENT_CONC_AWAY_O2_INSP_PV_APNEA, "NLS_NOM_SETT_VENT_CONC_AWAY_O2_INSP_PV_APNEA"},
  {NLS_NOM_SETT_VENT_RESP_RATE_PV_APNEA, "NLS_NOM_SETT_VENT_RESP_RATE_PV_APNEA"},
  {NLS_NOM_SETT_AWAY_RESP_RATE_APNEA, "NLS_NOM_SETT_AWAY_RESP_RATE_APNEA"},
  {NLS_NOM_SETT_VOL_AWAY_TIDAL_APNEA, "NLS_NOM_SETT_VOL_AWAY_TIDAL_APNEA"},
  {NLS_NOM_SETT_APNEA_ALARM_DELAY, "NLS_NOM_SETT_APNEA_ALARM_DELAY"},
  {NLS_NOM_SETT_VOL_AWAY_TIDAL_APPLIED, "NLS_NOM_SETT_VOL_AWAY_TIDAL_APPLIED"},
  {NLS_NOM_SETT_SENS_LEVEL, "NLS_NOM_SETT_SENS_LEVEL"},
  {NLS_NOM_SETT_VENT_AWAY_FLOW_BACKGROUND, "NLS_NOM_SETT_VENT_AWAY_FLOW_BACKGROUND"},
  {NLS_NOM_SETT_PRESS_AWAY_CTS_POS, "NLS_NOM_SETT_PRESS_AWAY_CTS_POS"},
  {NLS_NOM_SETT_VENT_MODE_MAND_CTS_ONOFF, "NLS_NOM_SETT_VENT_MODE_MAND_CTS_ONOFF"},
  {NLS_NOM_SETT_TIME_PD_MSMT, "NLS_NOM_SETT_TIME_PD_MSMT"},
  {NLS_NOM_SETT_VENT_MODE_SIGH, "NLS_NOM_SETT_VENT_MODE_SIGH"},
  {NLS_NOM_SETT_VENT_TIME_PD_EXP, "NLS_NOM_SETT_VENT_TIME_PD_EXP"},
  {NLS_NOM_SETT_FLOW_AWAY_EXP, "NLS_NOM_SETT_FLOW_AWAY_EXP"},
  {NLS_NOM_SETT_VENT_FLOW, "NLS_NOM_SETT_VENT_FLOW"},
  {NLS_NOM_SETT_VENT_FLOW_AWAY_ASSIST, "NLS_NOM_SETT_VENT_FLOW_AWAY_ASSIST"},
  {NLS_NOM_SETT_VENT_FLOW_INSP_TRIG, "NLS_NOM_SETT_VENT_FLOW_INSP_TRIG"},
  {NLS_NOM_SETT_VENT_AWAY_FLOW_BASE, "NLS_NOM_SETT_VENT_AWAY_FLOW_BASE"},
  {NLS_NOM_SETT_VENT_AWAY_FLOW_SENSE, "NLS_NOM_SETT_VENT_AWAY_FLOW_SENSE"},
  {NLS_NOM_SETT_FLOW_AWAY_N2O, "NLS_NOM_SETT_FLOW_AWAY_N2O"},
  {NLS_NOM_SETT_FLOW_AWAY_O2, "NLS_NOM_SETT_FLOW_AWAY_O2"},
  {NLS_NOM_SETT_VENT_O2_PROBE_POSN, "NLS_NOM_SETT_VENT_O2_PROBE_POSN"},
  {NLS_NOM_SETT_VENT_GAS_PROBE_POSN, "NLS_NOM_SETT_VENT_GAS_PROBE_POSN"},
  {NLS_NOM_SETT_HFV_AMPL, "NLS_NOM_SETT_HFV_AMPL"},
  {NLS_NOM_SETT_AWAY_RESP_RATE_HFV, "NLS_NOM_SETT_AWAY_RESP_RATE_HFV"},
  {NLS_NOM_SETT_FLOW_AWAY_HFV, "NLS_NOM_SETT_FLOW_AWAY_HFV"},
  {NLS_NOM_SETT_FLOW_FLUID_PUMP, "NLS_NOM_SETT_FLOW_FLUID_PUMP"},
  {NLS_NOM_SETT_FLOW_AWAY_INSP, "NLS_NOM_SETT_FLOW_AWAY_INSP"},
  {NLS_NOM_SETT_VENT_TIME_PD_INSP, "NLS_NOM_SETT_VENT_TIME_PD_INSP"},
  {NLS_NOM_SETT_VENT_CONC_AWAY_O2_INSP, "NLS_NOM_SETT_VENT_CONC_AWAY_O2_INSP"},
  {NLS_NOM_SETT_VOL_AWAY_INSP_TIDAL, "NLS_NOM_SETT_VOL_AWAY_INSP_TIDAL"},
  {NLS_NOM_SETT_PRESS_AWAY_MIN, "NLS_NOM_SETT_PRESS_AWAY_MIN"},
  {NLS_NOM_SETT_PRESS_AWAY_INSP_MAX_LIMIT_LO, "NLS_NOM_SETT_PRESS_AWAY_INSP_MAX_LIMIT_LO"},
  {NLS_NOM_SETT_VENT_VOL_MINUTE_AWAY_MAND, "NLS_NOM_SETT_VENT_VOL_MINUTE_AWAY_MAND"},
  {NLS_NOM_SETT_VENT_PRESS_AWAY_INSP_MAX, "NLS_NOM_SETT_VENT_PRESS_AWAY_INSP_MAX"},
  {NLS_NOM_SETT_VOL_MINUTE_AWAY, "NLS_NOM_SETT_VOL_MINUTE_AWAY"},
  {NLS_NOM_SETT_VOL_MINUTE_ALARM_DELAY, "NLS_NOM_SETT_VOL_MINUTE_ALARM_DELAY"},
  {NLS_NOM_SETT_VENT_SIGH_MULT_RATE, "NLS_NOM_SETT_VENT_SIGH_MULT_RATE"},
  {NLS_NOM_SETT_VENT_O2_CAL_MODE, "NLS_NOM_SETT_VENT_O2_CAL_MODE"},
  {NLS_NOM_SETT_VENT_ANALY_CONC_GAS_O2_MODE, "NLS_NOM_SETT_VENT_ANALY_CONC_GAS_O2_MODE"},
  {NLS_NOM_SETT_VENT_RESP_RATE_LIMIT_HI_PANT, "NLS_NOM_SETT_VENT_RESP_RATE_LIMIT_HI_PANT"},
  {NLS_NOM_SETT_VENT_TIME_PD_EXP_APRV, "NLS_NOM_SETT_VENT_TIME_PD_EXP_APRV"},
  {NLS_NOM_SETT_VENT_TIME_PD_INSP_APRV, "NLS_NOM_SETT_VENT_TIME_PD_INSP_APRV"},
  {NLS_NOM_SETT_VENT_PRESS_AWAY_EXP_APRV, "NLS_NOM_SETT_VENT_PRESS_AWAY_EXP_APRV"},
  {NLS_NOM_SETT_VENT_PRESS_AWAY_INSP_APRV, "NLS_NOM_SETT_VENT_PRESS_AWAY_INSP_APRV"},
  {NLS_NOM_SETT_FLOW_AWAY_INSP_MAX, "NLS_NOM_SETT_FLOW_AWAY_INSP_MAX"},
  {NLS_NOM_SETT_VENT_PRESS_AWAY_END_EXP_POS, "NLS_NOM_SETT_VENT_PRESS_AWAY_END_EXP_POS"},
  {NLS_NOM_SETT_TIME_PD_RESP_PLAT, "NLS_NOM_SETT_TIME_PD_RESP_PLAT"},
  {NLS_NOM_SETT_PRESS_AWAY_INSP_MAX, "NLS_NOM_SETT_PRESS_AWAY_INSP_MAX"},
  {NLS_NOM_SETT_URINE_BAL_PD, "NLS_NOM_SETT_URINE_BAL_PD"},
  {NLS_NOM_SETT_EVOK_CHARGE, "NLS_NOM_SETT_EVOK_CHARGE"},
  {NLS_NOM_SETT_EVOK_CURR, "NLS_NOM_SETT_EVOK_CURR"},
  {NLS_NOM_SETT_TIME_PD_EVOK, "NLS_NOM_SETT_TIME_PD_EVOK"},
  {NLS_NOM_SETT_TIME_PD_TRAIN_OF_FOUR, "NLS_NOM_SETT_TIME_PD_TRAIN_OF_FOUR"},
  {NLS_NOM_SETT_VENT_AWAY_PRESS_RATE_INCREASE, "NLS_NOM_SETT_VENT_AWAY_PRESS_RATE_INCREASE"},
  {NLS_NOM_SETT_VENT_PRESS_AWAY_END_EXP_POS_INTERMIT, "NLS_NOM_SETT_VENT_PRESS_AWAY_END_EXP_POS_INTERMIT"},
  {NLS_NOM_SETT_VENT_PRESS_AWAY_PV, "NLS_NOM_SETT_VENT_PRESS_AWAY_PV"},
  {NLS_NOM_SETT_PRESS_AWAY_INSP, "NLS_NOM_SETT_PRESS_AWAY_INSP"},
  {NLS_NOM_SETT_RATIO_IE_EXP_PV, "NLS_NOM_SETT_RATIO_IE_EXP_PV"},
  {NLS_NOM_SETT_RATIO_IE_INSP_PV, "NLS_NOM_SETT_RATIO_IE_INSP_PV"},
  {NLS_NOM_SETT_VENT_TIME_PD_INSP_PV, "NLS_NOM_SETT_VENT_TIME_PD_INSP_PV"},
  {NLS_NOM_SETT_VENT_SIGH_RATE, "NLS_NOM_SETT_VENT_SIGH_RATE"},
  {NLS_NOM_SETT_VENT_VOL_TIDAL_SIGH, "NLS_NOM_SETT_VENT_VOL_TIDAL_SIGH"},
  {NLS_NOM_SETT_VENT_O2_SUCTION_MODE, "NLS_NOM_SETT_VENT_O2_SUCTION_MODE"},
  {NLS_NOM_SETT_VENT_MODE_SYNC_MAND_INTERMIT, "NLS_NOM_SETT_VENT_MODE_SYNC_MAND_INTERMIT"},
  {NLS_NOM_SETT_VOL_AWAY_TIDAL, "NLS_NOM_SETT_VOL_AWAY_TIDAL"},
  {NLS_NOM_SETT_FLOW_AWAY_AIR, "NLS_NOM_SETT_FLOW_AWAY_AIR"},
  {NLS_NOM_SETT_FLOW_AWAY_TOT, "NLS_NOM_SETT_FLOW_AWAY_TOT"},
  {NLS_NOM_SETT_VENT_VOL_LUNG_TRAPD, "NLS_NOM_SETT_VENT_VOL_LUNG_TRAPD"},
  {NLS_NOM_SETT_CONC_AWAY_DESFL, "NLS_NOM_SETT_CONC_AWAY_DESFL"},
  {NLS_NOM_SETT_CONC_AWAY_ENFL, "NLS_NOM_SETT_CONC_AWAY_ENFL"},
  {NLS_NOM_SETT_CONC_AWAY_HALOTH, "NLS_NOM_SETT_CONC_AWAY_HALOTH"},
  {NLS_NOM_SETT_CONC_AWAY_ISOFL, "NLS_NOM_SETT_CONC_AWAY_ISOFL"},
  {NLS_NOM_SETT_CONC_AWAY_SEVOFL, "NLS_NOM_SETT_CONC_AWAY_SEVOFL"},
  {NLS_NOM_SETT_FLOW_AWAY_AGENT, "NLS_NOM_SETT_FLOW_AWAY_AGENT"},
  {NLS_NOM_SETT_VENT_RESP_RATE_MODE_MAND_INTERMITT, "NLS_NOM_SETT_VENT_RESP_RATE_MODE_MAND_INTERMITT"},
  {NLS_NOM_SETT_VENT_RESP_RATE_MODE_PPV_INTERMIT_PAP, "NLS_NOM_SETT_VENT_RESP_RATE_MODE_PPV_INTERMIT_PAP"},
  {NLS_NOM_SETT_VENT_VOL_AWAY_ASSIST, "NLS_NOM_SETT_VENT_VOL_AWAY_ASSIST"},
  {NLS_NOM_SETT_VENT_VOL_LIMIT_AL_HI_ONOFF, "NLS_NOM_SETT_VENT_VOL_LIMIT_AL_HI_ONOFF"},
  {NLS_NOM_EEG_BIS_SIG_QUAL_INDEX, "NLS_NOM_EEG_BIS_SIG_QUAL_INDEX"},
  {NLS_NOM_SNR, "NLS_NOM_SNR"},
  {NLS_NOM_TIME_TCUT_SENSOR, "NLS_NOM_TIME_TCUT_SENSOR"},
  {NLS_NOM_TEMP_SKIN, "NLS_NOM_TEMP_SKIN"},
  {NLS_NOM_FLOW_PUMP_HEART_LUNG_SLAVE, "NLS_NOM_FLOW_PUMP_HEART_LUNG_SLAVE"},
  {NLS_NOM_EEG_FREQ_PWR_SPEC_CRTX_SPECTRAL_EDGE, "NLS_NOM_EEG_FREQ_PWR_SPEC_CRTX_SPECTRAL_EDGE"},
  {NLS_NOM_FLOW_PUMP_HEART_LUNG_CARDIOPLEGIA_SLAVE, "NLS_NOM_FLOW_PUMP_HEART_LUNG_CARDIOPLEGIA_SLAVE"},
  {NLS_NOM_PULS_OXIM_SAT_O2_TELE, "NLS_NOM_PULS_OXIM_SAT_O2_TELE"},
  {NLS_NOM_VOL_AWAY_EXP_TIDAL_SPONT, "NLS_NOM_VOL_AWAY_EXP_TIDAL_SPONT"},
  {NLS_NOM_AWAY_RESP_RATE_SPONT, "NLS_NOM_AWAY_RESP_RATE_SPONT"},
  {NLS_NOM_TIME_PD_INSP, "NLS_NOM_TIME_PD_INSP"},
  {NLS_NOM_VENT_VOL_MINUTE_AWAY_SPONT, "NLS_NOM_VENT_VOL_MINUTE_AWAY_SPONT"},
  {NLS_NOM_FLOW_AWAY_MAX_SPONT, "NLS_NOM_FLOW_AWAY_MAX_SPONT"},
  {NLS_NOM_RESP_RATE_SPONT, "NLS_NOM_RESP_RATE_SPONT"},
  {NLS_NOM_VENT_VOL_TIDAL_SPONT, "NLS_NOM_VENT_VOL_TIDAL_SPONT"},
  {NLS_NOM_ECG_AMPL_ST, "NLS_NOM_ECG_AMPL_ST"},
  {NLS_NOM_ECG_AMPL_ST_INDEX, "NLS_NOM_ECG_AMPL_ST_INDEX"},
  {NLS_NOM_ECG_AMPL_ST_BASELINE_AVF, "NLS_NOM_ECG_AMPL_ST_BASELINE_AVF"},
  {NLS_NOM_ECG_AMPL_ST_BASELINE_AVL, "NLS_NOM_ECG_AMPL_ST_BASELINE_AVL"},
  {NLS_NOM_ECG_AMPL_ST_BASELINE_AVR, "NLS_NOM_ECG_AMPL_ST_BASELINE_AVR"},
  {NLS_NOM_ECG_AMPL_ST_BASELINE_I, "NLS_NOM_ECG_AMPL_ST_BASELINE_I"},
  {NLS_NOM_ECG_AMPL_ST_BASELINE_II, "NLS_NOM_ECG_AMPL_ST_BASELINE_II"},
  {NLS_NOM_ECG_AMPL_ST_BASELINE_III, "NLS_NOM_ECG_AMPL_ST_BASELINE_III"},
  {NLS_NOM_ECG_AMPL_ST_BASELINE_V1, "NLS_NOM_ECG_AMPL_ST_BASELINE_V1"},
  {NLS_NOM_ECG_AMPL_ST_BASELINE_V2, "NLS_NOM_ECG_AMPL_ST_BASELINE_V2"},
  {NLS_NOM_ECG_AMPL_ST_BASELINE_V3, "NLS_NOM_ECG_AMPL_ST_BASELINE_V3"},
  {NLS_NOM_ECG_AMPL_ST_BASELINE_V4, "NLS_NOM_ECG_AMPL_ST_BASELINE_V4"},
  {NLS_NOM_ECG_AMPL_ST_BASELINE_V5, "NLS_NOM_ECG_AMPL_ST_BASELINE_V5"},
  {NLS_NOM_ECG_AMPL_ST_BASELINE_V6, "NLS_NOM_ECG_AMPL_ST_BASELINE_V6"},
  {NLS_NOM_COMPL_LUNG_STATIC, "NLS_NOM_COMPL_LUNG_STATIC"},
  {NLS_NOM_RES_AWAY, "NLS_NOM_RES_AWAY"},
  {NLS_NOM_VOL_BLD_STROKE_INDEX, "NLS_NOM_VOL_BLD_STROKE_INDEX"},
  {NLS_NOM_VOL_BLD_STROKE, "NLS_NOM_VOL_BLD_STROKE"},
  {NLS_NOM_VOL_BLD_STROKE_VAR, "NLS_NOM_VOL_BLD_STROKE_VAR"},
  {NLS_NOM_SCORE_EYE_SUBSC_GLAS_COMA, "NLS_NOM_SCORE_EYE_SUBSC_GLAS_COMA"},
  {NLS_NOM_SCORE_MOTOR_SUBSC_GLAS_COMA, "NLS_NOM_SCORE_MOTOR_SUBSC_GLAS_COMA"},
  {NLS_NOM_SCORE_SUBSC_VERBAL_GLAS_COMA, "NLS_NOM_SCORE_SUBSC_VERBAL_GLAS_COMA"},
  {NLS_NOM_FLOW_PUMP_HEART_LUNG_SUCTION, "NLS_NOM_FLOW_PUMP_HEART_LUNG_SUCTION"},
  {NLS_NOM_EEG_RATIO_SUPPRN, "NLS_NOM_EEG_RATIO_SUPPRN"},
  {NLS_NOM_RESP_BREATH_ASSIST_CNT, "NLS_NOM_RESP_BREATH_ASSIST_CNT"},
  {NLS_NOM_RES_VASC_SYS, "NLS_NOM_RES_VASC_SYS"},
  {NLS_NOM_RES_VASC_SYS_INDEX, "NLS_NOM_RES_VASC_SYS_INDEX"},
  {NLS_NOM_PULS_OXIM_PERF_REL_TELE, "NLS_NOM_PULS_OXIM_PERF_REL_TELE"},
  {NLS_NOM_TEMP_BLD, "NLS_NOM_TEMP_BLD"},
  {NLS_NOM_TEMP_INFRARED, "NLS_NOM_TEMP_INFRARED"},
  {NLS_NOM_TEMP_VESICAL, "NLS_NOM_TEMP_VESICAL"},
  {NLS_NOM_EEG_PWR_SPEC_THETA_ABS_LEFT, "NLS_NOM_EEG_PWR_SPEC_THETA_ABS_LEFT"},
  {NLS_NOM_EEG_PWR_SPEC_THETA_ABS_RIGHT, "NLS_NOM_EEG_PWR_SPEC_THETA_ABS_RIGHT"},
  {NLS_NOM_VOL_FLUID_THORAC, "NLS_NOM_VOL_FLUID_THORAC"},
  {NLS_NOM_VOL_FLUID_THORAC_INDEX, "NLS_NOM_VOL_FLUID_THORAC_INDEX"},
  {NLS_NOM_TIME_PD_THROMBIN, "NLS_NOM_TIME_PD_THROMBIN"},
  {NLS_NOM_TIME_PD_THROMBOPLAS, "NLS_NOM_TIME_PD_THROMBOPLAS"},
  {NLS_NOM_VOL_AWAY_TIDAL, "NLS_NOM_VOL_AWAY_TIDAL"},
  {NLS_NOM_VOL_AWAY_TIDAL_PSV, "NLS_NOM_VOL_AWAY_TIDAL_PSV"},
  {NLS_NOM_AWAY_TC, "NLS_NOM_AWAY_TC"},
  {NLS_NOM_TIME_PD_FROM_LAST_MSMT, "NLS_NOM_TIME_PD_FROM_LAST_MSMT"},
  {NLS_NOM_RATIO_INSP_TOTAL_BREATH_SPONT, "NLS_NOM_RATIO_INSP_TOTAL_BREATH_SPONT"},
  {NLS_NOM_CONC_BILI_TOT, "NLS_NOM_CONC_BILI_TOT"},
  {NLS_NOM_FLOW_AWAY_TOT, "NLS_NOM_FLOW_AWAY_TOT"},
  {NLS_NOM_CONC_tCA_SER, "NLS_NOM_CONC_tCA_SER"},
  {NLS_NOM_CONC_CO2_TOT, "NLS_NOM_CONC_CO2_TOT"},
  {NLS_NOM_EEG_PWR_SPEC_TOT, "NLS_NOM_EEG_PWR_SPEC_TOT"},
  {NLS_EEG_NAMES_CHAN_TP1, "NLS_EEG_NAMES_CHAN_TP1"},
  {NLS_EEG_NAMES_CHAN_TP2, "NLS_EEG_NAMES_CHAN_TP2"},
  {NLS_NOM_CONC_PROT_TOT, "NLS_NOM_CONC_PROT_TOT"},
  {NLS_NOM_VOL_URINE_BAL_PD_INSTANT, "NLS_NOM_VOL_URINE_BAL_PD_INSTANT"},
  {NLS_NOM_EEG_PWR_SPEC_TOT_LEFT, "NLS_NOM_EEG_PWR_SPEC_TOT_LEFT"},
  {NLS_NOM_EEG_PWR_SPEC_TOT_RIGHT, "NLS_NOM_EEG_PWR_SPEC_TOT_RIGHT"},
  {NLS_NOM_VENT_PRESS_AWAY_END_EXP_POS_TOTAL, "NLS_NOM_VENT_PRESS_AWAY_END_EXP_POS_TOTAL"},
  {NLS_NOM_TRAIN_OF_FOUR_CNT, "NLS_NOM_TRAIN_OF_FOUR_CNT"},
  {NLS_NOM_RATIO_TRAIN_OF_FOUR, "NLS_NOM_RATIO_TRAIN_OF_FOUR"},
  {NLS_NOM_TRAIN_OF_FOUR_1, "NLS_NOM_TRAIN_OF_FOUR_1"},
  {NLS_NOM_TRAIN_OF_FOUR_2, "NLS_NOM_TRAIN_OF_FOUR_2"},
  {NLS_NOM_TRAIN_OF_FOUR_3, "NLS_NOM_TRAIN_OF_FOUR_3"},
  {NLS_NOM_TRAIN_OF_FOUR_4, "NLS_NOM_TRAIN_OF_FOUR_4"},
  {NLS_NOM_CO2_TCUT, "NLS_NOM_CO2_TCUT"},
  {NLS_NOM_O2_TCUT, "NLS_NOM_O2_TCUT"},
  {NLS_NOM_IMPED_TTHOR, "NLS_NOM_IMPED_TTHOR"},
  {NLS_NOM_CONC_TGL, "NLS_NOM_CONC_TGL"},
  {NLS_NOM_TWITCH_AMPL, "NLS_NOM_TWITCH_AMPL"},
  {NLS_NOM_TEMP_TYMP, "NLS_NOM_TEMP_TYMP"},
  {NLS_NOM_PRESS_BLD_ART_UMB, "NLS_NOM_PRESS_BLD_ART_UMB"},
  {NLS_NOM_PRESS_BLD_VEN_UMB, "NLS_NOM_PRESS_BLD_VEN_UMB"},
  {NLS_NOM_PRESS_BLD, "NLS_NOM_PRESS_BLD"},
  {NLS_NOM_TEMP, "NLS_NOM_TEMP"},
  {NLS_NOM_CONC_UREA_GEN, "NLS_NOM_CONC_UREA_GEN"},
  {NLS_NOM_FLOW_URINE_INSTANT, "NLS_NOM_FLOW_URINE_INSTANT"},
  {NLS_NOM_VOL_URINE_SHIFT, "NLS_NOM_VOL_URINE_SHIFT"},
  {NLS_NOM_CONC_K_URINE_EXCR, "NLS_NOM_CONC_K_URINE_EXCR"},
  {NLS_NOM_CONC_CREA_URINE, "NLS_NOM_CONC_CREA_URINE"},
  {NLS_NOM_CONC_OSM_URINE, "NLS_NOM_CONC_OSM_URINE"},
  {NLS_NOM_RATIO_URINE_SER_OSM, "NLS_NOM_RATIO_URINE_SER_OSM"},
  {NLS_NOM_CONC_K_URINE, "NLS_NOM_CONC_K_URINE"},
  {NLS_NOM_RATIO_CONC_URINE_CREA_SER, "NLS_NOM_RATIO_CONC_URINE_CREA_SER"},
  {NLS_NOM_CONC_NA_EXCR, "NLS_NOM_CONC_NA_EXCR"},
  {NLS_NOM_RATIO_CONC_URINE_NA_K, "NLS_NOM_RATIO_CONC_URINE_NA_K"},
  {NLS_NOM_CONC_UREA_URINE, "NLS_NOM_CONC_UREA_URINE"},
  {NLS_NOM_VOL_URINE_BAL_PD, "NLS_NOM_VOL_URINE_BAL_PD"},
  {NLS_NOM_CONC_HB_O2_VEN, "NLS_NOM_CONC_HB_O2_VEN"},
  {NLS_NOM_TEMP_VEN, "NLS_NOM_TEMP_VEN"},
  {NLS_NOM_VENT_FLOW_RATIO_PERF_ALV_INDEX, "NLS_NOM_VENT_FLOW_RATIO_PERF_ALV_INDEX"},
  {NLS_NOM_CAPAC_VITAL, "NLS_NOM_CAPAC_VITAL"},
  {NLS_NOM_TIME_PD_PT_WB, "NLS_NOM_TIME_PD_PT_WB"},
  {NLS_NOM_WEIGHT_URINE_COL, "NLS_NOM_WEIGHT_URINE_COL"},
  {NLS_NOM_WB_CNT, "NLS_NOM_WB_CNT"},
};

DicesRcPhilipsIntellivueMP70 IntellivueUtils::IsValidSetResultAttribute(
  const intellivue::OIDType attribute_id,
  bool* is_valid)
{
  static const char* sfn = "IntellivueUtils::IsValidSetResultAttribute() ";
  if (!is_valid)
  {
    LOG4CPLUS_ERROR(root_logger, sfn << "Function argument is_valid is a null "
      "pointer.");
    return DicesRcPhilipsIntellivueMP70::NULL_POINTER_FUNCTION_ARGUMENT_FAILURE;
  }
  *is_valid = false;

  switch (attribute_id)
  {
    case NOM_ATTR_POLL_RTSA_PRIO_LIST:
      *is_valid = true;
      break;
    default:
      LOG4CPLUS_WARN(root_logger, sfn << "Set result "
        "should not contain attribute_id: " << static_cast<int>(attribute_id));
      break;
  }

  return DicesRcPhilipsIntellivueMP70::OK;
}

DicesRcPhilipsIntellivueMP70 IntellivueUtils::
IsValidMDSCreateEventReportAttribute(
  const intellivue::OIDType attribute_id,
  bool* is_valid)
{
  static const char* sfn = "IntellivueUtils::"
    "IsValidMDSCreateEventReportAttribute() ";
  if (!is_valid)
  {
    LOG4CPLUS_ERROR(root_logger, sfn << "Function argument is_valid is a null "
      "pointer.");
    return DicesRcPhilipsIntellivueMP70::NULL_POINTER_FUNCTION_ARGUMENT_FAILURE;
  }
  *is_valid = false;

  switch (attribute_id)
  {
    case NOM_ATTR_ID_HANDLE:
    case NOM_ATTR_SYS_TYPE:
    case NOM_ATTR_ID_MODEL:
    case NOM_ATTR_SYS_ID:
    case NOM_ATTR_NOM_VERS:
    case NOM_ATTR_LOCALIZN:
    case NOM_ATTR_SYS_SPECN:
    case NOM_ATTR_MDS_GEN_INFO:
    case NOM_ATTR_ID_PROD_SPECN:
    case NOM_ATTR_VMS_MDS_STAT:
    case NOM_ATTR_ID_BED_LABEL:
    case NOM_ATTR_MODE_OP:
    case NOM_ATTR_AREA_APPL:
    case NOM_ATTR_TIME_ABS:
    case NOM_ATTR_TIME_REL:
    case NOM_ATTR_ALTITUDE:
    case NOM_ATTR_LINE_FREQ:
    case NOM_ATTR_ID_ASSOC_NO:
      *is_valid = true;
      break;
    default:
      LOG4CPLUS_INFO(root_logger, sfn << "MDS create event report "
        "should not contain attribute_id: " << static_cast<int>(attribute_id));
      break;
  }

  return DicesRcPhilipsIntellivueMP70::OK;
}

DicesRcPhilipsIntellivueMP70 IntellivueUtils::
IsValidAssociationResponseAttribute(
  const intellivue::OIDType attribute_id,
  bool* is_valid)
{
  static const char* sfn = "IntellivueUtils::"
    "IsValidAssociationResponseAttribute() ";
  if (!is_valid)
  {
    LOG4CPLUS_ERROR(root_logger, sfn << "Function argument is_valid is a null "
      "pointer.");
    return DicesRcPhilipsIntellivueMP70::NULL_POINTER_FUNCTION_ARGUMENT_FAILURE;
  }
  *is_valid = false;

  switch (attribute_id)
  {
    case NOM_POLL_PROFILE_SUPPORT:
    case NOM_ATTR_POLL_PROFILE_EXT:
      *is_valid = true;
      break;
    default:
      LOG4CPLUS_WARN(root_logger, sfn << "association response message "
        "should not contain attribute_id: " << static_cast<int>(attribute_id));
      break;
  }

  return DicesRcPhilipsIntellivueMP70::OK;
}

DicesRcPhilipsIntellivueMP70 IntellivueUtils::IsValidConnectIndicationAttribute(
  const intellivue::OIDType attribute_id,
  bool* is_valid)
{
  static const char* sfn = "IntellivueUtils::IsValidConnectIndicationAttribute() ";
  if (!is_valid)
  {
    LOG4CPLUS_ERROR(root_logger, sfn << "Function argument is_valid is a null "
      "pointer.");
    return DicesRcPhilipsIntellivueMP70::NULL_POINTER_FUNCTION_ARGUMENT_FAILURE;
  }
  *is_valid = false;

  switch (attribute_id)
  {
    case NOM_ATTR_SYS_TYPE:
    case NOM_ATTR_PCOL_SUPPORT:
    case NOM_ATTR_LOCALIZN:
    case NOM_ATTR_NET_ADDR_INFO:
      *is_valid = true;
      break;
    default:
      LOG4CPLUS_WARN(root_logger, sfn << "Connect indication message "
        "should not contain attribute_id: " << static_cast<int>(attribute_id));
      break;
  }

  return DicesRcPhilipsIntellivueMP70::OK;
}

DicesRcPhilipsIntellivueMP70 IntellivueUtils::IsValidAttribute(
  const intellivue::OIDType code,
  const intellivue::OIDType attribute_id,
  bool* is_valid)
{
  static const char* sfn = "IntellivueUtils::IsValidAttribute() ";
  if (!is_valid)
  {
    LOG4CPLUS_ERROR(root_logger, sfn << "Function argument is_valid is a null "
      "pointer.");
    return DicesRcPhilipsIntellivueMP70::NULL_POINTER_FUNCTION_ARGUMENT_FAILURE;
  }
  *is_valid = false;

  switch (code)
  {
    case NOM_MOC_VMS_MDS:
    {
      switch (attribute_id)
      {
        case NOM_ATTR_ID_HANDLE:
        case NOM_ATTR_SYS_TYPE:
        case NOM_ATTR_ID_MODEL:
        case NOM_ATTR_SYS_ID:
        case NOM_ATTR_NOM_VERS:
        case NOM_ATTR_LOCALIZN:
        case NOM_ATTR_SYS_SPECN:
        case NOM_ATTR_MDS_GEN_INFO:
        case NOM_ATTR_ID_PROD_SPECN:
        case NOM_ATTR_VMS_MDS_STAT:
        case NOM_ATTR_ID_BED_LABEL:
        case NOM_ATTR_MODE_OP:
        case NOM_ATTR_AREA_APPL:
        case NOM_ATTR_TIME_ABS:
        case NOM_ATTR_TIME_REL:
        case NOM_ATTR_ALTITUDE:
        case NOM_ATTR_LINE_FREQ:
        case NOM_ATTR_ID_ASSOC_NO:
          *is_valid = true;
          break;
        default:
          LOG4CPLUS_INFO(root_logger, sfn << "MDS poll result should not "
            "contain attribute_id: " << static_cast<int>(attribute_id));
          break;
      }
    }
      break;
    case NOM_MOC_PT_DEMOG:
    {
      switch (attribute_id)
      {
        case NOM_ATTR_ID_HANDLE:
        case NOM_ATTR_PT_DEMOG_ST:
        case NOM_ATTR_PT_TYPE:
        case NOM_ATTR_PT_PACED_MODE:
        case NOM_ATTR_PT_NAME_GIVEN:
        case NOM_ATTR_PT_NAME_FAMILY:
        case NOM_ATTR_PT_ID:
        case NOM_ATTR_PT_SEX:
        case NOM_ATTR_PT_DOB:
        case NOM_ATTR_PT_HEIGHT:
        case NOM_ATTR_PT_WEIGHT:
        case NOM_ATTR_PT_AGE:
        case NOM_ATTR_PT_BSA:
        case NOM_ATTR_PT_BSA_FORMULA:
        case NOM_ATTR_PT_NOTES1:
        case NOM_ATTR_PT_NOTES2:
          *is_valid = true;
          break;
        default:
          LOG4CPLUS_INFO(root_logger, sfn << "Patient demographics poll "
            "result should not contain attribute_id: "
            << static_cast<int>(attribute_id));
          break;
      }
    }
      break;
    case NOM_MOC_VMO_AL_MON:
    {
      switch (attribute_id)
      {
        case NOM_ATTR_ID_HANDLE:
        case NOM_ATTR_ID_TYPE:
        case NOM_ATTR_DEV_AL_COND:
        case NOM_ATTR_AL_MON_T_AL_LIST:
        case NOM_ATTR_AL_MON_P_AL_LIST:
          *is_valid = true;
          break;
        default:
          LOG4CPLUS_INFO(root_logger, sfn << "Alert poll result should not "
            "contain attribute_id: " << static_cast<int>(attribute_id));
          break;
      }
    }
    case NOM_MOC_VMO_METRIC_NU:
    {
      switch (attribute_id)
      {
        case NOM_ATTR_ID_HANDLE:
        case NOM_ATTR_ID_TYPE:
        case NOM_ATTR_NU_VAL_OBS:
        case NOM_ATTR_NU_CMPD_VAL_OBS:
        case NOM_ATTR_TIME_STAMP_ABS:
        case NOM_ATTR_TIME_STAMP_REL:
        case NOM_ATTR_ID_LABEL:
        case NOM_ATTR_ID_LABEL_STRING:
        case NOM_ATTR_DISP_RES:
        case NOM_ATTR_COLOR:
        case NOM_ATTR_METRIC_SPECN:
        case NOM_ATTR_METRIC_MODALITY:
          *is_valid = true;
          break;
        default:
          LOG4CPLUS_INFO(root_logger, sfn << "Numeric poll "
            "result should not contain attribute_id: "
            << static_cast<int>(attribute_id));
          break;
      }
    }
      break;
    case NOM_MOC_VMO_METRIC_SA_RT:
    {
      switch (attribute_id)
      {
        case NOM_ATTR_ID_HANDLE:
        case NOM_ATTR_ID_TYPE:
        case NOM_ATTR_METRIC_SPECN:
        case NOM_ATTR_SA_SPECN:
        case NOM_ATTR_SA_FIXED_VAL_SPECN:
        case NOM_ATTR_TIME_PD_SAMP:
        case NOM_ATTR_ID_LABEL:
        case NOM_ATTR_ID_LABEL_STRING:
        case NOM_ATTR_METRIC_STAT:
        case NOM_ATTR_UNIT_CODE:
        case NOM_ATTR_COLOR:
        case NOM_ATTR_MODE_MSMT:
        case NOM_ATTR_METRIC_INFO_LABEL:
        case NOM_ATTR_METRIC_INFO_LABEL_STR:
        case NOM_ATTR_SCALE_SPECN_I16:
        case NOM_ATTR_SA_RANGE_PHYS_I16:
        case NOM_ATTR_GRID_VIS_I16:
        case NOM_ATTR_SA_CALIB_I16:
        case NOM_ATTR_SA_VAL_OBS:
        case NOM_ATTR_SA_CMPD_VAL_OBS:
          *is_valid = true;
          break;
        default:
          LOG4CPLUS_INFO(root_logger, sfn << "Wave poll "
            "result should not contain attribute_id: "
            << static_cast<int>(attribute_id));
          break;
      }
    }
      break;
    case NOM_MOC_VMO_METRIC_ENUM:
    {
      switch (attribute_id)
      {
        case NOM_ATTR_ID_HANDLE:
        case NOM_ATTR_ID_TYPE:
        case NOM_ATTR_METRIC_SPECN:
        case NOM_ATTR_ID_LABEL:
        case NOM_ATTR_ID_LABEL_STRING:
        case NOM_ATTR_COLOR:
        case NOM_ATTR_VAL_ENUM_OBS:
          *is_valid = true;
          break;
        default:
          LOG4CPLUS_INFO(root_logger, sfn << "Enumeration poll "
            "result should not contain attribute_id: "
            << static_cast<int>(attribute_id));
          break;
      }
    }
      break;
    default:
      LOG4CPLUS_WARN(root_logger, sfn << "Found unknown object code: "
        << static_cast<int>(code));
      break;
  }
  return DicesRcPhilipsIntellivueMP70::OK;
}

DicesRcPhilipsIntellivueMP70 IntellivueUtils::ParseAttribute(
  intellivue::AVAType* ava,
  uint8_t* buffer,
  int iindex)
{
  static const char* sfn = "IntellivueUtils::ParseAttribute() ";
  if (!ava)
  {
    LOG4CPLUS_ERROR(root_logger, sfn << "Function argument ava is a null "
      "pointer.");
    return DicesRcPhilipsIntellivueMP70::NULL_POINTER_FUNCTION_ARGUMENT_FAILURE;
  }

  if (!buffer)
  {
    LOG4CPLUS_ERROR(root_logger, sfn << "Function argument buffer is a null "
      "pointer.");
    return DicesRcPhilipsIntellivueMP70::NULL_POINTER_FUNCTION_ARGUMENT_FAILURE;
  }

  switch (ava->attribute_id)
  {
    case NOM_ATTR_ID_TYPE:
    case NOM_ATTR_SYS_TYPE:
    {
      intellivue::TYPE type = { 0 };
      DicesRcPhilipsIntellivueMP70 status = DicesRcPhilipsIntellivueMP70::OK;

      ava->attribute_val = new (std::nothrow) uint8_t[sizeof(intellivue::TYPE)]();
      if (!ava->attribute_val)
      {
        LOG4CPLUS_ERROR(root_logger, sfn << "Failed to allocate memory for "
          "attribute_val using TYPE");
        return DicesRcPhilipsIntellivueMP70::MEMORY_ALLOCATION_FAILURE;
      }
      intellivue::TYPE* ptype = reinterpret_cast<intellivue::TYPE *>(ava->attribute_val);

      type.partition = ntohs(*(reinterpret_cast<uint16_t*>(&buffer[iindex])));
      iindex += 2;
      type.code = ntohs(*(reinterpret_cast<uint16_t*>(&buffer[iindex])));
      iindex += 2;

      *ptype = type;
    }
      break;
    case NOM_ATTR_LOCALIZN:
    {
      intellivue::SystemLocal tsl = { 0 };
      DicesRcPhilipsIntellivueMP70 status = DicesRcPhilipsIntellivueMP70::OK;

      ava->attribute_val = new (std::nothrow) uint8_t[sizeof(intellivue::SystemLocal)]();
      if (!ava->attribute_val)
      {
        LOG4CPLUS_ERROR(root_logger, sfn << "Failed to allocate memory for "
          "attribute_val using SystemLocal");
        return DicesRcPhilipsIntellivueMP70::MEMORY_ALLOCATION_FAILURE;
      }
      intellivue::SystemLocal* ptsl = reinterpret_cast<intellivue::SystemLocal *>(ava->attribute_val);

      tsl.text_catalog_revision = ntohl(
        *(reinterpret_cast<uint32_t*>(&buffer[iindex])));
      iindex += 4;
      tsl.language = ntohs(*(reinterpret_cast<uint16_t*>(&buffer[iindex])));
      iindex += 2;
      tsl.format = ntohs(*(reinterpret_cast<uint16_t*>(&buffer[iindex])));
      iindex += 2;

      *ptsl = tsl;
    }
      break;
    case NOM_ATTR_NET_ADDR_INFO:
    {
      intellivue::IpAddressInfo ip = { 0 };

      ava->attribute_val = new (std::nothrow) uint8_t[sizeof(intellivue::IpAddressInfo)]();
      if (!ava->attribute_val)
      {
        LOG4CPLUS_ERROR(root_logger, sfn << "Failed to allocate memory for "
          "attribute_val using IpAddressInfo");
        return DicesRcPhilipsIntellivueMP70::MEMORY_ALLOCATION_FAILURE;
      }
      intellivue::IpAddressInfo* pip = reinterpret_cast<intellivue::IpAddressInfo *>(ava->attribute_val);

      memcpy(ip.mac_address.value, &buffer[iindex], 6);
      iindex += 6;
      memcpy(ip.ip_address.value, &buffer[iindex], 4);
      iindex += 4;
      memcpy(ip.subnet_mask.value, &buffer[iindex], 4);
      iindex += 4;

      *pip = ip;
    }
      break;
    case NOM_ATTR_PCOL_SUPPORT:
    {
      intellivue::ProtoSupport ps = { 0 };
      DicesRcPhilipsIntellivueMP70 status = DicesRcPhilipsIntellivueMP70::OK;

      ava->attribute_val = new (std::nothrow) uint8_t[sizeof(intellivue::ProtoSupport)]();
      if (!ava->attribute_val)
      {
        LOG4CPLUS_ERROR(root_logger, sfn << "Failed to allocate memory for "
          "attribute_val using ProtoSupport");
        return DicesRcPhilipsIntellivueMP70::MEMORY_ALLOCATION_FAILURE;
      }
      intellivue::ProtoSupport* pps = reinterpret_cast<intellivue::ProtoSupport *>(ava->attribute_val);

      ps.count = ntohs(*(reinterpret_cast<uint16_t*>(&buffer[iindex])));
      iindex += 2;
      ps.length = ntohs(*(reinterpret_cast<uint16_t*>(&buffer[iindex])));
      iindex += 2;

      LOG4CPLUS_INFO(root_logger, "ProtoSupport");
      LOG4CPLUS_INFO(root_logger, "\tcount: " << ps.count);
      LOG4CPLUS_INFO(root_logger, "\tlength: " << ps.length);

      ps.value = new (std::nothrow) intellivue::ProtoSupportEntry[ps.count]();
      if (!ps.value)
      {
        LOG4CPLUS_ERROR(root_logger, sfn << "Failed to allocate memory for "
          "ProtoSupportEntry value");
        return DicesRcPhilipsIntellivueMP70::MEMORY_ALLOCATION_FAILURE;
      }
      *pps = ps;

      for (int ix = 0; ix < ps.count; ix++)
      {
        intellivue::ProtoSupportEntry value = { 0 };
        value.appl_proto = ntohs(
          *(reinterpret_cast<uint16_t*>(&buffer[iindex])));
        iindex += 2;
        value.trans_proto = ntohs(
          *(reinterpret_cast<uint16_t*>(&buffer[iindex])));
        iindex += 2;
        value.port_number = ntohs(
          *(reinterpret_cast<uint16_t*>(&buffer[iindex])));
        iindex += 2;
        value.options = ntohs(
          *(reinterpret_cast<uint16_t*>(&buffer[iindex])));
        iindex += 2;
        ps.value[ix] = value;
      }
    }
      break;
    case NOM_ATTR_ID_PROD_SPECN:
    {
      intellivue::ProductionSpec pspec = { 0 };
      DicesRcPhilipsIntellivueMP70 status = DicesRcPhilipsIntellivueMP70::OK;

      ava->attribute_val = new (std::nothrow) uint8_t[sizeof(intellivue::ProductionSpec)]();
      if (!ava->attribute_val)
      {
        LOG4CPLUS_ERROR(root_logger, sfn << "Failed to allocate memory for "
          "attribute_val using ProductionSpec");
        return DicesRcPhilipsIntellivueMP70::MEMORY_ALLOCATION_FAILURE;
      }
      intellivue::ProductionSpec* ppspec = reinterpret_cast<intellivue::ProductionSpec *>(ava->attribute_val);

      pspec.count = ntohs(*(reinterpret_cast<uint16_t*>(&buffer[iindex])));
      iindex += 2;
      pspec.length = ntohs(*(reinterpret_cast<uint16_t*>(&buffer[iindex])));
      iindex += 2;
      pspec.value = new (std::nothrow) intellivue::ProdSpecEntry[pspec.count]();
      if (!pspec.value)
      {
        LOG4CPLUS_ERROR(root_logger, sfn << "Failed to allocate memory for "
          "ProdSpecEntry list");
        return DicesRcPhilipsIntellivueMP70::MEMORY_ALLOCATION_FAILURE;
      }
      *ppspec = pspec;

      for (int ix = 0; ix < pspec.count; ix++)
      {
        intellivue::ProdSpecEntry pspecentry = { 0 };
        pspecentry.spec_type = ntohs(
          *(reinterpret_cast<uint16_t*>(&buffer[iindex])));
        iindex += 2;
        pspecentry.component_id = ntohs(
          *(reinterpret_cast<uint16_t*>(&buffer[iindex])));
        iindex += 2;
        pspecentry.prod_spec.length = ntohs(
          *(reinterpret_cast<uint16_t*>(&buffer[iindex])));
        iindex += 2;
        pspecentry.prod_spec.value = new (std::nothrow) uint8_t[pspecentry.prod_spec.length]();
        if (!pspecentry.prod_spec.value)
        {
          LOG4CPLUS_ERROR(root_logger, sfn << "Failed to allocate memory for "
            "ProdSpecEntry value");
          return DicesRcPhilipsIntellivueMP70::MEMORY_ALLOCATION_FAILURE;
        }
        memcpy(pspecentry.prod_spec.value, &buffer[iindex], pspecentry.prod_spec.length);
        iindex += pspecentry.prod_spec.length;
        pspec.value[ix] = pspecentry;
      }
    }
      break;
    case NOM_ATTR_ID_MODEL:
    {
      intellivue::SystemModel system_model = { 0 };
      DicesRcPhilipsIntellivueMP70 status = DicesRcPhilipsIntellivueMP70::OK;

      ava->attribute_val = new (std::nothrow)
        uint8_t[sizeof(intellivue::SystemModel)]();
      if (!ava->attribute_val)
      {
        LOG4CPLUS_ERROR(root_logger, sfn << "Failed to allocate memory for "
          "attribute_val using SystemModel");
        return DicesRcPhilipsIntellivueMP70::MEMORY_ALLOCATION_FAILURE;
      }
      intellivue::SystemModel* psystem_model =
        reinterpret_cast<intellivue::SystemModel *>(ava->attribute_val);

      system_model.manufacturer.length =
        ntohs(*(reinterpret_cast<uint16_t*>(&buffer[iindex])));
      iindex += 2;

      system_model.manufacturer.value = new (std::nothrow)
        uint8_t[system_model.manufacturer.length]();
      if (!system_model.manufacturer.value)
      {
        LOG4CPLUS_ERROR(root_logger, sfn << "Failed to allocate memory for "
          "SystemModel manufacturer value");
        return DicesRcPhilipsIntellivueMP70::MEMORY_ALLOCATION_FAILURE;
      }
      memcpy(
        system_model.manufacturer.value,
        &buffer[iindex],
        system_model.manufacturer.length);
      iindex += system_model.manufacturer.length;
      *psystem_model = system_model;

      system_model.model_number.length =
        ntohs(*(reinterpret_cast<uint16_t*>(&buffer[iindex])));
      iindex += 2;

      system_model.model_number.value = new (std::nothrow)
        uint8_t[system_model.model_number.length]();
      if (!system_model.model_number.value)
      {
        LOG4CPLUS_ERROR(root_logger, sfn << "Failed to allocate memory for "
          "SystemModel model_number value");
        return DicesRcPhilipsIntellivueMP70::MEMORY_ALLOCATION_FAILURE;
      }
      memcpy(
        system_model.model_number.value,
        &buffer[iindex],
        system_model.model_number.length);
      iindex += system_model.model_number.length;

      *psystem_model = system_model;
    }
      break;
    case NOM_POLL_PROFILE_SUPPORT:
    {
      intellivue::PollProfileSupport poll_profile_support = { 0 };
      DicesRcPhilipsIntellivueMP70 status = DicesRcPhilipsIntellivueMP70::OK;

      ava->attribute_val = new (std::nothrow) uint8_t[sizeof(intellivue::PollProfileSupport)]();
      if (!ava->attribute_val)
      {
        LOG4CPLUS_ERROR(root_logger, sfn << "Failed to allocate memory for "
          "attribute_val using PollProfileSupport");
        return DicesRcPhilipsIntellivueMP70::MEMORY_ALLOCATION_FAILURE;
      }
      intellivue::PollProfileSupport* ppoll_profile_support =
        reinterpret_cast<intellivue::PollProfileSupport *>(ava->attribute_val);

      poll_profile_support.poll_profile_revision =
        ntohl(*(reinterpret_cast<uint32_t*>(&buffer[iindex])));
      iindex += 4;
      poll_profile_support.min_poll_period =
        ntohl(*(reinterpret_cast<uint32_t*>(&buffer[iindex])));
      iindex += 4;
      poll_profile_support.max_mtu_rx =
        ntohl(*(reinterpret_cast<uint32_t*>(&buffer[iindex])));
      iindex += 4;
      poll_profile_support.max_mtu_tx =
        ntohl(*(reinterpret_cast<uint32_t*>(&buffer[iindex])));
      iindex += 4;
      poll_profile_support.max_bw_tx =
        ntohl(*(reinterpret_cast<uint32_t*>(&buffer[iindex])));
      iindex += 4;
      poll_profile_support.options =
        ntohl(*(reinterpret_cast<uint32_t*>(&buffer[iindex])));
      iindex += 4;
      poll_profile_support.optional_packages.count =
        ntohs(*(reinterpret_cast<uint16_t*>(&buffer[iindex])));
      iindex += 2;
      poll_profile_support.optional_packages.length =
        ntohs(*(reinterpret_cast<uint16_t*>(&buffer[iindex])));
      iindex += 2;

      poll_profile_support.optional_packages.value = new (std::nothrow)
        intellivue::AVAType[poll_profile_support.optional_packages.count]();
      if (!poll_profile_support.optional_packages.value)
      {
        LOG4CPLUS_ERROR(root_logger, sfn << "Failed to allocate memory for "
          "PollProfileSupport optional_packages value");
        return DicesRcPhilipsIntellivueMP70::MEMORY_ALLOCATION_FAILURE;
      }
      *ppoll_profile_support = poll_profile_support;

      for (int ix = 0; ix < poll_profile_support.optional_packages.count; ix++)
      {
        poll_profile_support.optional_packages.value[ix].attribute_id = ntohs(
          *(reinterpret_cast<uint16_t*>(&buffer[iindex])));
        iindex += 2;
        poll_profile_support.optional_packages.value[ix].length = ntohs(
          *(reinterpret_cast<uint16_t*>(&buffer[iindex])));
        iindex += 2;
        status = IntellivueUtils::ParseAttribute(
          &poll_profile_support.optional_packages.value[ix],
          buffer,
          iindex);
        if (status != DicesRcPhilipsIntellivueMP70::OK)
        {
          LOG4CPLUS_ERROR(root_logger, sfn <<
            DicesRcPhilipsIntellivueMP70StatusMessage::
            DicesRcPhilipsIntellivueMP70ToString(status));
          return status;
        }
        iindex += poll_profile_support.optional_packages.value[ix].length;
      }
    }
      break;
    case NOM_ATTR_POLL_PROFILE_EXT:
    {
      intellivue::PollProfileExt poll_profile_ext = { 0 };
      DicesRcPhilipsIntellivueMP70 status = DicesRcPhilipsIntellivueMP70::OK;

      ava->attribute_val = new (std::nothrow) uint8_t[sizeof(intellivue::PollProfileExt)]();
      if (!ava->attribute_val)
      {
        LOG4CPLUS_ERROR(root_logger, sfn << "Failed to allocate memory for "
          "attribute_val using PollProfileExt");
        return DicesRcPhilipsIntellivueMP70::MEMORY_ALLOCATION_FAILURE;
      }
      intellivue::PollProfileExt* ppoll_profile_ext =
        reinterpret_cast<intellivue::PollProfileExt *>(ava->attribute_val);

      poll_profile_ext.options = ntohl(*(reinterpret_cast<uint32_t*>(&buffer[iindex])));
      iindex += 4;
      poll_profile_ext.ext_attr.count = ntohs(
        *(reinterpret_cast<uint16_t*>(&buffer[iindex])));
      iindex += 2;
      poll_profile_ext.ext_attr.length = ntohs(
        *(reinterpret_cast<uint16_t*>(&buffer[iindex])));
      iindex += 2;

      poll_profile_ext.ext_attr.value =
        new (std::nothrow) intellivue::AVAType[poll_profile_ext.ext_attr.count]();
      if (!poll_profile_ext.ext_attr.value)
      {
        LOG4CPLUS_ERROR(root_logger, sfn << "Failed to allocate memory for "
          "AVAType list");
        return DicesRcPhilipsIntellivueMP70::MEMORY_ALLOCATION_FAILURE;
      }
      *ppoll_profile_ext = poll_profile_ext;

      for (int ix = 0; ix < poll_profile_ext.ext_attr.count; ix++)
      {
        poll_profile_ext.ext_attr.value[ix].attribute_id = ntohs(
          *(reinterpret_cast<uint16_t*>(&buffer[iindex])));
        iindex += 2;
        poll_profile_ext.ext_attr.value[ix].length = ntohs(
          *(reinterpret_cast<uint16_t*>(&buffer[iindex])));
        iindex += 2;
        status = IntellivueUtils::ParseAttribute(
          &poll_profile_ext.ext_attr.value[ix],
          buffer,
          iindex);
        if (status != DicesRcPhilipsIntellivueMP70::OK)
        {
          LOG4CPLUS_ERROR(root_logger, sfn <<
            DicesRcPhilipsIntellivueMP70StatusMessage::
            DicesRcPhilipsIntellivueMP70ToString(status));
          return status;
        }
        iindex += poll_profile_ext.ext_attr.value[ix].length;
      }
    }
      break;
    case NOM_ATTR_ID_HANDLE:
    {
      intellivue::Handle handle = { 0 };
      DicesRcPhilipsIntellivueMP70 status = DicesRcPhilipsIntellivueMP70::OK;

      ava->attribute_val = new (std::nothrow) uint8_t[sizeof(intellivue::Handle)]();
      if (!ava->attribute_val)
      {
        LOG4CPLUS_ERROR(root_logger, sfn << "Failed to allocate memory for "
          "attribute_val using Handle");
        return DicesRcPhilipsIntellivueMP70::MEMORY_ALLOCATION_FAILURE;
      }
      intellivue::Handle* phandle = reinterpret_cast<intellivue::Handle *>(ava->attribute_val);

      handle = ntohs(*(reinterpret_cast<uint16_t*>(&buffer[iindex])));
      iindex += 2;

      *phandle = handle;
    }
      break;
    case NOM_ATTR_SYS_ID:
    {
      intellivue::VariableLabel var_label = { 0 };
      DicesRcPhilipsIntellivueMP70 status = DicesRcPhilipsIntellivueMP70::OK;

      ava->attribute_val = new (std::nothrow) uint8_t[
        sizeof(intellivue::VariableLabel)]();
      if (!ava->attribute_val)
      {
        LOG4CPLUS_ERROR(root_logger, sfn << "Failed to allocate memory for "
          "attribute_val using VariableLabel");
        return DicesRcPhilipsIntellivueMP70::MEMORY_ALLOCATION_FAILURE;
      }
      intellivue::VariableLabel* pvar_label
        = reinterpret_cast<intellivue::VariableLabel *>(ava->attribute_val);

      var_label.length = ntohs(
        *(reinterpret_cast<uint16_t*>(&buffer[iindex])));
      iindex += 2;

      var_label.value = new (std::nothrow) uint8_t[var_label.length]();
      if (!var_label.value)
      {
        LOG4CPLUS_ERROR(root_logger, sfn << "Failed to allocate memory for "
          "VariableLabel value");
        return DicesRcPhilipsIntellivueMP70::MEMORY_ALLOCATION_FAILURE;
      }
      memcpy(var_label.value, &buffer[iindex], var_label.length);
      iindex += var_label.length;

      *pvar_label = var_label;

    }
      break;
    case NOM_ATTR_NOM_VERS:
    {
      uint32_t u32 = { 0 };
      DicesRcPhilipsIntellivueMP70 status = DicesRcPhilipsIntellivueMP70::OK;

      ava->attribute_val = new (std::nothrow) uint8_t[
        sizeof(uint32_t)]();
      if (!ava->attribute_val)
      {
        LOG4CPLUS_ERROR(root_logger, sfn << "Failed to allocate memory for "
          "attribute_val using uint32_t");
        return DicesRcPhilipsIntellivueMP70::MEMORY_ALLOCATION_FAILURE;
      }
      uint32_t* pu32 = reinterpret_cast<uint32_t *>(ava->attribute_val);

      u32 = ntohl(*(reinterpret_cast<uint32_t*>(&buffer[iindex])));
      iindex += 4;
      *pu32 = u32;
    }
      break;
    case NOM_ATTR_SYS_SPECN:
    {
      intellivue::SystemSpec sysspec = { 0 };
      DicesRcPhilipsIntellivueMP70 status = DicesRcPhilipsIntellivueMP70::OK;

      ava->attribute_val = new (std::nothrow) uint8_t[
        sizeof(intellivue::SystemSpec)]();
      if (!ava->attribute_val)
      {
        LOG4CPLUS_ERROR(root_logger, sfn << "Failed to allocate memory for "
          "attribute_val using SystemSpec");
        return DicesRcPhilipsIntellivueMP70::MEMORY_ALLOCATION_FAILURE;
      }
      intellivue::SystemSpec* psysspec =
        reinterpret_cast<intellivue::SystemSpec *>(ava->attribute_val);

      sysspec.count = ntohs(*(reinterpret_cast<uint16_t*>(&buffer[iindex])));
      iindex += 2;

      sysspec.length = ntohs(*(reinterpret_cast<uint16_t*>(&buffer[iindex])));
      iindex += 2;

      sysspec.value =
        new (std::nothrow) intellivue::SystemSpecEntry[sysspec.count]();
      if (!sysspec.value)
      {
        LOG4CPLUS_ERROR(root_logger, sfn << "Failed to allocate memory for "
          "SystemSpec value");
        return DicesRcPhilipsIntellivueMP70::MEMORY_ALLOCATION_FAILURE;
      }
      *psysspec = sysspec;

      for (int ix = 0; ix < sysspec.count; ix++)
      {
        sysspec.value[ix].component_capab_id = ntohs(
          *(reinterpret_cast<uint16_t*>(&buffer[iindex])));
        iindex += 2;

        sysspec.value[ix].length = ntohs(
          *(reinterpret_cast<uint16_t*>(&buffer[iindex])));
        iindex += 2;

        intellivue::MdibObjectSupport mdib = { 0 };
        sysspec.value[ix].value =
          new (std::nothrow) uint16_t[sysspec.value[ix].length]();
        if (!sysspec.value)
        {
          LOG4CPLUS_ERROR(root_logger, sfn << "Failed to allocate memory for "
            "SystemSpecEntry value");
          return DicesRcPhilipsIntellivueMP70::MEMORY_ALLOCATION_FAILURE;
        }
        intellivue::MdibObjectSupport* pmdib =
          reinterpret_cast<intellivue::MdibObjectSupport *>(sysspec.value[ix].value);

        *psysspec = sysspec;

        mdib.count = ntohs(*(reinterpret_cast<uint16_t*>(&buffer[iindex])));
        iindex += 2;

        mdib.length = ntohs(*(reinterpret_cast<uint16_t*>(&buffer[iindex])));
        iindex += 2;

        intellivue::MdibObjectSupportEntry mdibentry = { 0 };
        pmdib->value =
          new (std::nothrow) intellivue::MdibObjectSupportEntry[mdib.count]();
        if (!pmdib->value)
        {
          LOG4CPLUS_ERROR(root_logger, sfn << "Failed to allocate memory for "
            "MdibObjectSupportEntry");
          return DicesRcPhilipsIntellivueMP70::MEMORY_ALLOCATION_FAILURE;
        }
        intellivue::MdibObjectSupportEntry* pmdibentry =
          reinterpret_cast<intellivue::MdibObjectSupportEntry *>(pmdib->value);

        *psysspec = sysspec;

        for (int iy = 0; iy < mdib.count; iy++)
        {
          pmdib->value[iy].object_type.partition = ntohs(
            *(reinterpret_cast<uint16_t*>(&buffer[iindex])));
          iindex += 2;

          pmdib->value[iy].object_type.code = ntohs(
            *(reinterpret_cast<uint16_t*>(&buffer[iindex])));
          iindex += 2;

          pmdib->value[iy].max_inst = ntohl(
            *(reinterpret_cast<uint32_t*>(&buffer[iindex])));
          iindex += 4;
        }
      }
    }
      break;
    case NOM_ATTR_MDS_GEN_INFO:
    {
      intellivue::MdsGenSystemInfo mgsi = { 0 };
      DicesRcPhilipsIntellivueMP70 status = DicesRcPhilipsIntellivueMP70::OK;

      ava->attribute_val = new (std::nothrow) uint8_t[
        sizeof(intellivue::MdsGenSystemInfo)]();
      if (!ava->attribute_val)
      {
        LOG4CPLUS_ERROR(root_logger, sfn << "Failed to allocate memory for "
          "attribute_val using MdsGenSystemInfo");
        return DicesRcPhilipsIntellivueMP70::MEMORY_ALLOCATION_FAILURE;
      }
      intellivue::MdsGenSystemInfo* pmgsi =
        reinterpret_cast<intellivue::MdsGenSystemInfo *>(ava->attribute_val);

      mgsi.count = ntohs(*(reinterpret_cast<uint16_t*>(&buffer[iindex])));
      iindex += 2;

      mgsi.length = ntohs(*(reinterpret_cast<uint16_t*>(&buffer[iindex])));
      iindex += 2;

      mgsi.value = new (std::nothrow) intellivue::MdsGenSystemInfoEntry[mgsi.count]();
      if (!mgsi.value)
      {
        LOG4CPLUS_ERROR(root_logger, sfn << "Failed to allocate memory for "
          "attribute_val using MdsGenSystemInfoEntry");
        return DicesRcPhilipsIntellivueMP70::MEMORY_ALLOCATION_FAILURE;
      }
      *pmgsi = mgsi;

      for (int ix = 0; ix < mgsi.count; ix++)
      {
        mgsi.value[ix].choice = ntohs(
          *(reinterpret_cast<uint16_t*>(&buffer[iindex])));
        iindex += 2;

        mgsi.value[ix].length = ntohs(
          *(reinterpret_cast<uint16_t*>(&buffer[iindex])));
        iindex += 2;

        mgsi.value[ix].value = new (std::nothrow) uint8_t[mgsi.value[ix].length]();
        if (!mgsi.value[ix].value)
        {
          LOG4CPLUS_ERROR(root_logger, sfn << "Failed to allocate memory for "
            "MdsGenSystemInfoEntry value");
          return DicesRcPhilipsIntellivueMP70::MEMORY_ALLOCATION_FAILURE;
        }
        intellivue::SystemPulseInfo* spinfo =
          reinterpret_cast<intellivue::SystemPulseInfo*>(mgsi.value[ix].value);

        if (mgsi.value[ix].choice == MDS_GEN_SYSTEM_INFO_SYSTEM_PULSE_CHOSEN)
        {
          spinfo->system_pulse.m_obj_class = ntohs(
            *(reinterpret_cast<uint16_t*>(&buffer[iindex])));
          iindex += 2;

          spinfo->system_pulse.m_obj_inst.context_id = ntohs(
            *(reinterpret_cast<uint16_t*>(&buffer[iindex])));
          iindex += 2;

          spinfo->system_pulse.m_obj_inst.handle = ntohs(
            *(reinterpret_cast<uint16_t*>(&buffer[iindex])));
          iindex += 2;

          spinfo->alarm_source.m_obj_class = ntohs(
            *(reinterpret_cast<uint16_t*>(&buffer[iindex])));
          iindex += 2;

          spinfo->alarm_source.m_obj_inst.context_id = ntohs(
            *(reinterpret_cast<uint16_t*>(&buffer[iindex])));
          iindex += 2;

          spinfo->alarm_source.m_obj_inst.handle = ntohs(
            *(reinterpret_cast<uint16_t*>(&buffer[iindex])));
          iindex += 2;
        }
      }
    }
      break;
    case NOM_ATTR_VMS_MDS_STAT:
    {
      intellivue::MDSStatus mds_status = { 0 };
      DicesRcPhilipsIntellivueMP70 status = DicesRcPhilipsIntellivueMP70::OK;

      ava->attribute_val = new (std::nothrow) uint8_t[
        sizeof(intellivue::MDSStatus)]();
      if (!ava->attribute_val)
      {
        LOG4CPLUS_ERROR(root_logger, sfn << "Failed to allocate memory for "
          "attribute_val using MDSStatus");
        return DicesRcPhilipsIntellivueMP70::MEMORY_ALLOCATION_FAILURE;
      }
      intellivue::MDSStatus* pmds_status =
        reinterpret_cast<intellivue::MDSStatus *>(ava->attribute_val);

      mds_status = ntohs(*(reinterpret_cast<uint16_t*>(&buffer[iindex])));
      iindex += 2;
      *pmds_status = mds_status;
    }
      break;
    case NOM_ATTR_METRIC_INFO_LABEL_STR:
    case NOM_ATTR_ID_LABEL_STRING:
    case NOM_ATTR_ID_BED_LABEL:
    case NOM_ATTR_PT_NAME_GIVEN:
    case NOM_ATTR_PT_NAME_FAMILY:
    case NOM_ATTR_PT_ID:
    case NOM_ATTR_PT_NOTES1:
    case NOM_ATTR_PT_NOTES2:
      // NOTE:
      // Attribute ID NOM_ATTR_PT_NAME_MIDDLE value is not in the manual.
      // Attribute ID NOM_ATTR_PT_ENCOUNTER_ID value is not in the manual.
    {
      intellivue::String label = { 0 };
      DicesRcPhilipsIntellivueMP70 status = DicesRcPhilipsIntellivueMP70::OK;

      ava->attribute_val = new (std::nothrow) uint8_t[
        sizeof(intellivue::String)]();
      if (!ava->attribute_val)
      {
        LOG4CPLUS_ERROR(root_logger, sfn << "Failed to allocate memory for "
          "attribute_val using String");
        return DicesRcPhilipsIntellivueMP70::MEMORY_ALLOCATION_FAILURE;
      }
      intellivue::String* plabel =
        reinterpret_cast<intellivue::String *>(ava->attribute_val);

      label.length = ntohs(*(reinterpret_cast<uint16_t*>(&buffer[iindex])));
      iindex += 2;

      label.value = new (std::nothrow) uint16_t[label.length]();
      if (!label.value)
      {
        LOG4CPLUS_ERROR(root_logger, sfn << "Failed to allocate memory for "
          "String value");
        return DicesRcPhilipsIntellivueMP70::MEMORY_ALLOCATION_FAILURE;
      }

      memcpy(label.value, &buffer[iindex], label.length);
      iindex += label.length;

      *plabel = label;
    }
      break;
    case NOM_ATTR_MODE_OP:
    {
      intellivue::PrivateOID op_mode = 0;
      DicesRcPhilipsIntellivueMP70 status = DicesRcPhilipsIntellivueMP70::OK;

      ava->attribute_val = new (std::nothrow) uint8_t[
        sizeof(intellivue::PrivateOID)]();
      if (!ava->attribute_val)
      {
        LOG4CPLUS_ERROR(root_logger, sfn << "Failed to allocate memory for "
          "attribute_val using PrivateOID");
        return DicesRcPhilipsIntellivueMP70::MEMORY_ALLOCATION_FAILURE;
      }
      intellivue::PrivateOID* pop_mode =
        reinterpret_cast<intellivue::PrivateOID *>(ava->attribute_val);

      op_mode = ntohs(*(reinterpret_cast<uint16_t*>(&buffer[iindex])));
      iindex += 2;

      *pop_mode = op_mode;
    }
      break;
    case NOM_ATTR_AREA_APPL:
    {
      intellivue::ApplicationArea aa = 0;
      DicesRcPhilipsIntellivueMP70 status = DicesRcPhilipsIntellivueMP70::OK;

      ava->attribute_val = new (std::nothrow) uint8_t[
        sizeof(intellivue::ApplicationArea)]();
      if (!ava->attribute_val)
      {
        LOG4CPLUS_ERROR(root_logger, sfn << "Failed to allocate memory for "
          "attribute_val using ApplicationArea");
        return DicesRcPhilipsIntellivueMP70::MEMORY_ALLOCATION_FAILURE;
      }
      intellivue::ApplicationArea* paa =
        reinterpret_cast<intellivue::ApplicationArea *>(ava->attribute_val);

      aa = ntohs(*(reinterpret_cast<uint16_t*>(&buffer[iindex])));
      iindex += 2;

      *paa = aa;
    }
      break;
    case NOM_ATTR_TIME_STAMP_ABS:
    case NOM_ATTR_TIME_ABS:
    case NOM_ATTR_PT_DOB:
    {
      intellivue::AbsoluteTime abs = { 0 };
      DicesRcPhilipsIntellivueMP70 status = DicesRcPhilipsIntellivueMP70::OK;

      ava->attribute_val = new (std::nothrow) uint8_t[
        sizeof(intellivue::AbsoluteTime)]();
      if (!ava->attribute_val)
      {
        LOG4CPLUS_ERROR(root_logger, sfn << "Failed to allocate memory for "
          "attribute_val using AbsoluteTime");
        return DicesRcPhilipsIntellivueMP70::MEMORY_ALLOCATION_FAILURE;
      }
      intellivue::AbsoluteTime* pabs =
        reinterpret_cast<intellivue::AbsoluteTime *>(ava->attribute_val);

      abs.century = buffer[iindex];
      abs.year = buffer[iindex + 1];
      abs.month = buffer[iindex + 2];
      abs.day = buffer[iindex + 3];
      abs.hour = buffer[iindex + 4];
      abs.minute = buffer[iindex + 5];
      abs.second = buffer[iindex + 6];
      abs.sec_fractions = buffer[iindex + 7];
      iindex += 8;
      *pabs = abs;
    }
      break;
    case NOM_ATTR_TIME_PD_SAMP:
    case NOM_ATTR_TIME_STAMP_REL:
    case NOM_ATTR_TIME_REL:
    {
      intellivue::RelativeTime rel_time = 0;
      DicesRcPhilipsIntellivueMP70 status = DicesRcPhilipsIntellivueMP70::OK;

      ava->attribute_val = new (std::nothrow) uint8_t[
        sizeof(intellivue::RelativeTime)]();
      if (!ava->attribute_val)
      {
        LOG4CPLUS_ERROR(root_logger, sfn << "Failed to allocate memory for "
          "attribute_val using RelativeTime");
        return DicesRcPhilipsIntellivueMP70::MEMORY_ALLOCATION_FAILURE;
      }
      intellivue::RelativeTime* prel_time =
        reinterpret_cast<intellivue::RelativeTime *>(ava->attribute_val);

      rel_time = ntohl(*(reinterpret_cast<uint32_t*>(&buffer[iindex])));
      iindex += 4;

      *prel_time = rel_time;
    }
      break;
    case NOM_ATTR_ALTITUDE:
    {
      int16_t altitude = 0;
      DicesRcPhilipsIntellivueMP70 status = DicesRcPhilipsIntellivueMP70::OK;

      ava->attribute_val = new (std::nothrow) uint8_t[
        sizeof(int16_t)]();
      if (!ava->attribute_val)
      {
        LOG4CPLUS_ERROR(root_logger, sfn << "Failed to allocate memory for "
          "attribute_val using uint16_t");
        return DicesRcPhilipsIntellivueMP70::MEMORY_ALLOCATION_FAILURE;
      }
      int16_t* paltitude =
        reinterpret_cast<int16_t *>(ava->attribute_val);

      altitude = ntohs(*(reinterpret_cast<int16_t*>(&buffer[iindex])));
      iindex += 2;

      *paltitude = altitude;
    }
      break;
    case NOM_ATTR_LINE_FREQ:
    {
      intellivue::LineFrequency lf = 0;
      DicesRcPhilipsIntellivueMP70 status = DicesRcPhilipsIntellivueMP70::OK;

      ava->attribute_val = new (std::nothrow) uint8_t[
        sizeof(intellivue::LineFrequency)]();
      if (!ava->attribute_val)
      {
        LOG4CPLUS_ERROR(root_logger, sfn << "Failed to allocate memory for "
          "attribute_val using LineFrequency");
        return DicesRcPhilipsIntellivueMP70::MEMORY_ALLOCATION_FAILURE;
      }
      intellivue::LineFrequency* plf =
        reinterpret_cast<intellivue::LineFrequency *>(ava->attribute_val);

      lf = ntohs(*(reinterpret_cast<uint16_t*>(&buffer[iindex])));
      iindex += 2;

      *plf = lf;
    }
      break;
    case NOM_ATTR_ID_ASSOC_NO:
    {
      uint16_t invoke_id = 0;
      DicesRcPhilipsIntellivueMP70 status = DicesRcPhilipsIntellivueMP70::OK;

      ava->attribute_val = new (std::nothrow) uint8_t[
        sizeof(uint16_t)]();
      if (!ava->attribute_val)
      {
        LOG4CPLUS_ERROR(root_logger, sfn << "Failed to allocate memory for "
          "attribute_val using uint16_t");
        return DicesRcPhilipsIntellivueMP70::MEMORY_ALLOCATION_FAILURE;
      }
      uint16_t* pinvoke_id =
        reinterpret_cast<uint16_t *>(ava->attribute_val);

      invoke_id = ntohs(*(reinterpret_cast<uint16_t*>(&buffer[iindex])));
      iindex += 2;
      *pinvoke_id = invoke_id;
    }
      break;
    case NOM_ATTR_NU_VAL_OBS:
    {
      DicesRcPhilipsIntellivueMP70 status = DicesRcPhilipsIntellivueMP70::OK;
      intellivue::NuObsValue nu_obs = { 0 };

      ava->attribute_val = new (std::nothrow) uint8_t[
        sizeof(intellivue::NuObsValue)]();
      if (!ava->attribute_val)
      {
        LOG4CPLUS_ERROR(root_logger, sfn << "Failed to allocate memory for "
          "attribute_val using NuObsValue");
        return DicesRcPhilipsIntellivueMP70::MEMORY_ALLOCATION_FAILURE;
      }
      intellivue::NuObsValue* pnu_obs =
        reinterpret_cast<intellivue::NuObsValue *>(ava->attribute_val);

      nu_obs.physio_id = ntohs(
        *(reinterpret_cast<uint16_t*>(&buffer[iindex])));
      iindex += 2;

      nu_obs.state = ntohs(*(reinterpret_cast<uint16_t*>(&buffer[iindex])));
      iindex += 2;

      nu_obs.unit_code = ntohs(
        *(reinterpret_cast<uint16_t*>(&buffer[iindex])));
      iindex += 2;

      nu_obs.value = ntohl(*(reinterpret_cast<uint32_t*>(&buffer[iindex])));
      iindex += 4;
      *pnu_obs = nu_obs;
    }
      break;
    case NOM_ATTR_NU_CMPD_VAL_OBS:
    {
      DicesRcPhilipsIntellivueMP70 status = DicesRcPhilipsIntellivueMP70::OK;
      intellivue::NuObsValueCmp nucmp = { 0 };

      ava->attribute_val = new (std::nothrow) uint8_t[
        sizeof(intellivue::NuObsValueCmp)]();
      if (!ava->attribute_val)
      {
        LOG4CPLUS_ERROR(root_logger, sfn << "Failed to allocate memory for "
          "attribute_val using NuObsValueCmp");
        return DicesRcPhilipsIntellivueMP70::MEMORY_ALLOCATION_FAILURE;
      }
      intellivue::NuObsValueCmp* pnucmp =
        reinterpret_cast<intellivue::NuObsValueCmp *>(ava->attribute_val);

      nucmp.count = ntohs(*(reinterpret_cast<uint16_t*>(&buffer[iindex])));
      iindex += 2;

      nucmp.length = ntohs(*(reinterpret_cast<uint16_t*>(&buffer[iindex])));
      iindex += 2;

      nucmp.value = new (std::nothrow) intellivue::NuObsValue[nucmp.count]();
      if (!nucmp.value)
      {
        LOG4CPLUS_ERROR(root_logger, sfn << "Failed to allocate memory for "
          "NuObsValue list");
        return DicesRcPhilipsIntellivueMP70::MEMORY_ALLOCATION_FAILURE;
      }
      *pnucmp = nucmp;

      for (int ix = 0; ix < nucmp.count; ix++)
      {
        intellivue::NuObsValue value = { 0 };
        value.physio_id = ntohs(
          *(reinterpret_cast<uint16_t*>(&buffer[iindex])));
        iindex += 2;
        value.state = ntohs(*(reinterpret_cast<uint16_t*>(&buffer[iindex])));
        iindex += 2;
        value.unit_code = ntohs(
          *(reinterpret_cast<uint16_t*>(&buffer[iindex])));
        iindex += 2;
        value.value = ntohl(*(reinterpret_cast<uint32_t*>(&buffer[iindex])));
        iindex += 4;

        pnucmp->value[ix] = value;
      }
    }
      break;
    case NOM_ATTR_ID_LABEL:
    {
      uint32_t u32 = { 0 };
      DicesRcPhilipsIntellivueMP70 status = DicesRcPhilipsIntellivueMP70::OK;

      ava->attribute_val = new (std::nothrow) uint8_t[
        sizeof(uint32_t)]();
      if (!ava->attribute_val)
      {
        LOG4CPLUS_ERROR(root_logger, sfn << "Failed to allocate memory for "
          "attribute_val using uint32_t");
        return DicesRcPhilipsIntellivueMP70::MEMORY_ALLOCATION_FAILURE;
      }
      uint32_t* pu32 = reinterpret_cast<uint32_t *>(ava->attribute_val);

      u32 = ntohl(*(reinterpret_cast<uint32_t*>(&buffer[iindex])));
      iindex += 4;
      *pu32 = u32;
    }
      break;
    case NOM_ATTR_DISP_RES:
    {
      DicesRcPhilipsIntellivueMP70 status = DicesRcPhilipsIntellivueMP70::OK;
      intellivue::DispResolution disp_res = { 0 };

      ava->attribute_val = new (std::nothrow) uint8_t[
        sizeof(intellivue::DispResolution)]();
      if (!ava->attribute_val)
      {
        LOG4CPLUS_ERROR(root_logger, sfn << "Failed to allocate memory for "
          "attribute_val using DispResolution");
        return DicesRcPhilipsIntellivueMP70::MEMORY_ALLOCATION_FAILURE;
      }
      intellivue::DispResolution* pdisp_res =
        reinterpret_cast<intellivue::DispResolution *>(ava->attribute_val);

      disp_res.pre_point = buffer[iindex];
      disp_res.post_point = buffer[iindex + 1];
      iindex += 2;

      *pdisp_res = disp_res;
    }
      break;
    case NOM_ATTR_COLOR:
    {
      DicesRcPhilipsIntellivueMP70 status = DicesRcPhilipsIntellivueMP70::OK;
      intellivue::SimpleColour color = { 0 };

      ava->attribute_val = new (std::nothrow) uint8_t[
        sizeof(intellivue::SimpleColour)]();
      if (!ava->attribute_val)
      {
        LOG4CPLUS_ERROR(root_logger, sfn << "Failed to allocate memory for "
          "attribute_val using SimpleColour");
        return DicesRcPhilipsIntellivueMP70::MEMORY_ALLOCATION_FAILURE;
      }
      intellivue::SimpleColour* pcolor =
        reinterpret_cast<intellivue::SimpleColour *>(ava->attribute_val);

      color = ntohs(*(reinterpret_cast<uint16_t*>(&buffer[iindex])));
      iindex += 2;

      *pcolor = color;
    }
      break;
    case NOM_ATTR_METRIC_SPECN:
    {
      DicesRcPhilipsIntellivueMP70 status = DicesRcPhilipsIntellivueMP70::OK;
      intellivue::MetricSpec mspec = { 0 };

      ava->attribute_val = new (std::nothrow) uint8_t[
        sizeof(intellivue::MetricSpec)]();
      if (!ava->attribute_val)
      {
        LOG4CPLUS_ERROR(root_logger, sfn << "Failed to allocate memory for "
          "attribute_val using MetricSpec");
        return DicesRcPhilipsIntellivueMP70::MEMORY_ALLOCATION_FAILURE;
      }
      intellivue::MetricSpec* pmspec =
        reinterpret_cast<intellivue::MetricSpec *>(ava->attribute_val);

      mspec.update_period = ntohl(
        *(reinterpret_cast<uint32_t*>(&buffer[iindex])));
      iindex += 4;
      mspec.category = ntohs(*(reinterpret_cast<uint16_t*>(&buffer[iindex])));
      iindex += 2;
      mspec.access = ntohs(*(reinterpret_cast<uint16_t*>(&buffer[iindex])));
      iindex += 2;
      mspec.structure.ms_struct = buffer[iindex];
      mspec.structure.ms_comp_no = buffer[iindex + 1];
      iindex += 2;
      mspec.relevance = ntohs(*(reinterpret_cast<uint16_t*>(&buffer[iindex])));
      iindex += 2;
      *pmspec = mspec;
    }
      break;
    case NOM_ATTR_SA_SPECN:
    {
      DicesRcPhilipsIntellivueMP70 status = DicesRcPhilipsIntellivueMP70::OK;
      intellivue::SaSpec sa_spec = { 0 };

      ava->attribute_val = new (std::nothrow) uint8_t[
        sizeof(intellivue::SaSpec)]();
      if (!ava->attribute_val)
      {
        LOG4CPLUS_ERROR(root_logger, sfn << "Failed to allocate memory for "
          "attribute_val using SaSpec");
        return DicesRcPhilipsIntellivueMP70::MEMORY_ALLOCATION_FAILURE;
      }
      intellivue::SaSpec* psa_spec =
        reinterpret_cast<intellivue::SaSpec *>(ava->attribute_val);

      sa_spec.array_size = ntohs(
        *(reinterpret_cast<uint16_t*>(&buffer[iindex])));
      iindex += 2;
      sa_spec.sample_type.sample_size = buffer[iindex];
      iindex++;
      sa_spec.sample_type.significant_bits = buffer[iindex];
      iindex++;
      sa_spec.flags = ntohs(
        *(reinterpret_cast<uint16_t*>(&buffer[iindex])));
      iindex += 2;
      *psa_spec = sa_spec;
    }
      break;
    case NOM_ATTR_SA_FIXED_VAL_SPECN:
    {
      DicesRcPhilipsIntellivueMP70 status = DicesRcPhilipsIntellivueMP70::OK;
      intellivue::SaFixedValSpec16 sa_fixed_val_spec = { 0 };

      ava->attribute_val = new (std::nothrow) uint8_t[
        sizeof(intellivue::SaFixedValSpec16)]();
      if (!ava->attribute_val)
      {
        LOG4CPLUS_ERROR(root_logger, sfn << "Failed to allocate memory for "
          "attribute_val using SaFixedValSpec16");
        return DicesRcPhilipsIntellivueMP70::MEMORY_ALLOCATION_FAILURE;
      }
      intellivue::SaFixedValSpec16* psa_fixed_val_spec =
        reinterpret_cast<intellivue::SaFixedValSpec16 *>(ava->attribute_val);

      sa_fixed_val_spec.count = ntohs(
        *(reinterpret_cast<uint16_t*>(&buffer[iindex])));
      iindex += 2;
      sa_fixed_val_spec.length = ntohs(
        *(reinterpret_cast<uint16_t*>(&buffer[iindex])));
      iindex += 2;
      sa_fixed_val_spec.value = new (std::nothrow)
        intellivue::SaFixedValSpecEntry16[sa_fixed_val_spec.count]();
      if (!sa_fixed_val_spec.value)
      {
        LOG4CPLUS_ERROR(root_logger, sfn << "Failed to allocate memory for "
          "SaFixedValSpecEntry16 list");
        return DicesRcPhilipsIntellivueMP70::MEMORY_ALLOCATION_FAILURE;
      }
      *psa_fixed_val_spec = sa_fixed_val_spec;

      for (int ix = 0; ix < sa_fixed_val_spec.count; ix++)
      {
        sa_fixed_val_spec.value[ix].sa_fixed_val_id = ntohs(
          *(reinterpret_cast<uint16_t*>(&buffer[iindex])));
        iindex += 2;
        sa_fixed_val_spec.value[ix].sa_fixed_val = ntohs(
          *(reinterpret_cast<uint16_t*>(&buffer[iindex])));
        iindex += 2;
      }
    }
      break;
    case NOM_ATTR_METRIC_STAT:
    {
      DicesRcPhilipsIntellivueMP70 status = DicesRcPhilipsIntellivueMP70::OK;
      intellivue::MetricState metric_state = 0;

      ava->attribute_val = new (std::nothrow) uint8_t[
        sizeof(intellivue::MetricState)]();
      if (!ava->attribute_val)
      {
        LOG4CPLUS_ERROR(root_logger, sfn << "Failed to allocate memory for "
          "attribute_val using MetricState");
        return DicesRcPhilipsIntellivueMP70::MEMORY_ALLOCATION_FAILURE;
      }
      intellivue::MetricState* pmetric_state =
        reinterpret_cast<intellivue::MetricState *>(ava->attribute_val);

      metric_state = ntohs(*(reinterpret_cast<uint16_t*>(&buffer[iindex])));
      iindex += 2;
      *pmetric_state = metric_state;
    }
      break;
    case NOM_ATTR_UNIT_CODE:
    {
      DicesRcPhilipsIntellivueMP70 status = DicesRcPhilipsIntellivueMP70::OK;
      intellivue::OIDType unit_code = 0;

      ava->attribute_val = new (std::nothrow) uint8_t[
        sizeof(intellivue::OIDType)]();
      if (!ava->attribute_val)
      {
        LOG4CPLUS_ERROR(root_logger, sfn << "Failed to allocate memory for "
          "attribute_val using OIDType");
        return DicesRcPhilipsIntellivueMP70::MEMORY_ALLOCATION_FAILURE;
      }
      intellivue::OIDType* punit_code =
        reinterpret_cast<intellivue::OIDType *>(ava->attribute_val);

      unit_code = ntohs(*(reinterpret_cast<uint16_t*>(&buffer[iindex])));
      iindex += 2;
      *punit_code = unit_code;
    }
      break;
    case NOM_ATTR_MODE_MSMT:
    {
      DicesRcPhilipsIntellivueMP70 status = DicesRcPhilipsIntellivueMP70::OK;
      intellivue::MeasureMode meas_mode = 0;

      ava->attribute_val = new (std::nothrow) uint8_t[
        sizeof(intellivue::MeasureMode)]();
      if (!ava->attribute_val)
      {
        LOG4CPLUS_ERROR(root_logger, sfn << "Failed to allocate memory for "
          "attribute_val using MeasureMode");
        return DicesRcPhilipsIntellivueMP70::MEMORY_ALLOCATION_FAILURE;
      }
      intellivue::MeasureMode* pmeas_mode =
        reinterpret_cast<intellivue::MeasureMode *>(ava->attribute_val);

      meas_mode = ntohs(*(reinterpret_cast<uint16_t*>(&buffer[iindex])));
      iindex += 2;
      *pmeas_mode = meas_mode;
    }
      break;
    case NOM_ATTR_METRIC_INFO_LABEL:
    {
      DicesRcPhilipsIntellivueMP70 status = DicesRcPhilipsIntellivueMP70::OK;
      intellivue::TextId text_id = 0;

      ava->attribute_val = new (std::nothrow) uint8_t[
        sizeof(intellivue::TextId)]();
      if (!ava->attribute_val)
      {
        LOG4CPLUS_ERROR(root_logger, sfn << "Failed to allocate memory for "
          "attribute_val using TextId");
        return DicesRcPhilipsIntellivueMP70::MEMORY_ALLOCATION_FAILURE;
      }
      intellivue::TextId* ptext_id =
        reinterpret_cast<intellivue::TextId *>(ava->attribute_val);

      text_id = ntohl(*(reinterpret_cast<uint32_t*>(&buffer[iindex])));
      iindex += 4;
      *ptext_id = text_id;
    }
      break;
    case NOM_ATTR_SCALE_SPECN_I16:
    {
      DicesRcPhilipsIntellivueMP70 status = DicesRcPhilipsIntellivueMP70::OK;
      intellivue::ScaleRangeSpec16 scale_range_spec16 = { 0 };

      ava->attribute_val = new (std::nothrow) uint8_t[
        sizeof(intellivue::ScaleRangeSpec16)]();
      if (!ava->attribute_val)
      {
        LOG4CPLUS_ERROR(root_logger, sfn << "Failed to allocate memory for "
          "attribute_val using ScaleRangeSpec16");
        return DicesRcPhilipsIntellivueMP70::MEMORY_ALLOCATION_FAILURE;
      }
      intellivue::ScaleRangeSpec16* pscale_range_spec16 =
        reinterpret_cast<intellivue::ScaleRangeSpec16 *>(ava->attribute_val);

      scale_range_spec16.lower_absolute_value = ntohl(
        *(reinterpret_cast<uint32_t*>(&buffer[iindex])));
      iindex += 4;
      scale_range_spec16.upper_absolute_value = ntohl(
        *(reinterpret_cast<uint32_t*>(&buffer[iindex])));
      iindex += 4;
      scale_range_spec16.lower_scaled_value = ntohs(
        *(reinterpret_cast<uint16_t*>(&buffer[iindex])));
      iindex += 2;
      scale_range_spec16.upper_scaled_value = ntohs(
        *(reinterpret_cast<uint16_t*>(&buffer[iindex])));
      iindex += 2;
      *pscale_range_spec16 = scale_range_spec16;
    }
      break;
    case NOM_ATTR_SA_RANGE_PHYS_I16:
    {
      DicesRcPhilipsIntellivueMP70 status = DicesRcPhilipsIntellivueMP70::OK;
      intellivue::ScaledRange16 scaled_range16 = { 0 };

      ava->attribute_val = new (std::nothrow) uint8_t[
        sizeof(intellivue::ScaledRange16)]();
      if (!ava->attribute_val)
      {
        LOG4CPLUS_ERROR(root_logger, sfn << "Failed to allocate memory for "
          "attribute_val using ScaledRange16");
        return DicesRcPhilipsIntellivueMP70::MEMORY_ALLOCATION_FAILURE;
      }
      intellivue::ScaledRange16* pscaled_range16 =
        reinterpret_cast<intellivue::ScaledRange16 *>(ava->attribute_val);

      scaled_range16.lower_scaled_value = ntohs(
        *(reinterpret_cast<uint16_t*>(&buffer[iindex])));
      iindex += 2;
      scaled_range16.upper_scaled_value = ntohs(
        *(reinterpret_cast<uint16_t*>(&buffer[iindex])));
      iindex += 2;
      *pscaled_range16 = scaled_range16;
    }
      break;
    case NOM_ATTR_GRID_VIS_I16:
    {
      DicesRcPhilipsIntellivueMP70 status = DicesRcPhilipsIntellivueMP70::OK;
      intellivue::SaVisualGrid16 sa_vis_grid16 = { 0 };

      ava->attribute_val = new (std::nothrow) uint8_t[
        sizeof(intellivue::SaVisualGrid16)]();
      if (!ava->attribute_val)
      {
        LOG4CPLUS_ERROR(root_logger, sfn << "Failed to allocate memory for "
          "attribute_val using SaVisualGrid16");
        return DicesRcPhilipsIntellivueMP70::MEMORY_ALLOCATION_FAILURE;
      }
      intellivue::SaVisualGrid16* psa_vis_grid16 =
        reinterpret_cast<intellivue::SaVisualGrid16 *>(ava->attribute_val);

      sa_vis_grid16.count = ntohs(
        *(reinterpret_cast<uint16_t*>(&buffer[iindex])));
      iindex += 2;
      sa_vis_grid16.length = ntohs(
        *(reinterpret_cast<uint16_t*>(&buffer[iindex])));
      iindex += 2;
      sa_vis_grid16.value = new (std::nothrow)
        intellivue::SaGridEntry16[sa_vis_grid16.count]();
      if (!sa_vis_grid16.value)
      {
        LOG4CPLUS_ERROR(root_logger, sfn << "Failed to allocate memory for "
          "SaGridEntry16 list");
        return DicesRcPhilipsIntellivueMP70::MEMORY_ALLOCATION_FAILURE;
      }
      *psa_vis_grid16 = sa_vis_grid16;
      for (int ix = 0; ix < sa_vis_grid16.count; ix++)
      {
        sa_vis_grid16.value[ix].absolute_value = ntohl(
          *(reinterpret_cast<uint32_t*>(&buffer[iindex])));
        iindex += 4;
        sa_vis_grid16.value[ix].scaled_value = ntohs(
          *(reinterpret_cast<uint16_t*>(&buffer[iindex])));
        iindex += 2;
        sa_vis_grid16.value[ix].level = ntohs(
          *(reinterpret_cast<uint16_t*>(&buffer[iindex])));
        iindex += 2;
      }
    }
      break;
    case NOM_ATTR_SA_CALIB_I16:
    {
      DicesRcPhilipsIntellivueMP70 status = DicesRcPhilipsIntellivueMP70::OK;
      intellivue::SaCalData16 sa_cal_data16 = { 0 };

      ava->attribute_val = new (std::nothrow) uint8_t[
        sizeof(intellivue::SaCalData16)]();
      if (!ava->attribute_val)
      {
        LOG4CPLUS_ERROR(root_logger, sfn << "Failed to allocate memory for "
          "attribute_val using SaCalData16");
        return DicesRcPhilipsIntellivueMP70::MEMORY_ALLOCATION_FAILURE;
      }
      intellivue::SaCalData16* psa_cal_data16 =
        reinterpret_cast<intellivue::SaCalData16 *>(ava->attribute_val);

      sa_cal_data16.lower_absolute_value = ntohl(
        *(reinterpret_cast<uint32_t*>(&buffer[iindex])));
      iindex += 4;
      sa_cal_data16.upper_absolute_value = ntohl(
        *(reinterpret_cast<uint32_t*>(&buffer[iindex])));
      iindex += 4;
      sa_cal_data16.lower_scaled_value = ntohs(
        *(reinterpret_cast<uint16_t*>(&buffer[iindex])));
      iindex += 2;
      sa_cal_data16.upper_scaled_value = ntohs(
        *(reinterpret_cast<uint16_t*>(&buffer[iindex])));
      iindex += 2;
      sa_cal_data16.increment = ntohs(
        *(reinterpret_cast<uint16_t*>(&buffer[iindex])));
      iindex += 2;
      sa_cal_data16.cal_type = ntohs(
        *(reinterpret_cast<uint16_t*>(&buffer[iindex])));
      iindex += 2;
    }
      break;
    case NOM_ATTR_SA_VAL_OBS:
    {
      DicesRcPhilipsIntellivueMP70 status = DicesRcPhilipsIntellivueMP70::OK;
      intellivue::SaObsValue sa_obs_value = { 0 };

      ava->attribute_val = new (std::nothrow) uint8_t[
        sizeof(intellivue::SaObsValue)]();
      if (!ava->attribute_val)
      {
        LOG4CPLUS_ERROR(root_logger, sfn << "Failed to allocate memory for "
          "attribute_val using SaObsValue");
        return DicesRcPhilipsIntellivueMP70::MEMORY_ALLOCATION_FAILURE;
      }
      intellivue::SaObsValue* psa_obs_value =
        reinterpret_cast<intellivue::SaObsValue *>(ava->attribute_val);

      sa_obs_value.physio_id = ntohs(
        *(reinterpret_cast<uint16_t*>(&buffer[iindex])));
      iindex += 2;
      sa_obs_value.state = ntohs(
        *(reinterpret_cast<uint16_t*>(&buffer[iindex])));
      iindex += 2;
      sa_obs_value.array.length = ntohs(
        *(reinterpret_cast<uint16_t*>(&buffer[iindex])));
      iindex += 2;
      sa_obs_value.array.value = new (std::nothrow) uint8_t[
        sa_obs_value.array.length]();
      if (!sa_obs_value.array.value)
      {
        LOG4CPLUS_ERROR(root_logger, sfn << "Failed to allocate memory for "
          "SaObsValue array value");
        return DicesRcPhilipsIntellivueMP70::MEMORY_ALLOCATION_FAILURE;
      }
      *psa_obs_value = sa_obs_value;
      memcpy(
        sa_obs_value.array.value,
        &buffer[iindex],
        sa_obs_value.array.length);
      iindex += sa_obs_value.array.length;
    }
      break;
    case NOM_ATTR_SA_CMPD_VAL_OBS:
    {
      DicesRcPhilipsIntellivueMP70 status = DicesRcPhilipsIntellivueMP70::OK;
      intellivue::SaObsValueCmp sa_obs_value_cmp = { 0 };

      ava->attribute_val = new (std::nothrow) uint8_t[
        sizeof(intellivue::SaObsValueCmp)]();
      if (!ava->attribute_val)
      {
        LOG4CPLUS_ERROR(root_logger, sfn << "Failed to allocate memory for "
          "attribute_val using SaObsValueCmp");
        return DicesRcPhilipsIntellivueMP70::MEMORY_ALLOCATION_FAILURE;
      }
      intellivue::SaObsValueCmp* psa_obs_value_cmp =
        reinterpret_cast<intellivue::SaObsValueCmp *>(ava->attribute_val);

      sa_obs_value_cmp.count = ntohs(
        *(reinterpret_cast<uint16_t*>(&buffer[iindex])));
      iindex += 2;
      sa_obs_value_cmp.length = ntohs(
        *(reinterpret_cast<uint16_t*>(&buffer[iindex])));
      iindex += 2;

      sa_obs_value_cmp.value = new (std::nothrow) intellivue::SaObsValue[
        sa_obs_value_cmp.count]();
      if (!sa_obs_value_cmp.value)
      {
        LOG4CPLUS_ERROR(root_logger, sfn << "Failed to allocate memory for "
          "SaObsValue list");
        return DicesRcPhilipsIntellivueMP70::MEMORY_ALLOCATION_FAILURE;
      }
      *psa_obs_value_cmp = sa_obs_value_cmp;

      for (int ix = 0; ix < sa_obs_value_cmp.count; ix++)
      {
        sa_obs_value_cmp.value[ix].physio_id = ntohs(
          *(reinterpret_cast<uint16_t*>(&buffer[iindex])));
        iindex += 2;
        sa_obs_value_cmp.value[ix].state = ntohs(
          *(reinterpret_cast<uint16_t*>(&buffer[iindex])));
        iindex += 2;
        sa_obs_value_cmp.value[ix].array.length = ntohs(
          *(reinterpret_cast<uint16_t*>(&buffer[iindex])));
        iindex += 2;
        sa_obs_value_cmp.value[ix].array.value = new (std::nothrow) uint8_t[
          sa_obs_value_cmp.value[ix].array.length]();
        if (!sa_obs_value_cmp.value[ix].array.value)
        {
          LOG4CPLUS_ERROR(root_logger, sfn << "Failed to allocate memory for "
            "SaObsValue array value");
          return DicesRcPhilipsIntellivueMP70::MEMORY_ALLOCATION_FAILURE;
        }
        memcpy(
          sa_obs_value_cmp.value[ix].array.value,
          &buffer[iindex],
          sa_obs_value_cmp.value[ix].array.length);
        iindex += sa_obs_value_cmp.value[ix].array.length;
      }
    }
      break;
    case NOM_ATTR_DEV_AL_COND:
    {
      intellivue::DeviceAlertCondition device_alert_cond = { 0 };

      ava->attribute_val = new (std::nothrow) uint8_t[
        sizeof(intellivue::DeviceAlertCondition)]();
      if (!ava->attribute_val)
      {
        LOG4CPLUS_ERROR(root_logger, sfn << "Failed to allocate memory for "
          "attribute_val using DeviceAlertCondition. attribute_id: "
          << static_cast<int>(ava->attribute_id));
        return DicesRcPhilipsIntellivueMP70::MEMORY_ALLOCATION_FAILURE;
      }
      intellivue::DeviceAlertCondition* pdevice_alert_cond =
        reinterpret_cast<intellivue::DeviceAlertCondition *>(
        ava->attribute_val);

      device_alert_cond.device_alert_state = ntohs(
        *(reinterpret_cast<uint16_t*>(&buffer[iindex])));
      iindex += 2;
      device_alert_cond.al_stat_chg_cnt = ntohs(
        *(reinterpret_cast<uint16_t*>(&buffer[iindex])));
      iindex += 2;
      device_alert_cond.max_p_alarm = ntohs(
        *(reinterpret_cast<uint16_t*>(&buffer[iindex])));
      iindex += 2;
      device_alert_cond.max_t_alarm = ntohs(
        *(reinterpret_cast<uint16_t*>(&buffer[iindex])));
      iindex += 2;
      device_alert_cond.max_aud_alarm = ntohs(
        *(reinterpret_cast<uint16_t*>(&buffer[iindex])));
      iindex += 2;

      *pdevice_alert_cond = device_alert_cond;
    }
      break;
    case NOM_ATTR_AL_MON_T_AL_LIST:
    case NOM_ATTR_AL_MON_P_AL_LIST:
    {
      intellivue::DevAlarmList device_alarm_list = { 0 };

      ava->attribute_val = new (std::nothrow) uint8_t[
        sizeof(intellivue::DevAlarmList)]();
      if (!ava->attribute_val)
      {
        LOG4CPLUS_ERROR(root_logger, sfn << "Failed to allocate memory for "
          "attribute_val using DevAlarmList. attribute_id: "
          << static_cast<int>(ava->attribute_id));
        return DicesRcPhilipsIntellivueMP70::MEMORY_ALLOCATION_FAILURE;
      }
      intellivue::DevAlarmList* pdevice_alarm_list =
        reinterpret_cast<intellivue::DevAlarmList *>(ava->attribute_val);

      device_alarm_list.count = ntohs(
        *(reinterpret_cast<uint16_t*>(&buffer[iindex])));
      iindex += 2;
      device_alarm_list.length = ntohs(
        *(reinterpret_cast<uint16_t*>(&buffer[iindex])));
      iindex += 2;

      device_alarm_list.value = new (std::nothrow) intellivue::DevAlarmEntry[
        device_alarm_list.count]();
      if (!device_alarm_list.value)
      {
        LOG4CPLUS_ERROR(root_logger, sfn << "Failed to allocate memory for "
          "DevAlarmEntry list. attribute_id: " << static_cast<int>(
          ava->attribute_id));
        return DicesRcPhilipsIntellivueMP70::MEMORY_ALLOCATION_FAILURE;
      }
      *pdevice_alarm_list = device_alarm_list;

      for (int ix = 0; ix < device_alarm_list.count; ix++)
      {
        device_alarm_list.value[ix].al_source = ntohs(
          *(reinterpret_cast<uint16_t*>(&buffer[iindex])));
        iindex += 2;
        device_alarm_list.value[ix].al_code = ntohs(
          *(reinterpret_cast<uint16_t*>(&buffer[iindex])));
        iindex += 2;
        device_alarm_list.value[ix].al_type = ntohs(
          *(reinterpret_cast<uint16_t*>(&buffer[iindex])));
        iindex += 2;
        device_alarm_list.value[ix].al_state = ntohs(
          *(reinterpret_cast<uint16_t*>(&buffer[iindex])));
        iindex += 2;
        device_alarm_list.value[ix].object.m_obj_class = ntohs(
          *(reinterpret_cast<uint16_t*>(&buffer[iindex])));
        iindex += 2;
        device_alarm_list.value[ix].object.m_obj_inst.context_id = ntohs(
          *(reinterpret_cast<uint16_t*>(&buffer[iindex])));
        iindex += 2;
        device_alarm_list.value[ix].object.m_obj_inst.handle = ntohs(
          *(reinterpret_cast<uint16_t*>(&buffer[iindex])));
        iindex += 2;
        device_alarm_list.value[ix].alert_info_id = ntohs(
          *(reinterpret_cast<uint16_t*>(&buffer[iindex])));
        iindex += 2;
        device_alarm_list.value[ix].length = ntohs(
          *(reinterpret_cast<uint16_t*>(&buffer[iindex])));
        iindex += 2;

        switch (device_alarm_list.value[ix].alert_info_id)
        {
          case GEN_ALMON_INFO:
          {
            intellivue::AlMonGenInfo al_mon_gen_info = { 0 };

            device_alarm_list.value[ix].alert_info = new (std::nothrow)
              uint8_t[sizeof(intellivue::AlMonGenInfo)]();
            if (!device_alarm_list.value[ix].alert_info)
            {
              LOG4CPLUS_ERROR(root_logger, sfn << "Failed to allocate memory "
                "for alert_info using AlMonGenInfo. attribute_id: "
                << static_cast<int>(ava->attribute_id));
              return DicesRcPhilipsIntellivueMP70::MEMORY_ALLOCATION_FAILURE;
            }
            intellivue::AlMonGenInfo* pal_mon_gen_info =
              reinterpret_cast<intellivue::AlMonGenInfo *>(
              device_alarm_list.value[ix].alert_info);

            al_mon_gen_info.al_inst_no = ntohs(
              *(reinterpret_cast<uint16_t*>(&buffer[iindex])));
            iindex += 2;
            al_mon_gen_info.al_text = ntohl(
              *(reinterpret_cast<uint32_t*>(&buffer[iindex])));
            iindex += 4;
            al_mon_gen_info.priority = ntohs(
              *(reinterpret_cast<uint16_t*>(&buffer[iindex])));
            iindex += 2;
            al_mon_gen_info.flags = ntohs(
              *(reinterpret_cast<uint16_t*>(&buffer[iindex])));
            iindex += 2;
            *pal_mon_gen_info = al_mon_gen_info;
          }
            break;
          case STR_ALMON_INFO:
          {
            intellivue::StrAlMonInfo str_al_mon_info = { 0 };

            device_alarm_list.value[ix].alert_info = new (std::nothrow)
              uint8_t[sizeof(intellivue::StrAlMonInfo)]();
            if (!device_alarm_list.value[ix].alert_info)
            {
              LOG4CPLUS_ERROR(root_logger, sfn << "Failed to allocate memory "
                "for alert_info using StrAlMonInfo. attribute_id: "
                << static_cast<int>(ava->attribute_id));
              return DicesRcPhilipsIntellivueMP70::MEMORY_ALLOCATION_FAILURE;
            }
            intellivue::StrAlMonInfo* pstr_al_mon_info =
              reinterpret_cast<intellivue::StrAlMonInfo *>(
              device_alarm_list.value[ix].alert_info);

            str_al_mon_info.al_inst_no = ntohs(
              *(reinterpret_cast<uint16_t*>(&buffer[iindex])));
            iindex += 2;
            str_al_mon_info.al_text = ntohl(
              *(reinterpret_cast<uint32_t*>(&buffer[iindex])));
            iindex += 4;
            str_al_mon_info.priority = ntohs(
              *(reinterpret_cast<uint16_t*>(&buffer[iindex])));
            iindex += 2;
            str_al_mon_info.flags = ntohs(
              *(reinterpret_cast<uint16_t*>(&buffer[iindex])));
            iindex += 2;
            str_al_mon_info.string.length = ntohs(
              *(reinterpret_cast<uint16_t*>(&buffer[iindex])));
            iindex += 2;
            *pstr_al_mon_info = str_al_mon_info;

            str_al_mon_info.string.value = new (std::nothrow)
              uint16_t[str_al_mon_info.string.length]();
            if (!str_al_mon_info.string.value)
            {
              LOG4CPLUS_ERROR(root_logger, sfn << "Failed to allocate memory "
                "for String value using uint16_t. attribute_id: "
                << static_cast<int>(ava->attribute_id));
              return DicesRcPhilipsIntellivueMP70::MEMORY_ALLOCATION_FAILURE;
            }
            *pstr_al_mon_info = str_al_mon_info;

            memmove(
              str_al_mon_info.string.value,
              &buffer[iindex],
              str_al_mon_info.string.length);
            iindex += str_al_mon_info.string.length;
          }
            break;
          default:
            LOG4CPLUS_WARN(root_logger, sfn << "Unknown alert_info_id ("
              << static_cast<int>(device_alarm_list.value[ix].alert_info_id)
              << ") received from the Intellivue. attribute_id: "
              << static_cast<int>(ava->attribute_id));
            break;
        }
      }
    }
      break;
    case NOM_ATTR_PT_DEMOG_ST:
    {
      intellivue::PatDemoState pat_demo_state = 0;

      ava->attribute_val = new (std::nothrow) uint8_t[
        sizeof(intellivue::PatDemoState)]();
      if (!ava->attribute_val)
      {
        LOG4CPLUS_ERROR(root_logger, sfn << "Failed to allocate memory for "
          "attribute_val using PatDemoState. attribute_id: "
          << static_cast<int>(ava->attribute_id));
        return DicesRcPhilipsIntellivueMP70::MEMORY_ALLOCATION_FAILURE;
      }
      intellivue::PatDemoState* ppat_demo_state =
        reinterpret_cast<intellivue::PatDemoState *>(
        ava->attribute_val);

      pat_demo_state = ntohs(
        *(reinterpret_cast<uint16_t*>(&buffer[iindex])));
      iindex += 2;

      *ppat_demo_state = pat_demo_state;
    }
      break;
    case NOM_ATTR_PT_TYPE:
    {
      intellivue::PatientType patient_type = 0;

      ava->attribute_val = new (std::nothrow) uint8_t[
        sizeof(intellivue::PatientType)]();
      if (!ava->attribute_val)
      {
        LOG4CPLUS_ERROR(root_logger, sfn << "Failed to allocate memory for "
          "attribute_val using PatientType. attribute_id: "
          << static_cast<int>(ava->attribute_id));
        return DicesRcPhilipsIntellivueMP70::MEMORY_ALLOCATION_FAILURE;
      }
      intellivue::PatientType* ppatient_type =
        reinterpret_cast<intellivue::PatientType *>(
        ava->attribute_val);

      patient_type = ntohs(
        *(reinterpret_cast<uint16_t*>(&buffer[iindex])));
      iindex += 2;

      *ppatient_type = patient_type;
    }
      break;
    case NOM_ATTR_PT_PACED_MODE:
    {
      intellivue::PatPacedMode pat_paced_mode = 0;

      ava->attribute_val = new (std::nothrow) uint8_t[
        sizeof(intellivue::PatPacedMode)]();
      if (!ava->attribute_val)
      {
        LOG4CPLUS_ERROR(root_logger, sfn << "Failed to allocate memory for "
          "attribute_val using PatPacedMode. attribute_id: "
          << static_cast<int>(ava->attribute_id));
        return DicesRcPhilipsIntellivueMP70::MEMORY_ALLOCATION_FAILURE;
      }
      intellivue::PatPacedMode* ppat_paced_mode =
        reinterpret_cast<intellivue::PatPacedMode *>(
        ava->attribute_val);

      pat_paced_mode = ntohs(
        *(reinterpret_cast<uint16_t*>(&buffer[iindex])));
      iindex += 2;

      *ppat_paced_mode = pat_paced_mode;
    }
      break;
    case NOM_ATTR_PT_SEX:
    {
      intellivue::PatientSex patient_sex = 0;

      ava->attribute_val = new (std::nothrow) uint8_t[
        sizeof(intellivue::PatientSex)]();
      if (!ava->attribute_val)
      {
        LOG4CPLUS_ERROR(root_logger, sfn << "Failed to allocate memory for "
          "attribute_val using PatientSex. attribute_id: "
          << static_cast<int>(ava->attribute_id));
        return DicesRcPhilipsIntellivueMP70::MEMORY_ALLOCATION_FAILURE;
      }
      intellivue::PatientSex* ppatient_sex =
        reinterpret_cast<intellivue::PatientSex *>(
        ava->attribute_val);

      patient_sex = ntohs(
        *(reinterpret_cast<uint16_t*>(&buffer[iindex])));
      iindex += 2;

      *ppatient_sex = patient_sex;
    }
      break;
    case NOM_ATTR_PT_HEIGHT:
    case NOM_ATTR_PT_WEIGHT:
    case NOM_ATTR_PT_AGE:
    case NOM_ATTR_PT_BSA:
    {
      intellivue::PatMeasure pat_measure = { 0 };

      ava->attribute_val = new (std::nothrow) uint8_t[
        sizeof(intellivue::PatMeasure)]();
      if (!ava->attribute_val)
      {
        LOG4CPLUS_ERROR(root_logger, sfn << "Failed to allocate memory for "
          "attribute_val using PatMeasure. attribute_id: "
          << static_cast<int>(ava->attribute_id));
        return DicesRcPhilipsIntellivueMP70::MEMORY_ALLOCATION_FAILURE;
      }
      intellivue::PatMeasure* ppat_measure =
        reinterpret_cast<intellivue::PatMeasure *>(
        ava->attribute_val);

      pat_measure.value = ntohl(
        *(reinterpret_cast<uint32_t*>(&buffer[iindex])));
      iindex += 4;
      pat_measure.m_unit = ntohs(
        *(reinterpret_cast<uint16_t*>(&buffer[iindex])));
      iindex += 2;

      *ppat_measure = pat_measure;
    }
      break;
    case NOM_ATTR_PT_BSA_FORMULA:
    {
      intellivue::PtBsaFormula pt_bsa_formula = 0;

      ava->attribute_val = new (std::nothrow) uint8_t[
        sizeof(intellivue::PtBsaFormula)]();
      if (!ava->attribute_val)
      {
        LOG4CPLUS_ERROR(root_logger, sfn << "Failed to allocate memory for "
          "attribute_val using PtBsaFormula. attribute_id: "
          << static_cast<int>(ava->attribute_id));
        return DicesRcPhilipsIntellivueMP70::MEMORY_ALLOCATION_FAILURE;
      }
      intellivue::PtBsaFormula* ppt_bsa_formula =
        reinterpret_cast<intellivue::PtBsaFormula *>(
        ava->attribute_val);

      pt_bsa_formula = ntohs(
        *(reinterpret_cast<uint16_t*>(&buffer[iindex])));
      iindex += 2;

      *ppt_bsa_formula = pt_bsa_formula;
    }
      break;
    case NOM_ATTR_VAL_ENUM_OBS:
    {
      intellivue::EnumObsVal enum_obs_val = { 0 };

      ava->attribute_val = new (std::nothrow) uint8_t[
        sizeof(intellivue::EnumObsVal)]();
      if (!ava->attribute_val)
      {
        LOG4CPLUS_ERROR(root_logger, sfn << "Failed to allocate memory for "
          "attribute_val using intellivue::EnumObsVal. attribute_id: "
          << static_cast<int>(ava->attribute_id));
        return DicesRcPhilipsIntellivueMP70::MEMORY_ALLOCATION_FAILURE;
      }
      intellivue::EnumObsVal* penum_obs_val =
        reinterpret_cast<intellivue::EnumObsVal *>(
        ava->attribute_val);

      enum_obs_val.physio_id = ntohs(
        *(reinterpret_cast<uint16_t*>(&buffer[iindex])));
      iindex += 2;
      enum_obs_val.state = ntohs(
        *(reinterpret_cast<uint16_t*>(&buffer[iindex])));
      iindex += 2;
      enum_obs_val.value.choice = ntohs(
        *(reinterpret_cast<uint16_t*>(&buffer[iindex])));
      iindex += 2;
      enum_obs_val.value.length = ntohs(
        *(reinterpret_cast<uint16_t*>(&buffer[iindex])));
      iindex += 2;

      switch (enum_obs_val.value.choice)
      {
        case ENUM_OBJ_ID_CHOSEN:
          enum_obs_val.value.u.enum_obj_id = ntohs(
            *(reinterpret_cast<uint16_t*>(&buffer[iindex])));
          iindex += 2;
          break;
        case ENUM_OBJ_ID_VAL_CHOSEN:
          enum_obs_val.value.u.enum_obj_id_val.obj_id = ntohs(
            *(reinterpret_cast<uint16_t*>(&buffer[iindex])));
          iindex += 2;
          enum_obs_val.value.u.enum_obj_id_val.num_val = ntohl(
            *(reinterpret_cast<uint32_t*>(&buffer[iindex])));
          iindex += 4;
          enum_obs_val.value.u.enum_obj_id_val.unit_code = ntohs(
            *(reinterpret_cast<uint16_t*>(&buffer[iindex])));
          iindex += 2;
          break;
        default:
          LOG4CPLUS_WARN(root_logger, sfn << "Found unknown EnumVal "
            "choice (" << static_cast<int>(enum_obs_val.value.choice) << ")."
            ". attribute_id: " << static_cast<int>(ava->attribute_id));
          break;
      }
      *penum_obs_val = enum_obs_val;
    }
      break;
    case NOM_ATTR_POLL_RTSA_PRIO_LIST:
    {
      intellivue::TextIdList text_id_list = { 0 };

      ava->attribute_val = new (std::nothrow) uint8_t[
        sizeof(intellivue::TextIdList)]();
      if (!ava->attribute_val)
      {
        LOG4CPLUS_ERROR(root_logger, sfn << "Failed to allocate memory for "
          "attribute_val using intellivue::TextIdList. attribute_id: "
          << static_cast<int>(ava->attribute_id));
        return DicesRcPhilipsIntellivueMP70::MEMORY_ALLOCATION_FAILURE;
      }
      intellivue::TextIdList* ptext_id_list =
        reinterpret_cast<intellivue::TextIdList *>(
        ava->attribute_val);

      text_id_list.count = ntohs(*(reinterpret_cast<uint16_t*>(
        &buffer[iindex])));
      iindex += 2;
      text_id_list.length = ntohs(*(reinterpret_cast<uint16_t*>(
        &buffer[iindex])));
      iindex += 2;

      text_id_list.value = new (std::nothrow) intellivue::TextId[
        text_id_list.count]();
      if (!text_id_list.value)
      {
        LOG4CPLUS_ERROR(root_logger, sfn << "Failed to allocate memory for "
          "TextId list.");
        return DicesRcPhilipsIntellivueMP70::MEMORY_ALLOCATION_FAILURE;
      }
      *ptext_id_list = text_id_list;

      for (int ix = 0; ix < text_id_list.count; ix++)
      {
        text_id_list.value[ix] = ntohl(*(reinterpret_cast<uint32_t*>(
          &buffer[iindex])));
        iindex += 4;
      }
    }
      break;
    default:
      LOG4CPLUS_INFO(root_logger, sfn << "Found unknown AVAType attribute_id "
        << static_cast<int>(ava->attribute_id));
      break;
  }

  return DicesRcPhilipsIntellivueMP70::OK;
}

DicesRcPhilipsIntellivueMP70 IntellivueUtils::DeleteAttribute(
  intellivue::AVAType* ava)
{
  static const char* sfn = "IntellivueUtils::DeleteAttribute() ";
  if (!ava)
  {
    LOG4CPLUS_ERROR(root_logger, sfn << "Function argument ava is a null "
      "pointer.");
    return DicesRcPhilipsIntellivueMP70::NULL_POINTER_FUNCTION_ARGUMENT_FAILURE;
  }

  if (!ava->attribute_val)
  {
    LOG4CPLUS_INFO(root_logger, sfn << "Deleting AVAType with null pointer "
      "attribute_val. attribute_id: " << static_cast<int>(ava->attribute_id));
    // It's safe to pass a null pointer to delete. That's why we're logging
    // and continuing.
  }

  switch (ava->attribute_id)
  {
    case NOM_ATTR_ID_TYPE:
    case NOM_ATTR_SYS_TYPE:
    case NOM_ATTR_LOCALIZN:
    case NOM_ATTR_NET_ADDR_INFO:
    case NOM_ATTR_ID_HANDLE:
    case NOM_ATTR_NOM_VERS:
    case NOM_ATTR_VMS_MDS_STAT:
    case NOM_ATTR_MODE_OP:
    case NOM_ATTR_AREA_APPL:
    case NOM_ATTR_TIME_STAMP_ABS:
    case NOM_ATTR_TIME_ABS:
    case NOM_ATTR_PT_DOB:
    case NOM_ATTR_TIME_PD_SAMP:
    case NOM_ATTR_TIME_STAMP_REL:
    case NOM_ATTR_TIME_REL:
    case NOM_ATTR_ALTITUDE:
    case NOM_ATTR_LINE_FREQ:
    case NOM_ATTR_ID_ASSOC_NO:
    case NOM_ATTR_ID_LABEL:
    case NOM_ATTR_DISP_RES:
    case NOM_ATTR_COLOR:
    case NOM_ATTR_METRIC_SPECN:
    case NOM_ATTR_NU_VAL_OBS:
    case NOM_ATTR_SA_SPECN:
    case NOM_ATTR_METRIC_STAT:
    case NOM_ATTR_UNIT_CODE:
    case NOM_ATTR_MODE_MSMT:
    case NOM_ATTR_METRIC_INFO_LABEL:
    case NOM_ATTR_SCALE_SPECN_I16:
    case NOM_ATTR_SA_RANGE_PHYS_I16:
    case NOM_ATTR_SA_CALIB_I16:
    case NOM_ATTR_DEV_AL_COND:
    case NOM_ATTR_PT_DEMOG_ST:
    case NOM_ATTR_PT_TYPE:
    case NOM_ATTR_PT_PACED_MODE:
    case NOM_ATTR_PT_SEX:
    case NOM_ATTR_PT_HEIGHT:
    case NOM_ATTR_PT_WEIGHT:
    case NOM_ATTR_PT_AGE:
    case NOM_ATTR_PT_BSA:
    case NOM_ATTR_PT_BSA_FORMULA:
    case NOM_ATTR_VAL_ENUM_OBS:
      delete [] ava->attribute_val;
      ava->attribute_val = nullptr;
      break;
    case NOM_ATTR_PCOL_SUPPORT:
    {
      intellivue::ProtoSupport* pps =
        reinterpret_cast<intellivue::ProtoSupport *>(ava->attribute_val);
      if (pps)
      {
        delete [] pps->value;
        pps->value = nullptr;
      }
      delete [] ava->attribute_val;
      ava->attribute_val = nullptr;
    }
      break;
    case NOM_ATTR_ID_PROD_SPECN:
    {
      intellivue::ProductionSpec* ppspec =
        reinterpret_cast<intellivue::ProductionSpec *>(ava->attribute_val);
      if (ppspec)
      {
        if (ppspec->value)
        {
          for (int ix = 0; ix < ppspec->count; ix++)
          {
            delete [] ppspec->value[ix].prod_spec.value;
            ppspec->value[ix].prod_spec.value = nullptr;
          }
        }
        delete [] ppspec->value;
        ppspec->value = nullptr;
      }
      delete [] ava->attribute_val;
      ava->attribute_val = nullptr;
    }
      break;
    case NOM_ATTR_ID_MODEL:
    {
      intellivue::SystemModel* psm =
        reinterpret_cast<intellivue::SystemModel *>(ava->attribute_val);
      if (psm)
      {
        delete [] psm->manufacturer.value;
        psm->manufacturer.value = nullptr;
        delete [] psm->model_number.value;
        psm->model_number.value = nullptr;
      }
      delete [] ava->attribute_val;
      ava->attribute_val = nullptr;
    }
      break;
    case NOM_POLL_PROFILE_SUPPORT:
    {
      intellivue::PollProfileSupport* ppps =
        reinterpret_cast<intellivue::PollProfileSupport *>(ava->attribute_val);
      if (ppps)
      {
        delete [] ppps->optional_packages.value;
        ppps->optional_packages.value = nullptr;
      }
      delete [] ava->attribute_val;
      ava->attribute_val = nullptr;
    }
      break;
    case NOM_ATTR_POLL_PROFILE_EXT:
    {
      intellivue::PollProfileExt* pppe =
        reinterpret_cast<intellivue::PollProfileExt *>(ava->attribute_val);
      if (pppe)
      {
        delete [] pppe->ext_attr.value;
        pppe->ext_attr.value = nullptr;
      }
      delete [] ava->attribute_val;
      ava->attribute_val = nullptr;
    }
      break;
    case NOM_ATTR_SYS_ID:
    {
      intellivue::VariableLabel* pvar_label
        = reinterpret_cast<intellivue::VariableLabel *>(ava->attribute_val);
      if (pvar_label)
      {
        delete [] pvar_label->value;
        pvar_label->value = nullptr;
      }
      delete [] ava->attribute_val;
      ava->attribute_val = nullptr;
    }
      break;
    case NOM_ATTR_SYS_SPECN:
    {
      intellivue::SystemSpec* psysspec =
        reinterpret_cast<intellivue::SystemSpec *>(ava->attribute_val);
      if (psysspec)
      {
        if (psysspec->value)
        {
          for (int ix = 0; ix < psysspec->count; ix++)
          {
            intellivue::MdibObjectSupport* pmdib =
              reinterpret_cast<intellivue::MdibObjectSupport *>(
              psysspec->value[ix].value);
            if (pmdib)
            {
              delete [] pmdib->value;
              pmdib->value = nullptr;
            }
            delete [] psysspec->value[ix].value;
            psysspec->value[ix].value = nullptr;
          }
        }
        delete [] psysspec->value;
        psysspec->value = nullptr;
      }
      delete [] ava->attribute_val;
      ava->attribute_val = nullptr;
    }
      break;
    case NOM_ATTR_MDS_GEN_INFO:
    {
      intellivue::MdsGenSystemInfo* pmgsi =
        reinterpret_cast<intellivue::MdsGenSystemInfo *>(ava->attribute_val);
      if (pmgsi)
      {
        if (pmgsi->value)
        {
          for (int ix = 0; ix < pmgsi->count; ix++)
          {
            delete [] pmgsi->value[ix].value;
            pmgsi->value[ix].value = nullptr;
          }
        }
        delete [] pmgsi->value;
        pmgsi->value = nullptr;
      }
      delete [] ava->attribute_val;
      ava->attribute_val = nullptr;
    }
      break;
    case NOM_ATTR_METRIC_INFO_LABEL_STR:
    case NOM_ATTR_ID_LABEL_STRING:
    case NOM_ATTR_ID_BED_LABEL:
    case NOM_ATTR_PT_NAME_GIVEN:
    case NOM_ATTR_PT_NAME_FAMILY:
    case NOM_ATTR_PT_ID:
    case NOM_ATTR_PT_NOTES1:
    case NOM_ATTR_PT_NOTES2:
    {
      intellivue::String* plabel =
        reinterpret_cast<intellivue::String *>(ava->attribute_val);
      if (plabel)
      {
        delete [] plabel->value;
        plabel->value = nullptr;
      }
      delete [] ava->attribute_val;
      ava->attribute_val = nullptr;
    }
      break;

    case NOM_ATTR_NU_CMPD_VAL_OBS:
    {
      intellivue::NuObsValueCmp* pnucmp =
        reinterpret_cast<intellivue::NuObsValueCmp *>(ava->attribute_val);
      if (pnucmp)
      {
        delete [] pnucmp->value;
        pnucmp->value = nullptr;
      }
      delete [] ava->attribute_val;
      ava->attribute_val = nullptr;
    }
      break;
    case NOM_ATTR_SA_FIXED_VAL_SPECN:
    {
      intellivue::SaFixedValSpec16* psa_fixed_val_spec =
        reinterpret_cast<intellivue::SaFixedValSpec16 *>(ava->attribute_val);
      if (psa_fixed_val_spec)
      {
        delete [] psa_fixed_val_spec->value;
        psa_fixed_val_spec->value = nullptr;
      }
      delete [] ava->attribute_val;
      ava->attribute_val = nullptr;
    }
      break;
    case NOM_ATTR_GRID_VIS_I16:
    {
      intellivue::SaVisualGrid16* psa_vis_grid16 =
        reinterpret_cast<intellivue::SaVisualGrid16 *>(ava->attribute_val);
      if (psa_vis_grid16)
      {
        delete [] psa_vis_grid16->value;
        psa_vis_grid16->value = nullptr;
      }
      delete [] ava->attribute_val;
      ava->attribute_val = nullptr;
    }
      break;
    case NOM_ATTR_SA_VAL_OBS:
    {
      intellivue::SaObsValue* psa_obs_value =
        reinterpret_cast<intellivue::SaObsValue *>(ava->attribute_val);
      if (psa_obs_value)
      {
        delete [] psa_obs_value->array.value;
        psa_obs_value->array.value = nullptr;
      }
      delete [] ava->attribute_val;
      ava->attribute_val = nullptr;
    }
      break;
    case NOM_ATTR_SA_CMPD_VAL_OBS:
    {
      intellivue::SaObsValueCmp* psa_obs_value_cmp =
        reinterpret_cast<intellivue::SaObsValueCmp *>(ava->attribute_val);
      if (psa_obs_value_cmp)
      {
        if (psa_obs_value_cmp->value)
        {
          for (int ix = 0; ix < psa_obs_value_cmp->count; ix++)
          {
            delete [] psa_obs_value_cmp->value[ix].array.value;
            psa_obs_value_cmp->value[ix].array.value = nullptr;
          }
        }
        delete [] psa_obs_value_cmp->value;
        psa_obs_value_cmp->value = nullptr;
      }
      delete [] ava->attribute_val;
      ava->attribute_val = nullptr;
    }
      break;
    case NOM_ATTR_AL_MON_T_AL_LIST:
    case NOM_ATTR_AL_MON_P_AL_LIST:
    {
      intellivue::DevAlarmList* pdevice_al_list =
        reinterpret_cast<intellivue::DevAlarmList *>(ava->attribute_val);
      if (pdevice_al_list)
      {
        if (pdevice_al_list->value)
        {
          for (int ix = 0; ix < pdevice_al_list->count; ix++)
          {
            delete [] pdevice_al_list->value[ix].alert_info;
            pdevice_al_list->value[ix].alert_info = nullptr;
          }
        }
        delete [] pdevice_al_list->value;
        pdevice_al_list->value = nullptr;
      }
      delete [] ava->attribute_val;
      ava->attribute_val = nullptr;
    }
      break;
    case NOM_ATTR_POLL_RTSA_PRIO_LIST:
    {
      intellivue::TextIdList* ptext_id_list =
        reinterpret_cast<intellivue::TextIdList *>(ava->attribute_val);
      if (ptext_id_list)
      {
        delete [] ptext_id_list->value;
        ptext_id_list->value = nullptr;
      }
      delete [] ava->attribute_val;
      ava->attribute_val = nullptr;
    }
      break;
    default:
      LOG4CPLUS_INFO(root_logger, sfn << "Found unknown AVAType attribute_id "
        << static_cast<int>(ava->attribute_id));

      // Delete allocated attribute_val even if unknown attribute_id.
      delete [] ava->attribute_val;
      ava->attribute_val = nullptr;
      break;
  }

  return DicesRcPhilipsIntellivueMP70::OK;
}

DicesRcPhilipsIntellivueMP70 IntellivueUtils::Convert16BitUnicodeToAscii(
  uint16_t in_16bit,
  uint8_t* out_8bit)
{
  static const char* sfn = "IntellivueUtils::Convert16BitUnicodeToAscii() ";
  if (!out_8bit)
  {
    LOG4CPLUS_ERROR(root_logger, sfn << "Function argument out_8bit is a "
      "null pointer.");
    return DicesRcPhilipsIntellivueMP70::NULL_POINTER_FUNCTION_ARGUMENT_FAILURE;
  }
  *out_8bit = kAsciiUnknown;

  if (in_16bit > kAsciiMax)
  {
    switch (in_16bit)
    {
      case SUBSCRIPT_CAPITAL_E_CHAR:
        *out_8bit = kAsciiSubscriptCapitalE;
        break;
      case SUBSCRIPT_CAPITAL_L_CHAR:
        *out_8bit = kAsciiSubscriptCapitalL;
        break;
      case LITER_PER_CHAR:
        // LITER PER used in 4 char unit "l/min"
        // TODO I don't know what characters they are referring to here. I
        // assume it's the '/' character, but let's correct this if
        // we find out.
        *out_8bit = kAsciiUnknown;
        break;
      case HYDROGEN_CHAR:
        // HYDROGEN - Used in 4 char unit "cmH2O"
        // TODO I don't know what characters they are referring to here. I
        // assume it's a subscript '2' character, but let's correct this if
        // we find out.
        *out_8bit = kAsciiUnknown;
        break;
      case ALARM_STAR_CHAR:
        *out_8bit = kAsciiStar;
        break;
      case CAPITAL_V_WITH_DOT_ABOVE_CHAR:
        *out_8bit = kAsciiVWithADotAbove;
        break;
      case ZERO_WIDTH_NO_BREAK_SPACE_CHAR:
        // The character 0xFEFF is used
        // as FILL character. For each wide asian character,
        // a FILL character is appended for size calculations
        // Using unknown character here because we aren't using an asian
        // language yet, and I think a null character would be risky.
        *out_8bit = kAsciiUnknown;
        break;
      case kUnicodeDelta:
        // Delta character. Delta is not an ascii code, so we're using 'd'
        *out_8bit = kAsciiDelta;
        break;
      case kUnicodeSubscriptTwo:
        // Subscript 2 character
        *out_8bit = kAsciiSubscript2;
        break;
      default:
        *out_8bit = kAsciiUnknown;
        break;
    }
  }
  else
  {
    *out_8bit = static_cast<uint8_t>(in_16bit);
  }
  return DicesRcPhilipsIntellivueMP70::OK;
}

DicesRcPhilipsIntellivueMP70 IntellivueUtils::ConvertIntellivueColorToDicesColor(
  ice::SimpleColor* dices_color,
  const intellivue::SimpleColour intellivue_color)
{
  static const char* sfn = "IntellivueUtils::"
    "ConvertIntellivueColorToDicesColor() ";
  if (!dices_color)
  {
    LOG4CPLUS_ERROR(root_logger, sfn << "Function argument dices_color is a "
      "null pointer.");
    return DicesRcPhilipsIntellivueMP70::NULL_POINTER_FUNCTION_ARGUMENT_FAILURE;
  }

  switch (intellivue_color)
  {
    case COL_BLACK:
      *dices_color = ice::col_black;
      break;
    case COL_PINK:
    case COL_LIGHT_RED:
    case COL_RED:
      *dices_color = ice::col_red;
      break;
    case COL_LIGHT_GREEN:
    case COL_GREEN:
      *dices_color = ice::col_green;
      break;
    case COL_ORANGE:
    case COL_YELLOW:
      *dices_color = ice::col_yellow;
      break;
    case COL_BLUE:
      *dices_color = ice::col_blue;
      break;
    case COL_CYAN:
      *dices_color = ice::col_cyan;
      break;
    case COL_WHITE:
      *dices_color = ice::col_white;
      break;
    case COL_MAGENTA:
      *dices_color = ice::col_magenta;
      break;
    default:
      *dices_color = ice::col_black;
      LOG4CPLUS_INFO(root_logger, sfn << "Unknown intellivue color "
        << intellivue_color << ". Setting col_black by default.");
      break;
  }
  return DicesRcPhilipsIntellivueMP70::OK;
}

DicesRcPhilipsIntellivueMP70 IntellivueUtils::
ConvertIntellivueMetricCategoryToDicesMetricCategory(
  ice::MetricCategory* dices_category,
  const intellivue::MetricCategory intellivue_category)
{
  static const char* sfn = "IntellivueUtils::"
    "ConvertIntellivueMetricCategoryToDicesMetricCategory()";
  if (!dices_category)
  {
    LOG4CPLUS_ERROR(root_logger, sfn << "Function argument dices_dim_category "
      "is a null pointer");
    return DicesRcPhilipsIntellivueMP70::NULL_POINTER_FUNCTION_ARGUMENT_FAILURE;
  }
  *dices_category = ice::MetricCategory::mcat_unspec;

  switch (intellivue_category)
  {
    case MCAT_UNSPEC: *dices_category = ice::MetricCategory::mcat_unspec;
      break;
    case AUTO_MEASUREMENT: *dices_category = ice::MetricCategory::auto_measurement;
      break;
    case MANUAL_MEASUREMENT: *dices_category = ice::MetricCategory::manual_measurement;
      break;
    case AUTO_SETTING: *dices_category = ice::MetricCategory::auto_setting;
      break;
    case MANUAL_SETTING: *dices_category = ice::MetricCategory::manual_setting;
      break;
    case AUTO_CALCULATION: *dices_category = ice::MetricCategory::auto_calculation;
      break;
    case MANUAL_CALCULATION: *dices_category = ice::MetricCategory::manual_calculation;
      break;
    case AUTO_ADJUST_PAT_TEMP:
      LOG4CPLUS_WARN(root_logger, sfn << "Unable to convert from intellivue "
        "AUTO_ADJUST_PAT_TEMP to ice::MetricCategory. Setting default "
        "mcat_unspec");
      break;
    case MANUAL_ADJUST_PAT_TEMP:
      LOG4CPLUS_WARN(root_logger, sfn << "Unable to convert from intellivue "
        "MANUAL_ADJUST_PAT_TEMP to ice::MetricCategory. Setting default "
        "mcat_unspec");
      break;
    case AUTO_ALARM_LIMIT_SETTING:
      LOG4CPLUS_WARN(root_logger, sfn << "Unable to convert from intellivue "
        "AUTO_ALARM_LIMIT_SETTING to ice::MetricCategory. Setting default "
        "mcat_unspec");
      break;
    default:
      LOG4CPLUS_WARN(root_logger, sfn << "Unknown intellivue metric "
        "specification category (" << static_cast<int>(intellivue_category)
        << "). Setting default mcat_unspec");
      break;
  }
  return DicesRcPhilipsIntellivueMP70::OK;
}

DicesRcPhilipsIntellivueMP70 IntellivueUtils::
ConvertIntellivueMetricAccessToDicesMetricAccess(
  ice::MetricAccess* dices_access,
  const intellivue::MetricAccess intellivue_access)
{
  static const char* sfn = "IntellivueUtils::"
    "ConvertIntellivueMetricAccessToDicesMetricAccess() ";
  if (!dices_access)
  {
    LOG4CPLUS_ERROR(root_logger, sfn << "Function argument dices_access is a "
      "null pointer.");
    return DicesRcPhilipsIntellivueMP70::NULL_POINTER_FUNCTION_ARGUMENT_FAILURE;
  }
  *dices_access = 0;

  if (intellivue_access & AVAIL_INTERMITTEND)
  {
    *dices_access |= ice::MetricAccessBits::avail_intermittent;
  }
  if (intellivue_access & UPD_PERIODIC)
  {
    *dices_access |= ice::MetricAccessBits::upd_periodic;
  }
  if (intellivue_access & UPD_EPISODIC)
  {
    *dices_access |= ice::MetricAccessBits::upd_episodic;
  }
  if (intellivue_access & MSMT_NONCONTINUOUS)
  {
    *dices_access |= ice::MetricAccessBits::msmt_noncontinuous;
  }

  return DicesRcPhilipsIntellivueMP70::OK;
}

DicesRcPhilipsIntellivueMP70 IntellivueUtils::
ConvertIntellivueAbsoluteTimeToDicesTimespec(
  ice::Timespec* dices_abs_time,
  const intellivue::AbsoluteTime& intellivue_abs_time)
{
  static const char* sfn = "IntellivueUtils::"
    "ConvertIntellivueAbsoluteTimeToDicesTimespec() ";
  if (!dices_abs_time)
  {
    LOG4CPLUS_ERROR(root_logger, sfn << "Function argument ice_abs_time is a "
      "null pointer.");
    return DicesRcPhilipsIntellivueMP70::NULL_POINTER_FUNCTION_ARGUMENT_FAILURE;
  }

  if (intellivue_abs_time.century == 0xFF
    && intellivue_abs_time.year == 0xFF
    && intellivue_abs_time.month == 0xFF
    && intellivue_abs_time.day == 0xFF
    && intellivue_abs_time.hour == 0xFF
    && intellivue_abs_time.minute == 0xFF
    && intellivue_abs_time.second == 0xFF
    && intellivue_abs_time.sec_fractions == 0xFF)
  {
    LOG4CPLUS_WARN(root_logger, sfn << "Received an invalid AbsoluteTime from "
      "the intellivue. An invalid time is marked with 0xff in all positions.");
    return DicesRcPhilipsIntellivueMP70::FAIL;
  }

  const int kmin_year = 1900;
  std::stringstream ss;
  struct tm abs_time_tm = { 0 };
  char* pend = 0;

  // Concatenate century and year of the intellivue absolute time, and parse
  // year integer from string
  ss << std::hex
    << static_cast<int>(intellivue_abs_time.century)
    << static_cast<int>(intellivue_abs_time.year);
  errno = 0;
  abs_time_tm.tm_year = strtol(ss.str().c_str(), &pend, 10) - kmin_year;
  if (ss.str().c_str() == pend || errno != 0)
  {
    LOG4CPLUS_ERROR(root_logger, sfn << "Failed to parse year string: "
      << ss.str() << ". " << strerror(errno));
    return DicesRcPhilipsIntellivueMP70::FAIL;
  }

  ss.str("");
  ss << std::hex << static_cast<int>(intellivue_abs_time.month);
  pend = 0;
  errno = 0;
  // NOTE: subtracting one because it's the month since January (0 - 11)
  abs_time_tm.tm_mon = strtol(ss.str().c_str(), &pend, 10) - 1;
  if (ss.str().c_str() == pend || errno != 0)
  {
    LOG4CPLUS_ERROR(root_logger, sfn << "Failed to parse month string: "
      << ss.str() << ". " << strerror(errno));
    return DicesRcPhilipsIntellivueMP70::FAIL;
  }

  ss.str("");
  ss << std::hex << static_cast<int>(intellivue_abs_time.day);
  pend = 0;
  errno = 0;
  abs_time_tm.tm_mday = strtol(ss.str().c_str(), &pend, 10);
  if (ss.str().c_str() == pend || errno != 0)
  {
    LOG4CPLUS_ERROR(root_logger, sfn << "Failed to parse day string: "
      << ss.str() << ". " << strerror(errno));
    return DicesRcPhilipsIntellivueMP70::FAIL;
  }

  ss.str("");
  ss << std::hex << static_cast<int>(intellivue_abs_time.hour);
  pend = 0;
  errno = 0;
  abs_time_tm.tm_hour = strtol(ss.str().c_str(), &pend, 10);
  if (ss.str().c_str() == pend || errno != 0)
  {
    LOG4CPLUS_ERROR(root_logger, sfn << "Failed to parse hour string: "
      << ss.str() << ". " << strerror(errno));
    return DicesRcPhilipsIntellivueMP70::FAIL;
  }

  ss.str("");
  ss << std::hex << static_cast<int>(intellivue_abs_time.minute);
  pend = 0;
  errno = 0;
  abs_time_tm.tm_min = strtol(ss.str().c_str(), &pend, 10);
  if (ss.str().c_str() == pend || errno != 0)
  {
    LOG4CPLUS_ERROR(root_logger, sfn << "Failed to parse minute string: "
      << ss.str() << ". " << strerror(errno));
    return DicesRcPhilipsIntellivueMP70::FAIL;
  }

  ss.str("");
  ss << std::hex << static_cast<int>(intellivue_abs_time.second);
  pend = 0;
  errno = 0;
  abs_time_tm.tm_sec = strtol(ss.str().c_str(), &pend, 10);
  if (ss.str().c_str() == pend || errno != 0)
  {
    LOG4CPLUS_ERROR(root_logger, sfn << "Failed to parse second string: "
      << ss.str() << ". " << strerror(errno));
    return DicesRcPhilipsIntellivueMP70::FAIL;
  }

  // NOTE: abs.sec_fractions is not used by Intellivue.

  dices_abs_time->seconds = static_cast<DDS::Long>(mktime(&abs_time_tm));
  dices_abs_time->nanoseconds = 0;

  return DicesRcPhilipsIntellivueMP70::OK;
}

DicesRcPhilipsIntellivueMP70 IntellivueUtils::
ConvertIntellivueRelativeTimeToDicesDuration(
  ice::Duration* dices_rel_time,
  const intellivue::RelativeTime intellivue_rel_time)
{
  static const char* sfn = "IntellivueUtils::"
    "ConvertIntellivueRelativeTimeToDicesDuration() ";
  if (!dices_rel_time)
  {
    LOG4CPLUS_WARN(root_logger, sfn << " Function argument ice_rel_time is "
      "a null pointer.");
    return DicesRcPhilipsIntellivueMP70::NULL_POINTER_FUNCTION_ARGUMENT_FAILURE;
  }

  // Convert 1/8 milliseconds to seconds
  double time_secs = static_cast<double>(intellivue_rel_time)
    / static_cast<double>(8 * 1000.0);

  // Lose precision and drop all sub-seconds
  int seconds = static_cast<int>(time_secs);

  // Get the remaining sub-seconds and convert them to nanoseconds
  double nanoseconds = (time_secs - seconds) * pow(10.0, 9.0);

  dices_rel_time->seconds = seconds;
  dices_rel_time->nanoseconds = static_cast<int>(nanoseconds);
  return DicesRcPhilipsIntellivueMP70::OK;
}

DicesRcPhilipsIntellivueMP70 IntellivueUtils::
ConvertIntellivueNomPartitionToDicesNomPartition(
  ice::NomPartition* dices_nom_partition,
  const intellivue::NomPartition intellivue_nom_partition)
{
  static const char* sfn = "IntellivueUtils::"
    "ConvertIntellivueNomPartitionToDicesNomPartition() ";
  if (!dices_nom_partition)
  {
    LOG4CPLUS_WARN(root_logger, sfn << " Function argument "
      "dices_nom_partition is a null pointer.");
    return DicesRcPhilipsIntellivueMP70::NULL_POINTER_FUNCTION_ARGUMENT_FAILURE;
  }
  *dices_nom_partition = ice::NomPartition::nom_part_unspec;

  switch (intellivue_nom_partition)
  {
    case NOM_PART_OBJ:
      *dices_nom_partition = ice::NomPartition::nom_part_obj;
      break;
    case NOM_PART_SCADA:
      *dices_nom_partition = ice::NomPartition::nom_part_metric;
      break;
    case NOM_PART_EVT:
      *dices_nom_partition = ice::NomPartition::nom_part_alert;
      break;
    case NOM_PART_DIM:
      *dices_nom_partition = ice::NomPartition::nom_part_dim;
      break;
    case NOM_PART_PGRP:
      *dices_nom_partition = ice::NomPartition::nom_part_pgrp;
      break;
    case NOM_PART_INFRASTRUCT:
      *dices_nom_partition = ice::NomPartition::nom_part_infrastruct;
      break;
    default:
      LOG4CPLUS_WARN(root_logger, sfn << "Unknown intellivue NomPartition "
        "(" << static_cast<int>(intellivue_nom_partition)
        << ").");
      break;
  }
  return DicesRcPhilipsIntellivueMP70::OK;
}

DicesRcPhilipsIntellivueMP70 IntellivueUtils::ConvertIntellivueMeasurementStatusToDicesMeasurementStatus(
  ice::MeasurementStatus* dices_meas_status,
  const intellivue::MeasurementState intellivue_meas_status)
{
  static const char* sfn = "IntellivueUtils::"
    "ConvertIntellivueMeasurementStatusToDicesMeasurementStatus()";
  if (!dices_meas_status)
  {
    LOG4CPLUS_WARN(root_logger, sfn << " Function argument "
      "dices_meas_status is a null pointer.");
    return DicesRcPhilipsIntellivueMP70::NULL_POINTER_FUNCTION_ARGUMENT_FAILURE;
  }
  ice::MeasurementStatus measurement_status = 0;

  if (intellivue_meas_status & INVALID)
    measurement_status |= ice::invalid;
  if (intellivue_meas_status & QUESTIONABLE)
    measurement_status |= ice::questionable;
  if (intellivue_meas_status & UNAVAILABLE)
    measurement_status |= ice::not_available;
  if (intellivue_meas_status & CALIBRATION_ONGOING)
    measurement_status |= ice::calibration_ongoing;
  if (intellivue_meas_status & TEST_DATA)
    measurement_status |= ice::test_data;
  if (intellivue_meas_status & DEMO_DATA)
    measurement_status |= ice::demo_data;
  if (intellivue_meas_status & VALIDATED_DATA)
    measurement_status |= ice::validated_data;
  if (intellivue_meas_status & EARLY_INDICATION)
    measurement_status |= ice::early_indication;
  if (intellivue_meas_status & MSMT_ONGOING)
    measurement_status |= ice::msmt_ongoing;
  if (intellivue_meas_status & MSMT_STATE_IN_ALARM)
    measurement_status |= ice::msmt_state_in_alarm;
  if (intellivue_meas_status & MSMT_STATE_AL_INHIBITED)
    measurement_status |= ice::msmt_state_al_inhibited;

  *dices_meas_status = measurement_status;
  return DicesRcPhilipsIntellivueMP70::OK;
}

DicesRcPhilipsIntellivueMP70 IntellivueUtils::
ConvertIntellivueMDSStatusToDicesMDSStatus(
  ice::MDSStatus* dices_mds_status,
  const intellivue::MDSStatus intellivue_mds_status)
{
  static const char* sfn = "IntellivueUtils::"
    "ConvertIntellivueMDSStatusToDicesMDSStatus() ";
  if (!dices_mds_status)
  {
    LOG4CPLUS_WARN(root_logger, sfn << " Function argument "
      "dices_mds_status is a null pointer.");
    return DicesRcPhilipsIntellivueMP70::NULL_POINTER_FUNCTION_ARGUMENT_FAILURE;
  }

  ice::MDSStatus mds_status = ice::MDSStatus::disconnected;
  switch (intellivue_mds_status)
  {
    case DISCONNECTED:
      mds_status = ice::MDSStatus::disconnected;
      break;
    case UNASSOCIATED:
      mds_status = ice::MDSStatus::unassociated;
      break;
    case OPERATING:
      mds_status = ice::MDSStatus::operating;
      break;
    default:
      LOG4CPLUS_WARN(root_logger, sfn << "Unknown intellivue MDSStatus "
        "(" << static_cast<int>(intellivue_mds_status)
        << "). Setting default to disconnected.");
      break;
  }
  *dices_mds_status = mds_status;
  return DicesRcPhilipsIntellivueMP70::OK;
}

DicesRcPhilipsIntellivueMP70 IntellivueUtils::
ConvertIntellivueProdSpecTypeToDicesProdSpecType(
  ice::ProdSpecType* dices_prod_spec_type,
  const uint16_t intellivue_prod_spec_type)
{
  static const char* sfn = "IntellivueUtils::"
    "ConvertIntellivueProdSpecTypeToDicesProdSpecType() ";
  if (!dices_prod_spec_type)
  {
    LOG4CPLUS_WARN(root_logger, sfn << " Function argument "
      "dices_prod_spec_type is a null pointer.");
    return DicesRcPhilipsIntellivueMP70::NULL_POINTER_FUNCTION_ARGUMENT_FAILURE;
  }

  ice::ProdSpecType prod_spec_type = ice::ProdSpecType::unspecified;
  switch (intellivue_prod_spec_type)
  {
    case UNSPECIFIED:
      prod_spec_type = ice::unspecified;
      break;
    case SERIAL_NUMBER:
      prod_spec_type = ice::serial_number;
      break;
    case PART_NUMBER:
      prod_spec_type = ice::part_number;
      break;
    case HW_REVISION:
      prod_spec_type = ice::hw_revision;
      break;
    case SW_REVISION:
      prod_spec_type = ice::sw_revision;
      break;
    case FW_REVISION:
      prod_spec_type = ice::fw_revision;
      break;
    case PROTOCOL_REVISION:
      prod_spec_type = ice::protocol_revision;
      break;
    default:
      LOG4CPLUS_WARN(root_logger, sfn << "Unknown intellivue production "
        "spec_type (" << static_cast<int>(intellivue_prod_spec_type)
        << "). Setting default to unspecified.");
      break;
  }
  *dices_prod_spec_type = prod_spec_type;
  return DicesRcPhilipsIntellivueMP70::OK;
}

DicesRcPhilipsIntellivueMP70 IntellivueUtils::
ConvertIntellivueLineFrequencyToDicesLineFrequency(
  ice::LineFrequency* dices_line_frequency,
  const intellivue::LineFrequency intellivue_line_frequency)
{
  static const char* sfn = "IntellivueUtils::"
    "ConvertIntellivueLineFrequencyToDicesLineFrequency() ";
  if (!dices_line_frequency)
  {
    LOG4CPLUS_WARN(root_logger, sfn << " Function argument "
      "dices_line_frequency is a null pointer.");
    return DicesRcPhilipsIntellivueMP70::NULL_POINTER_FUNCTION_ARGUMENT_FAILURE;
  }

  ice::LineFrequency line_frequency = ice::LineFrequency::line_f_unspec;
  switch (intellivue_line_frequency)
  {
    case LINE_F_UNSPEC:
      line_frequency = ice::line_f_unspec;
      break;
    case LINE_F_50HZ:
      line_frequency = ice::line_f_50hz;
      break;
    case LINE_F_60HZ:
      line_frequency = ice::line_f_60hz;
      break;
    default:
      LOG4CPLUS_WARN(root_logger, sfn << "Unknown intellivue line frequency "
        "(" << static_cast<int>(intellivue_line_frequency)
        << "). Setting default to unspecified.");
      break;
  }
  *dices_line_frequency = line_frequency;
  return DicesRcPhilipsIntellivueMP70::OK;
}

DicesRcPhilipsIntellivueMP70 IntellivueUtils::ConvertIntellivueFloatTypeToDicesFloatType(
  ice::FLOATType* dices_float_type,
  const intellivue::FLOATType intellivue_float_type)
{
  static const char* sfn = "IntellivueUtils::"
    "ConvertIntellivueFloatTypeToDicesFloatType() ";
  if (!dices_float_type)
  {
    LOG4CPLUS_WARN(root_logger, sfn << " Function argument "
      "dices_float_type is a null pointer.");
    return DicesRcPhilipsIntellivueMP70::NULL_POINTER_FUNCTION_ARGUMENT_FAILURE;
  }

  uint8_t byte_array[4] = { 0 };
  const uint8_t* pfloat_type = reinterpret_cast<const uint8_t*>(&intellivue_float_type);
  memcpy(
    &byte_array[0],
    pfloat_type,
    sizeof(intellivue_float_type));

  int8_t exponent = static_cast<int8_t>(byte_array[3]);
  int mantissa = (byte_array[2] << 16)
    | (byte_array[1] << 8)
    | (byte_array[0]);

  if (mantissa & 0x00800000)
  {
    // Mantissa should be negative, so let's make it negative
    // Example: 00FFFFFF | FF000000 = FFFFFFFF (-1)
    mantissa |= 0xFF000000;
  }

  const double base = 10.0;
  *dices_float_type = static_cast<ice::FLOATType>(
    mantissa * pow(base, static_cast<double>(exponent)));

  return DicesRcPhilipsIntellivueMP70::OK;
}

DicesRcPhilipsIntellivueMP70 IntellivueUtils::ConvertIntellivueFloatTypeToDicesFloatType(
  ice::FLOATType* dices_float_type,
  const intellivue::FLOATType intellivue_float_type,
    bool* is_invalid)
{
  static const char* sfn = "IntellivueUtils::"
    "ConvertIntellivueFloatTypeToDicesFloatType() ";
  if (!dices_float_type)
  {
    LOG4CPLUS_WARN(root_logger, sfn << " Function argument "
      "dices_float_type is a null pointer.");
    return DicesRcPhilipsIntellivueMP70::NULL_POINTER_FUNCTION_ARGUMENT_FAILURE;
  }

  if (!is_invalid)
  {
    LOG4CPLUS_WARN(root_logger, sfn << " Function argument "
      "is_invalid is a null pointer.");
    return DicesRcPhilipsIntellivueMP70::NULL_POINTER_FUNCTION_ARGUMENT_FAILURE;
  }
  *is_invalid = false;

  uint8_t byte_array[4] = { 0 };
  const uint8_t* pfloat_type = reinterpret_cast<const uint8_t*>(&intellivue_float_type);
  memcpy(
    &byte_array[0],
    pfloat_type,
    sizeof(intellivue_float_type));

  int8_t exponent = static_cast<int8_t>(byte_array[3]);
  int mantissa = (byte_array[2] << 16)
    | (byte_array[1] << 8)
    | (byte_array[0]);

  if (mantissa == kNaN
      || mantissa == kNRes
      || mantissa == kPlusInfinity
      || mantissa == kMinusInfinity)
  {
    *is_invalid = true;
  }

  if (mantissa & 0x00800000)
  {
    // Mantissa should be negative, so let's make it negative
    // Example: 00FFFFFF | FF000000 = FFFFFFFF (-1)
    mantissa |= 0xFF000000;
  }

  const double base = 10.0;
  *dices_float_type = static_cast<ice::FLOATType>(
    mantissa * pow(base, static_cast<double>(exponent)));

  return DicesRcPhilipsIntellivueMP70::OK;
}

DicesRcPhilipsIntellivueMP70 IntellivueUtils::
ConvertIntellivuePatDemoStateToDicesPatAdmitState(
  ice::PatAdmitState* dices_pat_admit_state,
  const intellivue::PatDemoState intellivue_pat_demo_state)
{
  static const char* sfn = "IntellivueUtils::"
    "ConvertIntellivuePatDemoStateToDicesPatAdmitState() ";
  if (!dices_pat_admit_state)
  {
    LOG4CPLUS_WARN(root_logger, sfn << " Function argument "
      "dices_pat_admit_state is a null pointer.");
    return DicesRcPhilipsIntellivueMP70::NULL_POINTER_FUNCTION_ARGUMENT_FAILURE;
  }

  ice::PatAdmitState pat_admit_state = ice::empty;
  switch (intellivue_pat_demo_state)
  {
    case EMPTY:
      pat_admit_state = ice::empty;
      break;
    case PRE_ADMITTED:
      pat_admit_state = ice::pre_admitted;
      break;
    case ADMITTED:
      pat_admit_state = ice::admitted;
      break;
    case DISCHARGED:
      pat_admit_state = ice::discharged;
      break;
    default:
      LOG4CPLUS_WARN(root_logger, sfn << "Unknown intellivue pat demo state "
        "(" << static_cast<int>(intellivue_pat_demo_state)
        << "). Setting default to empty.");
      break;
  }
  *dices_pat_admit_state = pat_admit_state;
  return DicesRcPhilipsIntellivueMP70::OK;
}

DicesRcPhilipsIntellivueMP70 IntellivueUtils::
ConvertIntellivuePatientTypeToDicesPatientType(
  ice::PatientType* dices_pat_type,
  const intellivue::PatientType intellivue_pat_type)
{
  static const char* sfn = "IntellivueUtils::"
    "ConvertIntellivuePatientTypeToDicesPatientType() ";
  if (!dices_pat_type)
  {
    LOG4CPLUS_WARN(root_logger, sfn << " Function argument "
      "dices_pat_type is a null pointer.");
    return DicesRcPhilipsIntellivueMP70::NULL_POINTER_FUNCTION_ARGUMENT_FAILURE;
  }

  ice::PatientType pat_type = ice::pt_unspecified;
  switch (intellivue_pat_type)
  {
    case PAT_TYPE_UNSPECIFIED:
      pat_type = ice::pt_unspecified;
      break;
    case ADULT:
      pat_type = ice::adult;
      break;
    case PEDIATRIC:
      pat_type = ice::pediatric;
      break;
    case NEONATAL:
      pat_type = ice::neonatal;
      break;
    default:
      LOG4CPLUS_WARN(root_logger, sfn << "Unknown intellivue patient type "
        "(" << static_cast<int>(intellivue_pat_type)
        << "). Setting default to unspecified.");
      break;
  }
  *dices_pat_type = pat_type;
  return DicesRcPhilipsIntellivueMP70::OK;
}

DicesRcPhilipsIntellivueMP70 IntellivueUtils::
ConvertIntellivuePatientSexToDicesPatientSex(
  ice::PatientSex* dices_pat_sex,
  const intellivue::PatientSex intellivue_pat_sex)
{
  static const char* sfn = "IntellivueUtils::"
    "ConvertIntellivuePatientSexToDicesPatientSex() ";
  if (!dices_pat_sex)
  {
    LOG4CPLUS_WARN(root_logger, sfn << " Function argument "
      "dices_pat_sex is a null pointer.");
    return DicesRcPhilipsIntellivueMP70::NULL_POINTER_FUNCTION_ARGUMENT_FAILURE;
  }

  ice::PatientSex pat_sex = ice::sex_unknown;
  switch (intellivue_pat_sex)
  {
    case SEX_UNKNOWN:
      pat_sex = ice::sex_unknown;
      break;
    case MALE:
      pat_sex = ice::sex_male;
      break;
    case FEMALE:
      pat_sex = ice::sex_female;
      break;
    case SEX_UNSPECIFIED:
      pat_sex = ice::sex_unspecified;
      break;
    default:
      LOG4CPLUS_WARN(root_logger, sfn << "Unknown intellivue pat sex "
        "(" << static_cast<int>(intellivue_pat_sex)
        << "). Setting default to sex unknown.");
      break;
  }
  *dices_pat_sex = pat_sex;
  return DicesRcPhilipsIntellivueMP70::OK;
}

DicesRcPhilipsIntellivueMP70 IntellivueUtils::
ConvertIntellivueTextIdToVMOLabelString(
    std::string* dices_vmo_label_string,
    const intellivue::TextId intellivue_textid)
{
  static const char* sfn = "IntellivueUtils::"
                           "ConvertIntellivueTextIdToVMOLabelString() ";
  if (!dices_vmo_label_string)
  {
    LOG4CPLUS_WARN(root_logger, sfn << "Function argument "
      "dices_vmo_label_string is a null pointer.");
    return DicesRcPhilipsIntellivueMP70::NULL_POINTER_FUNCTION_ARGUMENT_FAILURE;
  }
  *dices_vmo_label_string = "";

  for(int ix = 0; ix < kTextIdToStringVector.size(); ix++)
  {
    try
    {
      kTextIdToStringVector.at(ix);
    }
    catch(std::exception& ex)
    {
      LOG4CPLUS_ERROR(root_logger, sfn << "Failed to access element at "
        "position " << ix << " of kTextIdToStringVector. " << ex.what());
      return DicesRcPhilipsIntellivueMP70::FAIL;
    }

    if (kTextIdToStringVector.at(ix).first == intellivue_textid)
    {
      *dices_vmo_label_string = kTextIdToStringVector.at(ix).second;
      return DicesRcPhilipsIntellivueMP70::OK;
    }
  }

  LOG4CPLUS_WARN(root_logger, sfn << "Unknown label textId ("
    << static_cast<int>(intellivue_textid) << ")");

  return DicesRcPhilipsIntellivueMP70::OK;
}

DicesRcPhilipsIntellivueMP70 IntellivueUtils::
  ConvertIntellivueTextIdStringToTextId(
    intellivue::TextId* intellivue_textid,
    const std::string& dices_vmo_label_string)
{
  static const char* sfn = "IntellivueUtils::"
                           "ConvertIntellivueTextIdStringToTextId() ";
  if (!intellivue_textid)
  {
    LOG4CPLUS_WARN(root_logger, sfn << "Function argument "
      "intellivue_textid is a null pointer.");
    return DicesRcPhilipsIntellivueMP70::NULL_POINTER_FUNCTION_ARGUMENT_FAILURE;
  }
  *intellivue_textid = 0;

  if (dices_vmo_label_string.empty())
  {
    LOG4CPLUS_INFO(root_logger, sfn << "dices_vmo_label_string is empty");
    return DicesRcPhilipsIntellivueMP70::OK;
  }

  for(int ix = 0; ix < kTextIdToStringVector.size(); ix++)
  {
    try
    {
      kTextIdToStringVector.at(ix);
    }
    catch(std::exception& ex)
    {
      LOG4CPLUS_ERROR(root_logger, sfn << "Failed to access element at "
        "position " << ix << " of kTextIdToStringVector. " << ex.what());
      return DicesRcPhilipsIntellivueMP70::FAIL;
    }

    if (strcmp(
      dices_vmo_label_string.c_str(),
      kTextIdToStringVector.at(ix).second.c_str()) == 0)
    {
      *intellivue_textid = kTextIdToStringVector.at(ix).first;
      return DicesRcPhilipsIntellivueMP70::OK;
    }
  }

  LOG4CPLUS_WARN(root_logger, sfn << "Unknown label textId string ("
    << dices_vmo_label_string << ")");

  return DicesRcPhilipsIntellivueMP70::OK;
}

DicesRcPhilipsIntellivueMP70 IntellivueUtils::
TranslateIntellivePhysioIdToDicesMetricId(
    const std::string& dices_vmo_label_string,
    const intellivue::OIDType intellivue_physio_id,
    intellivue::OIDType* dices_metric_id)
{
  static const char* sfn = "IntellivueUtils::"
                           "TranslateIntelliveLabelAndPhysioIdToDicesMetricId() ";
  if (!dices_metric_id)
  {
    LOG4CPLUS_WARN(root_logger, sfn << " Function argument "
      "dices_metric_id is a null pointer.");
    return DicesRcPhilipsIntellivueMP70::NULL_POINTER_FUNCTION_ARGUMENT_FAILURE;
  }
  *dices_metric_id = intellivue_physio_id;

  intellivue::TextId text_id = 0;
  ConvertIntellivueTextIdStringToTextId(
    &text_id,
    dices_vmo_label_string);
  
  switch(intellivue_physio_id)
  {
    case NOM_ECG_CARD_BEAT_RATE:
      switch(text_id)
      {
        case NLS_NOM_ECG_CARD_BEAT_RATE:
          *dices_metric_id = MDC_ECG_CARD_BEAT_RATE;
          break;
        case NLS_NOM_CARD_BEAT_RATE_EXT:
          *dices_metric_id = MDC_ECG_CARD_BEAT_RATE_EXT;
          break;
      }
      break;
    case NOM_PULS_RATE:
      switch(text_id)
      {
        case NLS_NOM_PULS_RATE:
          *dices_metric_id = MDC_PULS_RATE;
          break;
        case NLS_PRESS_NAMES_PULSE_FROM_ABP:
          *dices_metric_id = MDC_BLD_PULS_RATE_INV_ABP;
          break;
        case NLS_PRESS_NAMES_PULSE_FROM_ART:
          *dices_metric_id = MDC_BLD_PULS_RATE_INV_ART;
          break;
        case NLS_PRESS_NAMES_PULSE_FROM_AO:
          *dices_metric_id = MDC_BLD_PULS_RATE_INV_AO;
          break;
        case NLS_PRESS_NAMES_PULSE_FROM_PAP:
          *dices_metric_id = MDC_BLD_PULS_RATE_INV_PAP;
          break;
        case NLS_PRESS_NAMES_PULSE_FROM_CVP:
          *dices_metric_id = MDC_BLD_PULS_RATE_INV_CVP;
          break;
        case NLS_PRESS_NAMES_PULSE_FROM_RAP:
          *dices_metric_id = MDC_BLD_PULS_RATE_INV_RAP;
          break;
        case NLS_PRESS_NAMES_PULSE_FROM_LAP:
          *dices_metric_id = MDC_BLD_PULS_RATE_INV_LAP;
          break;
        case NLS_PRESS_NAMES_PULSE_FROM_ICP:
          *dices_metric_id = MDC_BLD_PULS_RATE_INV_ICP;
          break;
        case NLS_PRESS_NAMES_PULSE_FROM_UAP:
          *dices_metric_id = MDC_BLD_PULS_RATE_INV_UAP;
          break;
        case NLS_PRESS_NAMES_PULSE_FROM_UVP:
          *dices_metric_id = MDC_BLD_PULS_RATE_INV_UVP;
          break;
        case NLS_PRESS_NAMES_PULSE_FROM_FAP:
          *dices_metric_id = MDC_BLD_PULS_RATE_INV_FAP;
          break;
        case NLS_PRESS_NAMES_PULSE_FROM_BAP:
          *dices_metric_id = MDC_BLD_PULS_RATE_INV_BAP;
          break;
        case NLS_PRESS_NAMES_PULSE_FROM_IC1:
          *dices_metric_id = MDC_BLD_PULS_RATE_INV_IC1;
          break;
        case NLS_PRESS_NAMES_PULSE_FROM_IC2:
          *dices_metric_id = MDC_BLD_PULS_RATE_INV_IC2;
          break;
        case NLS_PRESS_NAMES_PULSE_FROM_P:
          *dices_metric_id = MDC_BLD_PULS_RATE_INV_GEN;
          break;
        case NLS_PRESS_NAMES_PULSE_FROM_P1:
          *dices_metric_id = MDC_BLD_PULS_RATE_P1;
          break;
        case NLS_PRESS_NAMES_PULSE_FROM_P2:
          *dices_metric_id = MDC_BLD_PULS_RATE_P2;
          break;
        case NLS_PRESS_NAMES_PULSE_FROM_P3:
          *dices_metric_id = MDC_BLD_PULS_RATE_P3;
          break;
        case NLS_PRESS_NAMES_PULSE_FROM_P4:
          *dices_metric_id = MDC_BLD_PULS_RATE_P4;
          break;
      }
      break;
    case NOM_PLETH_PULS_RATE:
    {
      switch (text_id)
      {
        case NLS_NOM_PULS_OXIM_PULS_RATE:
          *dices_metric_id = MDC_PLETH_PULS_RATE;
          break;
        case NLS_SPO2_NAMES_PULS_OXIM_PULS_RATE_PRE_DUCTAL:
          *dices_metric_id = MDC_PLETH_PULS_RATE;
          break;
        case NLS_SPO2_NAMES_PULS_OXIM_PULS_RATE_POST_DUCTAL:
          *dices_metric_id = MDC_PLETH_PULS_RATE;
          break;
        case NLS_SPO2_NAMES_PULS_OXIM_PULS_RATE_RIGHT:
          *dices_metric_id = MDC_PLETH_PULS_RATE;
          break;
        case NLS_SPO2_NAMES_PULS_OXIM_PULS_RATE_LEFT:
          *dices_metric_id = MDC_PLETH_PULS_RATE;
          break;
      }
    }
      break;
    case NOM_PRESS_BLD:
    {
      switch (text_id)
      {
        case NLS_NOM_PRESS_BLD:
          *dices_metric_id = MDC_PRESS_BLD;
          break;
        case NLS_NOM_PRESS_INTRA_UTERAL:
          *dices_metric_id = MDC_PRESS_BLD_INTRA_UTERINE;
          break;
      }
    }
      break;
    case NOM_SAT_O2_ART:
    {
      switch (text_id)
      {
        case NLS_NOM_SAT_O2_ART:
          *dices_metric_id = MDC_SAT_O2_ART;
          break;
        case NLS_NOM_SAT_O2_LEFT:
          *dices_metric_id = MDC_SAT_O2_ART;
          break;
        case NLS_NOM_SAT_O2_RIGHT:
          *dices_metric_id = MDC_SAT_O2_ART;
          break;
        case NLS_NOM_SAT_O2_CALC:
          *dices_metric_id = MDC_SAT_O2_ART;
          break;
      }
    }
      break;
    case NOM_SAT_O2_VEN:
    {
      switch (text_id)
      {
        case NLS_NOM_SAT_O2_VEN:
          *dices_metric_id = MDC_SAT_O2_VEN;
          break;
        case NLS_NOM_SAT_O2_VEN_CALC:
          *dices_metric_id = MDC_SAT_O2_VEN;
          break;
      }
    }
      break;
    case NOM_TEMP: // NOTE: NOM_SETT_TEMP same value as NOM_TEMP
    {
      switch (text_id)
      {
        case NLS_NOM_TEMP:
          *dices_metric_id = MDC_TEMP;
          break;
        case NLS_NOM_TEMP_BODY:
          *dices_metric_id = MDC_TEMP;
          break;
        case NLS_NOM_SETT_TEMP:
          *dices_metric_id = MDC_SETT_TEMP;
          break;
      }
    }
      break;
    case NOM_EEG_FREQ_PWR_SPEC_CRTX_DOM_MEAN:
    {
      switch (text_id)
      {
        case NLS_NOM_EEG_FREQ_PWR_SPEC_CRTX_DOM_MEAN:
          *dices_metric_id = MDC_EEG_FREQ_PWR_SPEC_CRTX_DOM_MEAN;
          break;
        case NLS_EEG_NAMES_CHAN_FREQ1:
          *dices_metric_id = MDC_EEG_FREQ_PWR_SPEC_CRTX_DOM_MEAN_CH_1;
          break;
        case NLS_EEG_NAMES_CHAN_FREQ2:
          *dices_metric_id = MDC_EEG_FREQ_PWR_SPEC_CRTX_DOM_MEAN_CH_2;
          break;
        case NLS_NOM_EEG_FREQ_PWR_SPEC_CRTX_DOM_MEAN_LEFT:
          *dices_metric_id = MDC_EEG_FREQ_PWR_SPEC_CRTX_DOM_MEAN_LEFT;
          break;
        case NLS_NOM_EEG_FREQ_PWR_SPEC_CRTX_DOM_MEAN_RIGHT:
          *dices_metric_id = MDC_EEG_FREQ_PWR_SPEC_CRTX_DOM_MEAN_RIGHT;
          break;
      }
    }
      break;
    case NOM_EEG_FREQ_PWR_SPEC_CRTX_PEAK:
    {
      switch (text_id)
      {
        case NLS_NOM_EEG_FREQ_PWR_SPEC_CRTX_PEAK:
          *dices_metric_id = MDC_EEG_FREQ_PWR_SPEC_CRTX_DOM_MEAN;
          break;
        case NLS_EEG_NAMES_CHAN_FREQ1:
          *dices_metric_id = MDC_EEG_FREQ_PWR_SPEC_CRTX_DOM_MEAN_CH_1;
          break;
        case NLS_EEG_NAMES_CHAN_FREQ2:
          *dices_metric_id = MDC_EEG_FREQ_PWR_SPEC_CRTX_DOM_MEAN_CH_2;
          break;
        case NLS_NOM_EEG_FREQ_PWR_SPEC_CRTX_DOM_MEAN_LEFT:
          *dices_metric_id = MDC_EEG_FREQ_PWR_SPEC_CRTX_DOM_MEAN_LEFT;
          break;
        case NLS_NOM_EEG_FREQ_PWR_SPEC_CRTX_DOM_MEAN_RIGHT:
          *dices_metric_id = MDC_EEG_FREQ_PWR_SPEC_CRTX_DOM_MEAN_RIGHT;
          break;
      }
    }
      break;
    case NOM_EEG_FREQ_PWR_SPEC_CRTX_SPECTRAL_EDGE:
    {
      switch (text_id)
      {
        case NLS_NOM_EEG_FREQ_PWR_SPEC_CRTX_SPECTRAL_EDGE:
          *dices_metric_id = MDC_EEG_FREQ_PWR_SPEC_CRTX_SPECTRAL_EDGE;
          break;
        case NLS_EEG_NAMES_CHAN_FREQ1:
          *dices_metric_id = MDC_EEG_FREQ_PWR_SPEC_CRTX_SPECTRAL_EDGE_CH_1;
          break;
        case NLS_EEG_NAMES_CHAN_FREQ2:
          *dices_metric_id = MDC_EEG_FREQ_PWR_SPEC_CRTX_SPECTRAL_EDGE_CH_2;
          break;
        case NLS_NOM_EEG_FREQ_PWR_SPEC_CRTX_SPECTRAL_EDGE_LEFT:
          *dices_metric_id = MDC_EEG_FREQ_PWR_SPEC_CRTX_SPECTRAL_EDGE_LEFT;
          break;
        case NLS_NOM_EEG_FREQ_PWR_SPEC_CRTX_SPECTRAL_EDGE_RIGHT:
          *dices_metric_id = MDC_EEG_FREQ_PWR_SPEC_CRTX_SPECTRAL_EDGE_RIGHT;
          break;
      }
    }
      break;
    case NOM_EEG_PWR_SPEC_TOT:
    {
      switch (text_id)
      {
        case NLS_NOM_EEG_PWR_SPEC_TOT:
          *dices_metric_id = MDC_EEG_PWR_SPEC_TOT;
          break;
        case NLS_EEG_NAMES_CHAN_TP1:
          *dices_metric_id = MDC_EEG_PWR_SPEC_TOT_CH_1;
          break;
        case NLS_EEG_NAMES_CHAN_TP2:
          *dices_metric_id = MDC_EEG_PWR_SPEC_TOT_CH_2;
          break;
        case NLS_NOM_EEG_PWR_SPEC_TOT_LEFT:
          *dices_metric_id = MDC_EEG_PWR_SPEC_TOT_LEFT;
          break;
        case NLS_NOM_EEG_PWR_SPEC_TOT_RIGHT:
          *dices_metric_id = MDC_EEG_PWR_SPEC_TOT_RIGHT;
          break;
      }
    }
      break;
    case NOM_EEG_PWR_SPEC_ALPHA_REL:
    {
      switch (text_id)
      {
        case NLS_EEG_NAMES_CHAN_PCNT1:
          *dices_metric_id = MDC_EEG_PWR_SPEC_ALPHA_REL_CH_1;
          break;
        case NLS_EEG_NAMES_CHAN_PCNT2:
          *dices_metric_id = MDC_EEG_PWR_SPEC_ALPHA_REL_CH_2;
          break;
        case NLS_NOM_EEG_PWR_SPEC_ALPHA_REL_LEFT:
          *dices_metric_id = MDC_EEG_PWR_SPEC_ALPHA_REL_LEFT;
          break;
        case NLS_NOM_EEG_PWR_SPEC_ALPHA_REL_RIGHT:
          *dices_metric_id = MDC_EEG_PWR_SPEC_ALPHA_REL_RIGHT;
          break;
      }
    }
      break;
    case NOM_EEG_PWR_SPEC_BETA_REL:
    {
      switch (text_id)
      {
        case NLS_EEG_NAMES_CHAN_PCNT1:
          *dices_metric_id = MDC_EEG_PWR_SPEC_BETA_REL_CH_1;
          break;
        case NLS_EEG_NAMES_CHAN_PCNT2:
          *dices_metric_id = MDC_EEG_PWR_SPEC_BETA_REL_CH_2;
          break;
        case NLS_NOM_EEG_PWR_SPEC_BETA_REL_LEFT:
          *dices_metric_id = MDC_EEG_PWR_SPEC_BETA_REL_LEFT;
          break;
        case NLS_NOM_EEG_PWR_SPEC_BETA_REL_RIGHT:
          *dices_metric_id = MDC_EEG_PWR_SPEC_BETA_REL_RIGHT;
          break;
      }
    }
      break;
    case NOM_EEG_PWR_SPEC_DELTA_REL:
    {
      switch (text_id)
      {
        case NLS_EEG_NAMES_CHAN_PCNT1:
          *dices_metric_id = MDC_EEG_PWR_SPEC_DELTA_REL_CH_1;
          break;
        case NLS_EEG_NAMES_CHAN_PCNT2:
          *dices_metric_id = MDC_EEG_PWR_SPEC_DELTA_REL_CH_2;
          break;
        case NLS_NOM_EEG_PWR_SPEC_DELTA_REL_LEFT:
          *dices_metric_id = MDC_EEG_PWR_SPEC_DELTA_REL_LEFT;
          break;
        case NLS_NOM_EEG_PWR_SPEC_DELTA_REL_RIGHT:
          *dices_metric_id = MDC_EEG_PWR_SPEC_DELTA_REL_RIGHT;
          break;
      }
    }
      break;
    case NOM_EEG_PWR_SPEC_THETA_REL:
    {
      switch (text_id)
      {
        case NLS_EEG_NAMES_CHAN_PCNT1:
          *dices_metric_id = MDC_EEG_PWR_SPEC_THETA_REL_CH_1;
          break;
        case NLS_EEG_NAMES_CHAN_PCNT2:
          *dices_metric_id = MDC_EEG_PWR_SPEC_THETA_REL_CH_2;
          break;
        case NLS_NOM_EEG_PWR_SPEC_THETA_REL_LEFT:
          *dices_metric_id = MDC_EEG_PWR_SPEC_THETA_REL_LEFT;
          break;
        case NLS_NOM_EEG_PWR_SPEC_THETA_REL_RIGHT:
          *dices_metric_id = MDC_EEG_PWR_SPEC_THETA_REL_RIGHT;
          break;
      }
    }
      break;
    case NOM_CONC_PH_ART:
          {
      switch (text_id)
      {
        case NLS_NOM_CONC_PH_ART:
          *dices_metric_id = MDC_CONC_PH_ART;
          break;
        case NLS_NOM_CONC_PH_ART_ADJ:
          *dices_metric_id = MDC_CONC_PH_ART;
          break;
      }
    }
      break;
    case NOM_CONC_HB_ART:
                {
      switch (text_id)
      {
        case NLS_NOM_CONC_HB_ART:
          *dices_metric_id = MDC_CONC_HB_ART;
          break;
        case NLS_NOM_CONC_HB_ART_CALC:
          *dices_metric_id = MDC_CONC_HB_ART;
          break;
      }
    }
      break;
    case NOM_CONC_PH_VEN:
                {
      switch (text_id)
      {
        case NLS_NOM_CONC_PH_VEN:
          *dices_metric_id = MDC_CONC_PH_VEN;
          break;
        case NLS_NOM_CONC_PH_VEN_ADJ:
          *dices_metric_id = MDC_CONC_PH_VEN;
          break;
      }
    }
      break;
    case NOM_CONC_PCO2_VEN:
                {
      switch (text_id)
      {
        case NLS_NOM_CONC_PCO2_VEN:
          *dices_metric_id = MDC_CONC_PCO2_VEN;
          break;
        case NLS_NOM_CONC_PCO2_VEN_ADJ:
          *dices_metric_id = MDC_CONC_PCO2_VEN;
          break;
      }
    }
      break;
    case NOM_CONC_PO2_VEN:
                {
      switch (text_id)
      {
        case NLS_NOM_VENT_AWAY_CO2_EXP:
          *dices_metric_id = MDC_CONC_PO2_VEN;
          break;
        case NLS_NOM_CONC_PO2_VEN_ADJ:
          *dices_metric_id = MDC_CONC_PO2_VEN;
          break;
      }
    }
      break;
    case NOM_CONC_HCO3_GEN:
                {
      switch (text_id)
      {
        case NLS_NOM_CONC_HCO3_GEN:
          *dices_metric_id = MDC_CONC_HCO3_GEN;
          break;
        case NLS_NOM_CONC_HCO3_GEN_CALC:
          *dices_metric_id = MDC_CONC_HCO3_GEN;
          break;
      }
    }
      break;
    case NOM_CONC_PCO2_GEN:
                {
      switch (text_id)
      {
        case NLS_NOM_CONC_PCO2_GEN:
          *dices_metric_id = MDC_CONC_PCO2_GEN;
          break;
        case NLS_NOM_CONC_PCO2_GEN_ADJ:
          *dices_metric_id = MDC_CONC_PCO2_GEN;
          break;
      }
    }
      break;
    case NOM_BASE_EXCESS_BLD_ART:
                {
      switch (text_id)
      {
        case NLS_NOM_BASE_EXCESS_BLD_ART:
          *dices_metric_id = MDC_BASE_EXCESS_BLD_ART;
          break;
        case NLS_NOM_BASE_EXCESS_BLD_ART_CALC:
          *dices_metric_id = MDC_BASE_EXCESS_BLD_ART;
          break;
      }
    }
      break;
    case NOM_CONC_PO2_GEN:
                {
      switch (text_id)
      {
        case NLS_NOM_CONC_PO2_GEN:
          *dices_metric_id = MDC_CONC_PO2_GEN;
          break;
        case NLS_NOM_CONC_PO2_GEN_ADJ:
          *dices_metric_id = MDC_CONC_PO2_GEN;
          break;
      }
    }
      break;
    case NOM_VOL_GLOBAL_END_DIA:
    {
      switch (text_id)
      {
        case NLS_NOM_VOL_GLOBAL_END_DIA:
          *dices_metric_id = MDC_VOL_GLOBAL_END_DIA;
          break;
        case NLS_NOM_VOL_VENT_L_END_DIA:
          *dices_metric_id = MDC_VOL_VENT_L_END_DIA;
          break;
      }
    }
      break;
    case NOM_VOL_GLOBAL_END_DIA_INDEX:
    {
      switch (text_id)
      {
        case NLS_NOM_VOL_GLOBAL_END_DIA_INDEX:
          *dices_metric_id = MDC_VOL_GLOBAL_END_DIA_INDEX;
          break;
        case NLS_NOM_VOL_VENT_L_END_DIA_INDEX:
          *dices_metric_id = MDC_VOL_VENT_L_END_DIA_INDEX;
          break;
      }
    }
      break;
    case NOM_AREA_BODY_SURFACE:
          {
      switch (text_id)
      {
        case NLS_NOM_AREA_BODY_SURFACE:
          *dices_metric_id = MDC_AREA_BODY_SURFACE;
          break;
        case NLS_NOM_AREA_BODY_SURFACE_ACTUAL_BOYD:
          *dices_metric_id = MDC_AREA_BODY_SURFACE_BOYD;
          break;
          case NLS_NOM_AREA_BODY_SURFACE_ACTUAL_DUBOIS:
          *dices_metric_id = MDC_AREA_BODY_SURFACE_DUBOIS;
          break;
      }
    }
      break;
    case NOM_CONC_BASE_EXCESS_ECF:
    {
      switch (text_id)
      {
        case NLS_NOM_CONC_BASE_EXCESS_ECF:
          *dices_metric_id = MDC_CONC_BASE_EXCESS_ECF;
          break;
        case NLS_NOM_CONC_BASE_EXCESS_ECF_CALC:
          *dices_metric_id = MDC_CONC_BASE_EXCESS_ECF;
          break;
      }
    }
      break;
    case NOM_PRESS_GEN_3:
    {
      switch (text_id)
      {
        case NLS_NOM_PRESS_GEN_3:
          *dices_metric_id = MDC_PRESS_GEN_3;
          break;
      }
    }
      break;
  }
  
  return DicesRcPhilipsIntellivueMP70::OK;
}
