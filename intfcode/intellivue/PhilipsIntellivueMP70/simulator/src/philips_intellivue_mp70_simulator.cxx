/**
 * @file masimo_pulse_oximeter_simulator.cxx
 *
 * @brief Defines a class which simulates both masimo radical-5 and radical-7
 * pulse oximeters. The model is selected upon startup. The data is written to
 * the serial port once per second.
 *
 * @author M Szwaja
 */
//=============================================================================

#include <unistd.h>
#include <iomanip>
#include <ctime>
#include <thread>
#include <atomic>
#include <mutex>
#include <chrono>
#include <cstdio>
#include <cstring>
#include <sys/types.h>
#include <ifaddrs.h>
#include <netinet/in.h>
#include <linux/types.h>
#include <linux/netlink.h>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <netdb.h>
#include <cstdlib>
#include <sys/ioctl.h>
#include <net/if.h>
#include <log4cplus/loggingmacros.h>
#include <log4cplus/configurator.h>
#include "kbhit_util.h"
#include "common.h"
#include "Core/CmdLnArgParser/DeviceSimulatorInheritance/simulator-cmd-ln-arg-parser.h"
#include "Core/Time/dices-time.h"
#include "Communication/RS232/rs232.h"
#include "Communication/RS232/rs232-read-interface-three-pin.h"
#include "Communication/Socket/socket.h"
#include "Communication/Socket/socket-read-interface-impl.h"
#include "intellivue.h"
#include "intellivue_utils.h"
#include "intellivue_serial.h"
#include "philips_intellivue_mp70_simulator.h"
#include "Communication/rc-base-communication.h"

#define VERBOSITY_LEVEL 1

static const int kAsciiEsc = 0x1B;
static const uint8_t kBOF = 0xC0;
static const int kEOF = 0xC1;
static const int kMaxNumberOfFilePointers = 10;
static const int kMaxReceiveBufferSize = 5000;
static const int kMaxFileRecordBufferSize = 50000;
static const int kEndOfFileMaxLimit = 2;
static const int kconnect_indication_port = 24005; // Connect Indication Port number
static const int kprotocol_udp_port = 24105; // Protocol UDP Port number

std::atomic<bool> terminate_simulator(false);

static log4cplus::Logger root_logger = log4cplus::Logger::getRoot();
static log4cplus::Logger cmd_logger = log4cplus::Logger::getInstance(
  "cmdlogger");

static uint8_t ksimulate_association_response[] = {
  0xC0, 0x11, 0x01, 0x00, 0xD0, 0x0E, 0xCE, 0x05, 0x08, 0x13, 0x01, 0x00, 0x16, 0x01, 0x02, 0x80,
  0x00, 0x14, 0x02, 0x00, 0x02, 0x7D, 0xE1, 0xBE, 0x31, 0x80, 0xA0, 0x80, 0x80, 0x01, 0x01, 0x00,
  0x00, 0xA2, 0x80, 0xA0, 0x03, 0x00, 0x00, 0x01, 0xA5, 0x80, 0x30, 0x80, 0x80, 0x01, 0x00, 0x81,
  0x02, 0x51, 0x01, 0x00, 0x00, 0x30, 0x80, 0x80, 0x01, 0x00, 0x81, 0x0C, 0x2A, 0x86, 0x48, 0xCE,
  0x14, 0x02, 0x01, 0x00, 0x00, 0x00, 0x02, 0x01, 0x00, 0x00, 0x00, 0x00, 0x61, 0x80, 0x30, 0x80,
  0x02, 0x01, 0x01, 0xA0, 0x80, 0x61, 0x80, 0xA1, 0x80, 0x06, 0x0C, 0x2A, 0x86, 0x48, 0xCE, 0x14,
  0x02, 0x01, 0x00, 0x00, 0x00, 0x03, 0x01, 0x00, 0x00, 0xA2, 0x03, 0x02, 0x01, 0x00, 0xA3, 0x05,
  0xA1, 0x03, 0x02, 0x01, 0x00, 0xBE, 0x80, 0x28, 0x80, 0x02, 0x01, 0x02, 0x81, 0x48, 0x80, 0x00,
  0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x80, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x2C, 0x00, 0x01, 0x00, 0x28, 0x80, 0x00,
  0x00, 0x00, 0x00, 0x0C, 0x35, 0x00, 0x00, 0x00, 0x03, 0xE4, 0x00, 0x00, 0x03, 0xE4, 0xFF, 0xFF,
  0xFF, 0xFF, 0x60, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x0C, 0xF0, 0x01, 0x00, 0x08, 0x88, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xD0, 0xC3, 0xC1
};

static uint8_t ksimulate_mds_create_event_report[] = {
  0xC0, 0x11, 0x01, 0x01, 0x1A, 0xE1, 0x00, 0x00, 0x02, 0x00, 0x01, 0x01, 0x12, 0x00, 0x01, 0x00,
  0x01, 0x01, 0x0C, 0x00, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC8, 0xAD, 0x00, 0x0D, 0x06, 0x00,
  0xFE, 0x00, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0x00, 0xF4, 0x09, 0x84, 0x00, 0x08, 0x00,
  0x06, 0x00, 0x09, 0xFB, 0x70, 0x57, 0x1D, 0x09, 0x86, 0x00, 0x04, 0x00, 0x01, 0x11, 0x4D, 0x09,
  0x1D, 0x00, 0x02, 0x03, 0x7F, 0x09, 0x28, 0x00, 0x12, 0x00, 0x08, 0x50, 0x68, 0x69, 0x6C, 0x69,
  0x70, 0x73, 0x00, 0x00, 0x06, 0x4D, 0x38, 0x30, 0x30, 0x30, 0x00, 0x09, 0x48, 0x00, 0x04, 0x00,
  0x01, 0x00, 0x00, 0x09, 0x37, 0x00, 0x08, 0x06, 0x46, 0x06, 0x46, 0x00, 0x01, 0x00, 0x0B, 0x09,
  0x46, 0x00, 0x02, 0x40, 0x00, 0x09, 0x0D, 0x00, 0x02, 0x00, 0x01, 0x09, 0x35, 0x00, 0x02, 0x00,
  0x02, 0x09, 0x82, 0x00, 0x02, 0x00, 0x02, 0x09, 0x0C, 0x00, 0x02, 0x00, 0x00, 0xF1, 0xFA, 0x00,
  0x14, 0x00, 0x01, 0x00, 0x10, 0x00, 0x01, 0x00, 0x0C, 0x00, 0x06, 0x00, 0x01, 0x86, 0xA6, 0x00,
  0x06, 0x00, 0x01, 0x87, 0x3C, 0x09, 0xA7, 0x00, 0x02, 0x00, 0x06, 0x09, 0x1E, 0x00, 0x24, 0x00,
  0x22, 0x00, 0x4F, 0x00, 0x52, 0x00, 0x31, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x09, 0x87, 0x00, 0x08, 0x20, 0x14, 0x06, 0x24, 0x14, 0x05, 0x19, 0x00, 0x09,
  0x8F, 0x00, 0x04, 0x00, 0xC8, 0xAD, 0x00, 0x09, 0x85, 0x00, 0x34, 0x00, 0x01, 0x00, 0x30, 0x01,
  0x02, 0x00, 0x2C, 0x00, 0x05, 0x00, 0x28, 0x00, 0x01, 0x00, 0x21, 0x00, 0x00, 0x00, 0x01, 0x00,
  0x01, 0x00, 0x06, 0x00, 0x00, 0x01, 0x0E, 0x00, 0x01, 0x00, 0x09, 0x00, 0x00, 0x00, 0x49, 0x00,
  0x01, 0x00, 0x2A, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x36, 0x00, 0x00, 0x00, 0x01, 0x79,
  0xCD, 0xC1
};

static uint8_t ksimulate_set_priority_list_result[] = {
  0xC0, 0x11, 0x01, 0x00, 0x34, 0xE1, 0x00, 0x00, 0x02, 0x00, 0x02, 0x00, 0x2C, 0x00, 0x00, 0x00,
  0x05, 0x00, 0x26, 0x00, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x1C, 0xF2, 0x3A, 0x00,
  0x18, 0x00, 0x05, 0x00, 0x14, 0x00, 0x02, 0x01, 0x02, 0x00, 0x02, 0x4B, 0xB4, 0x00, 0x02, 0x4A,
  0x1C, 0x00, 0x02, 0x50, 0xAC, 0x00, 0x02, 0x50, 0x00, 0x58, 0xA7, 0xC1
};

static uint8_t ksimulate_mds[] = {
  0xC0, 0x11, 0x01, 0x01, 0xC8, 0xE1, 0x00, 0x00, 0x02, 0x00, 0x02, 0x01, 0x7D, 0xE0, 0x00, 0x02,
  0x00, 0x07, 0x01, 0xBA, 0x00, 0x21, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x16, 0x01, 0xB0, 0x00, 0x00,
  0x00, 0xC9, 0x33, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x01, 0x00, 0x21,
  0x00, 0x00, 0x00, 0x01, 0x01, 0x98, 0x00, 0x00, 0x00, 0x01, 0x01, 0x92, 0x00, 0x00, 0x00, 0x13,
  0x01, 0x8C, 0x09, 0x46, 0x00, 0x02, 0x40, 0x00, 0x09, 0x0D, 0x00, 0x02, 0x00, 0x01, 0x09, 0x35,
  0x00, 0x02, 0x00, 0x02, 0x09, 0x82, 0x00, 0x02, 0x00, 0x02, 0x09, 0x0C, 0x00, 0x02, 0x00, 0x00,
  0xF1, 0xFA, 0x00, 0x14, 0x00, 0x01, 0x00, 0x10, 0x00, 0x01, 0x00, 0x0C, 0x00, 0x06, 0x00, 0x01,
  0x86, 0xA6, 0x00, 0x06, 0x00, 0x01, 0x87, 0x3C, 0x09, 0xA7, 0x00, 0x02, 0x00, 0x06, 0x09, 0x84,
  0x00, 0x08, 0x00, 0x06, 0x00, 0x09, 0xFB, 0x70, 0x57, 0x1D, 0x09, 0x1E, 0x00, 0x24, 0x00, 0x22,
  0x00, 0x4F, 0x00, 0x52, 0x00, 0x31, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x09, 0x87, 0x00, 0x08, 0x20, 0x14, 0x06, 0x24, 0x14, 0x05, 0x24, 0x00, 0x09, 0x8F,
  0x00, 0x04, 0x00, 0xC9, 0x33, 0x00, 0x09, 0x86, 0x00, 0x04, 0x00, 0x01, 0x11, 0x4D, 0x09, 0x1D,
  0x00, 0x02, 0x03, 0x7F, 0x09, 0x21, 0x00, 0x02, 0x00, 0x00, 0x09, 0x28, 0x00, 0x12, 0x00, 0x08,
  0x50, 0x68, 0x69, 0x6C, 0x69, 0x70, 0x73, 0x00, 0x00, 0x06, 0x4D, 0x38, 0x30, 0x30, 0x30, 0x00,
  0x09, 0x2D, 0x00, 0x8E, 0x00, 0x08, 0x00, 0x8A, 0x00, 0x01, 0x00, 0x08, 0x00, 0x0A, 0x44, 0x45,
  0x38, 0x34, 0x33, 0x41, 0x31, 0x36, 0x36, 0x34, 0x00, 0x02, 0x00, 0x08, 0x00, 0x0E, 0x4D, 0x38,
  0x30, 0x30, 0x37, 0x41, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x58,
  0x00, 0x0E, 0x53, 0x2D, 0x4D, 0x34, 0x30, 0x34, 0x36, 0x2D, 0x31, 0x37, 0x30, 0x31, 0x41, 0x20,
  0x00, 0x04, 0x00, 0x58, 0x00, 0x08, 0x4A, 0x2E, 0x31, 0x30, 0x2E, 0x32, 0x36, 0x20, 0x00, 0x02,
  0x00, 0x10, 0x00, 0x0E, 0x53, 0x2D, 0x4D, 0x34, 0x30, 0x34, 0x36, 0x2D, 0x31, 0x36, 0x30, 0x31,
  0x41, 0x20, 0x00, 0x04, 0x00, 0x10, 0x00, 0x08, 0x4A, 0x2E, 0x31, 0x30, 0x2E, 0x32, 0x36, 0x20,
  0x00, 0x02, 0x00, 0x18, 0x00, 0x0E, 0x53, 0x2D, 0x4D, 0x38, 0x30, 0x30, 0x30, 0x2D, 0x31, 0x33,
  0x30, 0x31, 0x41, 0x20, 0x00, 0x04, 0x00, 0x18, 0x00, 0x08, 0x41, 0x2E, 0x31, 0x36, 0x2E, 0x31,
  0x30, 0x00, 0x09, 0x85, 0x00, 0x34, 0x00, 0x01, 0x00, 0x30, 0x01, 0x02, 0x00, 0x2C, 0x00, 0x05,
  0x00, 0x28, 0x00, 0x01, 0x00, 0x21, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x06, 0x00, 0x00,
  0x01, 0x0E, 0x00, 0x01, 0x00, 0x09, 0x00, 0x00, 0x00, 0x49, 0x00, 0x01, 0x00, 0x2A, 0x00, 0x00,
  0x00, 0x01, 0x00, 0x01, 0x00, 0x36, 0x00, 0x00, 0x00, 0x01, 0x09, 0x48, 0x00, 0x04, 0x00, 0x01,
  0x00, 0x00, 0x09, 0x37, 0x00, 0x08, 0x06, 0x46, 0x06, 0x46, 0x00, 0x01, 0x00, 0x0B, 0x10, 0xAE,
  0xC1
};

static uint8_t ksimulate_al_mon[] = {
  0xC0, 0x11, 0x01, 0x00, 0x5C, 0xE1, 0x00, 0x00, 0x02, 0x00, 0x02, 0x00, 0x54, 0x00, 0x07, 0x00,
  0x07, 0x00, 0x4E, 0x00, 0x21, 0x00, 0x00, 0x00, 0x00, 0xF1, 0x3B, 0x00, 0x44, 0x00, 0x02, 0x00,
  0x00, 0x00, 0xC9, 0x33, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x01, 0x00,
  0x36, 0x08, 0x01, 0x00, 0x01, 0x00, 0x2A, 0x00, 0x00, 0x00, 0x01, 0x00, 0x24, 0x00, 0x00, 0x00,
  0x03, 0x00, 0x1E, 0x09, 0x16, 0x00, 0x0A, 0x10, 0x04, 0x04, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x09, 0x02, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x09, 0x04, 0x00, 0x04, 0x00, 0x00, 0x00,
  0x00, 0xAE, 0x96, 0xC1
};

static uint8_t ksimulate_pat_demog[] = {
  0xC0, 0x11, 0x01, 0x01, 0x10, 0xE1, 0x00, 0x00, 0x02, 0x00, 0x02, 0x01, 0x08, 0x00, 0x02, 0x00,
  0x07, 0x01, 0x02, 0x00, 0x21, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x16, 0x00, 0xF8, 0x00, 0x02, 0x00,
  0xC9, 0x73, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x01, 0x00, 0x2A, 0x00,
  0x00, 0x00, 0x01, 0x00, 0xE0, 0x00, 0x00, 0x00, 0x01, 0x00, 0xDA, 0x00, 0x50, 0x00, 0x18, 0x00,
  0xD4, 0x09, 0x21, 0x00, 0x02, 0x00, 0x50, 0x09, 0x57, 0x00, 0x02, 0x00, 0x02, 0x0A, 0x1A, 0x00,
  0x02, 0x20, 0x00, 0xF0, 0x01, 0x00, 0x0A, 0x00, 0x09, 0xFB, 0x70, 0x57, 0x1D, 0x20, 0xB2, 0xFC,
  0x7D, 0xE1, 0x09, 0x62, 0x00, 0x02, 0x00, 0x01, 0x0A, 0x1E, 0x00, 0x02, 0x00, 0x02, 0x09, 0x5D,
  0x00, 0x04, 0x00, 0x02, 0x00, 0x00, 0x09, 0x5F, 0x00, 0x04, 0x00, 0x02, 0x00, 0x00, 0x09, 0x5C,
  0x00, 0x16, 0x00, 0x14, 0x00, 0x45, 0x00, 0x6E, 0x00, 0x67, 0x00, 0x65, 0x00, 0x6C, 0x00, 0x62,
  0x00, 0x72, 0x00, 0x74, 0x00, 0x6F, 0x00, 0x00, 0xF2, 0xD4, 0x00, 0x04, 0x00, 0x02, 0x00, 0x00,
  0x09, 0x5A, 0x00, 0x04, 0x00, 0x02, 0x00, 0x00, 0xF2, 0xE1, 0x00, 0x04, 0x00, 0x02, 0x00, 0x00,
  0xF1, 0x29, 0x00, 0x04, 0x00, 0x02, 0x00, 0x00, 0xF1, 0x2A, 0x00, 0x04, 0x00, 0x02, 0x00, 0x00,
  0x09, 0x61, 0x00, 0x02, 0x00, 0x09, 0x09, 0x58, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x09, 0xD8, 0x00, 0x06, 0x00, 0x7F, 0xFF, 0xFF, 0x09, 0x40, 0x09, 0xDC, 0x00, 0x06,
  0x00, 0x7F, 0xFF, 0xFF, 0x05, 0x11, 0x09, 0xDF, 0x00, 0x06, 0x00, 0x7F, 0xFF, 0xFF, 0x06, 0xC3,
  0x09, 0x56, 0x00, 0x06, 0x00, 0x7F, 0xFF, 0xFF, 0x05, 0x7D, 0xE0, 0xF1, 0xEC, 0x00, 0x02, 0x00,
  0x02, 0xF2, 0xE2, 0x00, 0x04, 0x80, 0x75, 0x20, 0x95, 0xF2, 0xE3, 0x00, 0x04, 0x80, 0x8B, 0x0D,
  0x99, 0xF9, 0x96, 0x00, 0x02, 0x00, 0x00, 0x8E, 0x4C, 0xC1
};

static uint8_t ksimulate_numeric_static_linked[] = {
  // first message
  0xC0, 0x11, 0x01, 0x01, 0xA8, 0xE1, 0x00, 0x00, 0x02, 0x00, 0x05, 0x01, 0xA0, 0x01, 0x01, 0x00,
  0x08, 0x00, 0x07, 0x01, 0x98, 0x00, 0x21, 0x00, 0x00, 0x00, 0x00, 0xF1, 0x3B, 0x01, 0x8E, 0x00,
  0x00, 0x00, 0x00, 0x00, 0xC8, 0xF3, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00,
  0x01, 0x00, 0x06, 0x08, 0x11, 0x00, 0x02, 0x01, 0x74, 0x00, 0x00, 0x00, 0x07, 0x00, 0xFC, 0x86,
  0x61, 0x00, 0x03, 0x00, 0x1E, 0x09, 0x21, 0x00, 0x02, 0x86, 0x61, 0x09, 0x2F, 0x00, 0x04, 0x00,
  0x01, 0x00, 0x06, 0x09, 0x3F, 0x00, 0x0C, 0x00, 0x00, 0x20, 0x00, 0x00, 0x01, 0x42, 0x28, 0x00,
  0x00, 0x00, 0x00, 0x86, 0x7A, 0x00, 0x03, 0x00, 0x1E, 0x09, 0x21, 0x00, 0x02, 0x86, 0x7A, 0x09,
  0x2F, 0x00, 0x04, 0x00, 0x01, 0x00, 0x06, 0x09, 0x3F, 0x00, 0x0C, 0x00, 0x00, 0x20, 0x00, 0x00,
  0x01, 0x42, 0x28, 0x00, 0x00, 0x00, 0x00, 0x86, 0x93, 0x00, 0x03, 0x00, 0x1E, 0x09, 0x21, 0x00,
  0x02, 0x86, 0x93, 0x09, 0x2F, 0x00, 0x04, 0x00, 0x01, 0x00, 0x06, 0x09, 0x3F, 0x00, 0x0C, 0x00,
  0x00, 0x20, 0x00, 0x00, 0x01, 0x42, 0x28, 0x00, 0x00, 0x00, 0x00, 0x86, 0xAC, 0x00, 0x03, 0x00,
  0x1E, 0x09, 0x21, 0x00, 0x02, 0x86, 0xAC, 0x09, 0x2F, 0x00, 0x04, 0x00, 0x01, 0x00, 0x06, 0x09,
  0x3F, 0x00, 0x0C, 0x00, 0x00, 0x20, 0x00, 0x00, 0x01, 0x42, 0x28, 0x00, 0x00, 0x00, 0x00, 0x86,
  0xC5, 0x00, 0x03, 0x00, 0x1E, 0x09, 0x21, 0x00, 0x02, 0x86, 0xC5, 0x09, 0x2F, 0x00, 0x04, 0x00,
  0x01, 0x00, 0x06, 0x09, 0x3F, 0x00, 0x0C, 0x00, 0x00, 0x20, 0x00, 0x00, 0x01, 0x42, 0x28, 0x00,
  0x00, 0x00, 0x00, 0x86, 0xDE, 0x00, 0x03, 0x00, 0x1E, 0x09, 0x21, 0x00, 0x02, 0x86, 0xDE, 0x09,
  0x2F, 0x00, 0x04, 0x00, 0x01, 0x00, 0x06, 0x09, 0x3F, 0x00, 0x0C, 0x00, 0x00, 0x20, 0x00, 0x00,
  0x01, 0x42, 0x28, 0x00, 0x00, 0x00, 0x00, 0x87, 0x1E, 0x00, 0x03, 0x00, 0x1E, 0x09, 0x21, 0x00,
  0x02, 0x87, 0x1E, 0x09, 0x2F, 0x00, 0x04, 0x00, 0x01, 0x00, 0x06, 0x09, 0x3F, 0x00, 0x0C, 0x00,
  0x00, 0x20, 0x00, 0x00, 0x05, 0x52, 0x28, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x03, 0x00,
  0x6C, 0x86, 0x9D, 0x00, 0x03, 0x00, 0x1E, 0x09, 0x21, 0x00, 0x02, 0x86, 0x9D, 0x09, 0x2F, 0x00,
  0x04, 0x00, 0x01, 0x00, 0x06, 0x09, 0x3F, 0x00, 0x0C, 0x00, 0x00, 0x20, 0x00, 0x00, 0x01, 0x42,
  0x28, 0x00, 0x00, 0x00, 0x00, 0x86, 0xA6, 0x00, 0x03, 0x00, 0x1E, 0x09, 0x21, 0x00, 0x02, 0x86,
  0xA6, 0x09, 0x2F, 0x00, 0x04, 0x00, 0x01, 0x00, 0x06, 0x09, 0x3F, 0x00, 0x0C, 0x00, 0x00, 0x20,
  0x00, 0x00, 0x01, 0x42, 0x28, 0x00, 0x00, 0x00, 0x00, 0x86, 0xAD, 0x00, 0x03, 0x00, 0x1E, 0x09,
  0x21, 0x00, 0x02, 0x86, 0xAD, 0x09, 0x2F, 0x00, 0x04, 0x00, 0x01, 0x00, 0x06, 0x09, 0x3F, 0x00,
  0x0C, 0x00, 0x00, 0x20, 0x00, 0x00, 0x01, 0x42, 0x28, 0x00, 0x00, 0x00, 0x00, 0x46, 0xAC, 0xC1,
  // second message
  0xC0, 0x11, 0x01, 0x01, 0xA2, 0xE1, 0x00, 0x00, 0x02, 0x00, 0x05, 0x01, 0x9A, 0x02, 0x02, 0x00,
  0x08, 0x00, 0x07, 0x01, 0x92, 0x00, 0x21, 0x00, 0x00, 0x00, 0x00, 0xF1, 0x3B, 0x01, 0x88, 0x00,
  0x00, 0x00, 0x00, 0x00, 0xC8, 0xF3, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00,
  0x01, 0x00, 0x06, 0x08, 0x11, 0x00, 0x01, 0x01, 0x6E, 0x00, 0x01, 0x00, 0x0A, 0x01, 0x68, 0x87,
  0x09, 0x00, 0x03, 0x00, 0x1E, 0x09, 0x21, 0x00, 0x02, 0x87, 0x09, 0x09, 0x2F, 0x00, 0x04, 0x00,
  0x01, 0x00, 0x06, 0x09, 0x3F, 0x00, 0x0C, 0x00, 0x00, 0x20, 0x00, 0x00, 0x01, 0x52, 0x28, 0x01,
  0x03, 0x00, 0x00, 0x87, 0x0C, 0x00, 0x03, 0x00, 0x1E, 0x09, 0x21, 0x00, 0x02, 0x87, 0x0C, 0x09,
  0x2F, 0x00, 0x04, 0x00, 0x01, 0x00, 0x06, 0x09, 0x3F, 0x00, 0x0C, 0x00, 0x00, 0x20, 0x00, 0x00,
  0x01, 0x52, 0x28, 0x00, 0x01, 0x00, 0x00, 0x87, 0x3C, 0x00, 0x03, 0x00, 0x1E, 0x09, 0x21, 0x00,
  0x02, 0x87, 0x3C, 0x09, 0x2F, 0x00, 0x04, 0x00, 0x01, 0x00, 0x06, 0x09, 0x3F, 0x00, 0x0C, 0x00,
  0x00, 0x20, 0x00, 0x00, 0x01, 0x42, 0x28, 0x00, 0x00, 0x00, 0x00, 0x87, 0x43, 0x00, 0x03, 0x00,
  0x1E, 0x09, 0x21, 0x00, 0x02, 0x87, 0x43, 0x09, 0x2F, 0x00, 0x04, 0x00, 0x01, 0x00, 0x06, 0x09,
  0x3F, 0x00, 0x0C, 0x00, 0x00, 0x20, 0x00, 0x00, 0x01, 0x42, 0x28, 0x00, 0x00, 0x00, 0x00, 0x87,
  0x48, 0x00, 0x03, 0x00, 0x1E, 0x09, 0x21, 0x00, 0x02, 0x87, 0x48, 0x09, 0x2F, 0x00, 0x04, 0x00,
  0x01, 0x00, 0x06, 0x09, 0x3F, 0x00, 0x0C, 0x00, 0x00, 0x20, 0x00, 0x00, 0x01, 0x42, 0x28, 0x01,
  0x0C, 0x00, 0x00, 0x87, 0x4E, 0x00, 0x03, 0x00, 0x1E, 0x09, 0x21, 0x00, 0x02, 0x87, 0x4E, 0x09,
  0x2F, 0x00, 0x04, 0x00, 0x01, 0x00, 0x06, 0x09, 0x3F, 0x00, 0x0C, 0x00, 0x00, 0x20, 0x00, 0x00,
  0x01, 0x24, 0x00, 0x01, 0x0C, 0x00, 0x80, 0x87, 0x50, 0x00, 0x03, 0x00, 0x1E, 0x09, 0x21, 0x00,
  0x02, 0x87, 0x50, 0x09, 0x2F, 0x00, 0x04, 0x00, 0x01, 0x00, 0x06, 0x09, 0x3F, 0x00, 0x0C, 0x00,
  0x00, 0x20, 0x00, 0x00, 0x05, 0x42, 0x28, 0x00, 0x00, 0x00, 0x00, 0x87, 0x55, 0x00, 0x03, 0x00,
  0x1E, 0x09, 0x21, 0x00, 0x02, 0x87, 0x55, 0x09, 0x2F, 0x00, 0x04, 0x00, 0x01, 0x00, 0x06, 0x09,
  0x3F, 0x00, 0x0C, 0x00, 0x00, 0x20, 0x00, 0x00, 0x01, 0x42, 0x28, 0x00, 0x00, 0x00, 0x00, 0x87,
  0x62, 0x00, 0x03, 0x00, 0x1E, 0x09, 0x21, 0x00, 0x02, 0x87, 0x62, 0x09, 0x2F, 0x00, 0x04, 0x00,
  0x01, 0x00, 0x06, 0x09, 0x3F, 0x00, 0x0C, 0x00, 0x00, 0x20, 0x00, 0x00, 0x01, 0x42, 0x28, 0x00,
  0x00, 0x00, 0x00, 0x87, 0x64, 0x00, 0x03, 0x00, 0x1E, 0x09, 0x21, 0x00, 0x02, 0x87, 0x64, 0x09,
  0x2F, 0x00, 0x04, 0x00, 0x01, 0x00, 0x06, 0x09, 0x3F, 0x00, 0x0C, 0x00, 0x00, 0x20, 0x00, 0x00,
  0x01, 0x42, 0x28, 0x00, 0x00, 0x00, 0x00, 0xE2, 0xBF, 0xC1,
  // third message
  0xC0, 0x11, 0x01, 0x01, 0xA2, 0xE1, 0x00, 0x00, 0x02, 0x00, 0x05, 0x01, 0x9A, 0x02, 0x03, 0x00,
  0x08, 0x00, 0x07, 0x01, 0x92, 0x00, 0x21, 0x00, 0x00, 0x00, 0x00, 0xF1, 0x3B, 0x01, 0x88, 0x00,
  0x00, 0x00, 0x00, 0x00, 0xC8, 0xF3, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00,
  0x01, 0x00, 0x06, 0x08, 0x11, 0x00, 0x01, 0x01, 0x6E, 0x00, 0x01, 0x00, 0x0A, 0x01, 0x68, 0x87,
  0x66, 0x00, 0x03, 0x00, 0x1E, 0x09, 0x21, 0x00, 0x02, 0x87, 0x66, 0x09, 0x2F, 0x00, 0x04, 0x00,
  0x01, 0x00, 0x06, 0x09, 0x3F, 0x00, 0x0C, 0x00, 0x00, 0x20, 0x00, 0x00, 0x01, 0x42, 0x28, 0x00,
  0x00, 0x00, 0x00, 0x87, 0x68, 0x00, 0x03, 0x00, 0x1E, 0x09, 0x21, 0x00, 0x02, 0x87, 0x68, 0x09,
  0x2F, 0x00, 0x04, 0x00, 0x01, 0x00, 0x06, 0x09, 0x3F, 0x00, 0x0C, 0x00, 0x00, 0x20, 0x00, 0x00,
  0x01, 0x42, 0x28, 0x00, 0x00, 0x00, 0x00, 0x87, 0x6C, 0x00, 0x03, 0x00, 0x1E, 0x09, 0x21, 0x00,
  0x02, 0x87, 0x6C, 0x09, 0x2F, 0x00, 0x04, 0x00, 0x01, 0x00, 0x06, 0x09, 0x3F, 0x00, 0x0C, 0x00,
  0x00, 0x20, 0x00, 0x00, 0x01, 0x24, 0x00, 0x00, 0x00, 0x00, 0x80, 0x87, 0x6E, 0x00, 0x03, 0x00,
  0x1E, 0x09, 0x21, 0x00, 0x02, 0x87, 0x6E, 0x09, 0x2F, 0x00, 0x04, 0x00, 0x01, 0x00, 0x06, 0x09,
  0x3F, 0x00, 0x0C, 0x00, 0x00, 0x20, 0x00, 0x00, 0x01, 0x24, 0x00, 0x00, 0x00, 0x00, 0x80, 0x87,
  0x7D, 0xE0, 0x00, 0x03, 0x00, 0x1E, 0x09, 0x21, 0x00, 0x02, 0x87, 0x7D, 0xE0, 0x09, 0x2F, 0x00,
  0x04, 0x00, 0x01, 0x00, 0x06, 0x09, 0x3F, 0x00, 0x0C, 0x00, 0x00, 0x20, 0x00, 0x00, 0x01, 0x42,
  0x28, 0x00, 0x00, 0x00, 0x00, 0x88, 0x06, 0x00, 0x03, 0x00, 0x1E, 0x09, 0x21, 0x00, 0x02, 0x88,
  0x06, 0x09, 0x2F, 0x00, 0x04, 0x00, 0x01, 0x00, 0x06, 0x09, 0x3F, 0x00, 0x0C, 0x00, 0x00, 0x20,
  0x00, 0x00, 0x01, 0x42, 0x28, 0x01, 0x03, 0x00, 0x00, 0x88, 0x0D, 0x00, 0x03, 0x00, 0x1E, 0x09,
  0x21, 0x00, 0x02, 0x88, 0x0D, 0x09, 0x2F, 0x00, 0x04, 0x00, 0x01, 0x00, 0x06, 0x09, 0x3F, 0x00,
  0x0C, 0x00, 0x00, 0x20, 0x00, 0x00, 0x01, 0x42, 0x28, 0x00, 0x00, 0x00, 0x00, 0x88, 0x2D, 0x00,
  0x03, 0x00, 0x1E, 0x09, 0x21, 0x00, 0x02, 0x88, 0x2D, 0x09, 0x2F, 0x00, 0x04, 0x00, 0x01, 0x00,
  0x06, 0x09, 0x3F, 0x00, 0x0C, 0x00, 0x00, 0x20, 0x00, 0x00, 0x01, 0x42, 0x28, 0x01, 0x03, 0x00,
  0x00, 0x88, 0x34, 0x00, 0x03, 0x00, 0x1E, 0x09, 0x21, 0x00, 0x02, 0x88, 0x34, 0x09, 0x2F, 0x00,
  0x04, 0x00, 0x01, 0x00, 0x06, 0x09, 0x3F, 0x00, 0x0C, 0x00, 0x00, 0x20, 0x00, 0x00, 0x01, 0x42,
  0x28, 0x00, 0x00, 0x00, 0x00, 0x88, 0x54, 0x00, 0x03, 0x00, 0x1E, 0x09, 0x21, 0x00, 0x02, 0x88,
  0x54, 0x09, 0x2F, 0x00, 0x04, 0x00, 0x01, 0x00, 0x06, 0x09, 0x3F, 0x00, 0x0C, 0x00, 0x00, 0x20,
  0x00, 0x00, 0x01, 0x42, 0x28, 0x01, 0x03, 0x00, 0x00, 0xE6, 0x1E, 0xC1,
  // fourth message
  0xC0, 0x11, 0x01, 0x01, 0x12, 0xE1, 0x00, 0x00, 0x02, 0x00, 0x05, 0x01, 0x0A, 0x03, 0x04, 0x00,
  0x08, 0x00, 0x07, 0x01, 0x02, 0x00, 0x21, 0x00, 0x00, 0x00, 0x00, 0xF1, 0x3B, 0x00, 0xF8, 0x00,
  0x00, 0x00, 0x00, 0x00, 0xC8, 0xF3, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00,
  0x01, 0x00, 0x06, 0x08, 0x11, 0x00, 0x01, 0x00, 0xDE, 0x00, 0x01, 0x00, 0x06, 0x00, 0xD8, 0x88,
  0x5B, 0x00, 0x03, 0x00, 0x1E, 0x09, 0x21, 0x00, 0x02, 0x88, 0x5B, 0x09, 0x2F, 0x00, 0x04, 0x00,
  0x01, 0x00, 0x06, 0x09, 0x3F, 0x00, 0x0C, 0x00, 0x00, 0x20, 0x00, 0x00, 0x01, 0x42, 0x28, 0x00,
  0x00, 0x00, 0x00, 0x88, 0x94, 0x00, 0x03, 0x00, 0x1E, 0x09, 0x21, 0x00, 0x02, 0x88, 0x94, 0x09,
  0x2F, 0x00, 0x04, 0x00, 0x01, 0x00, 0x06, 0x09, 0x3F, 0x00, 0x0C, 0x00, 0x00, 0x20, 0x00, 0x00,
  0x01, 0x42, 0x28, 0x01, 0x02, 0x00, 0x00, 0x88, 0x9A, 0x00, 0x03, 0x00, 0x1E, 0x09, 0x21, 0x00,
  0x02, 0x88, 0x9A, 0x09, 0x2F, 0x00, 0x04, 0x00, 0x01, 0x00, 0x06, 0x09, 0x3F, 0x00, 0x0C, 0x00,
  0x00, 0x20, 0x00, 0x00, 0x01, 0x42, 0x28, 0x00, 0x00, 0x00, 0x00, 0x89, 0x0E, 0x00, 0x03, 0x00,
  0x1E, 0x09, 0x21, 0x00, 0x02, 0x89, 0x0E, 0x09, 0x2F, 0x00, 0x04, 0x00, 0x01, 0x00, 0x06, 0x09,
  0x3F, 0x00, 0x0C, 0x00, 0x00, 0x20, 0x00, 0x00, 0x01, 0x42, 0x28, 0x00, 0x00, 0x00, 0x00, 0x89,
  0x24, 0x00, 0x03, 0x00, 0x1E, 0x09, 0x21, 0x00, 0x02, 0x89, 0x24, 0x09, 0x2F, 0x00, 0x04, 0x00,
  0x01, 0x00, 0x06, 0x09, 0x3F, 0x00, 0x0C, 0x00, 0x00, 0x20, 0x00, 0x00, 0x01, 0xD2, 0x28, 0x00,
  0x00, 0x00, 0x00, 0x89, 0x26, 0x00, 0x03, 0x00, 0x1E, 0x09, 0x21, 0x00, 0x02, 0x89, 0x26, 0x09,
  0x2F, 0x00, 0x04, 0x00, 0x01, 0x00, 0x06, 0x09, 0x3F, 0x00, 0x0C, 0x00, 0x00, 0x20, 0x00, 0x00,
  0x01, 0xD2, 0x28, 0x00, 0x00, 0x00, 0x00, 0xA6, 0xD9, 0xC1,
  // final message
  0xC0, 0x11, 0x01, 0x00, 0x32, 0xE1, 0x00, 0x00, 0x02, 0x00, 0x02, 0x00, 0x2A, 0x00, 0x08, 0x00,
  0x07, 0x00, 0x24, 0x00, 0x21, 0x00, 0x00, 0x00, 0x00, 0xF1, 0x3B, 0x00, 0x1A, 0x00, 0x00, 0x00,
  0x00, 0x00, 0xC8, 0xF3, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x01, 0x00,
  0x06, 0x08, 0x11, 0x00, 0x00, 0x00, 0x00, 0x46, 0xE2, 0xC1
};

static uint8_t ksimulate_rtsa_static[] = {
  0xC0, 0x11, 0x01, 0x00, 0xF8, 0xE1, 0x00, 0x00, 0x02, 0x00, 0x02, 0x00, 0xF0, 0x00, 0x0A, 0x00,
  0x07, 0x00, 0xEA, 0x00, 0x21, 0x00, 0x00, 0x00, 0x00, 0xF1, 0x3B, 0x00, 0xE0, 0x00, 0x01, 0x00,
  0x00, 0x00, 0xC8, 0xF3, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x01, 0x00,
  0x09, 0x08, 0x11, 0x00, 0x02, 0x00, 0xC6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00,
  0x03, 0x00, 0xBA, 0x07, 0x37, 0x00, 0x06, 0x00, 0x48, 0x09, 0x21, 0x00, 0x02, 0x07, 0x37, 0x09,
  0x2F, 0x00, 0x04, 0x00, 0x01, 0x00, 0x09, 0x09, 0x3F, 0x00, 0x0C, 0x00, 0x00, 0x08, 0x00, 0x00,
  0x01, 0x42, 0x80, 0x00, 0x00, 0x00, 0x00, 0x09, 0x6D, 0x00, 0x06, 0x00, 0x80, 0x10, 0x0E, 0x30,
  0x00, 0x0A, 0x16, 0x00, 0x14, 0x00, 0x04, 0x00, 0x10, 0x00, 0x04, 0x80, 0x08, 0x00, 0x03, 0x40,
  0x01, 0x00, 0x02, 0x80, 0x04, 0x00, 0x05, 0x40, 0x02, 0x09, 0x8D, 0x00, 0x04, 0x00, 0x00, 0x00,
  0x10, 0x06, 0xA2, 0x00, 0x05, 0x00, 0x30, 0x09, 0x21, 0x00, 0x02, 0x06, 0xA2, 0x09, 0x2F, 0x00,
  0x04, 0x00, 0x01, 0x00, 0x09, 0x09, 0x3F, 0x00, 0x0C, 0x00, 0x00, 0x08, 0x00, 0x00, 0x01, 0x42,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x09, 0x6D, 0x00, 0x06, 0x00, 0x20, 0x10, 0x0C, 0x80, 0x00, 0x09,
  0x8D, 0x00, 0x04, 0x00, 0x00, 0x00, 0x40, 0x07, 0x41, 0x00, 0x05, 0x00, 0x30, 0x09, 0x21, 0x00,
  0x02, 0x07, 0x41, 0x09, 0x2F, 0x00, 0x04, 0x00, 0x01, 0x00, 0x09, 0x09, 0x3F, 0x00, 0x0C, 0x00,
  0x00, 0x08, 0x00, 0x00, 0x01, 0x42, 0x80, 0x00, 0x00, 0x00, 0x00, 0x09, 0x6D, 0x00, 0x06, 0x00,
  0x10, 0x10, 0x0C, 0x80, 0x00, 0x09, 0x8D, 0x00, 0x04, 0x00, 0x00, 0x00, 0x80, 0x8F, 0x54, 0xC1,
};

static uint8_t ksimulate_numeric_observed_value[] = {
  // First message
  0xC0, 0x11, 0x01, 0x03, 0x5C, 0xE1, 0x00, 0x00, 0x02, 0x00, 0x05, 0x03, 0x54, 0x01, 0x01, 0x00,
  0x05, 0x00, 0x07, 0x03, 0x4C, 0x00, 0x21, 0x00, 0x00, 0x00, 0x00, 0xF1, 0x3B, 0x03, 0x42, 0x00,
  0x03, 0x00, 0x00, 0x00, 0xC9, 0x33, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00,
  0x01, 0x00, 0x06, 0x00, 0x00, 0x00, 0x02, 0x03, 0x28, 0x00, 0x00, 0x00, 0x07, 0x02, 0x0E, 0x86,
  0x61, 0x00, 0x07, 0x00, 0x46, 0x09, 0x21, 0x00, 0x02, 0x86, 0x61, 0x09, 0x2F, 0x00, 0x04, 0x00,
  0x01, 0x00, 0x06, 0x09, 0x3F, 0x00, 0x0C, 0x00, 0x00, 0x20, 0x00, 0x00, 0x01, 0x42, 0x28, 0x00,
  0x00, 0x00, 0x00, 0x09, 0x24, 0x00, 0x04, 0x00, 0x02, 0x58, 0x04, 0x09, 0x27, 0x00, 0x10, 0x00,
  0x0E, 0x00, 0x43, 0x00, 0x50, 0x00, 0x50, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x00, 0x09,
  0x17, 0x00, 0x02, 0x03, 0x00, 0x09, 0x11, 0x00, 0x02, 0x00, 0x05, 0x86, 0x7A, 0x00, 0x07, 0x00,
  0x46, 0x09, 0x21, 0x00, 0x02, 0x86, 0x7A, 0x09, 0x2F, 0x00, 0x04, 0x00, 0x01, 0x00, 0x06, 0x09,
  0x3F, 0x00, 0x0C, 0x00, 0x00, 0x20, 0x00, 0x00, 0x01, 0x42, 0x28, 0x00, 0x00, 0x00, 0x00, 0x09,
  0x24, 0x00, 0x04, 0x00, 0x02, 0x4B, 0x28, 0x09, 0x27, 0x00, 0x10, 0x00, 0x0E, 0x00, 0x53, 0x00,
  0x56, 0x00, 0x52, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x00, 0x09, 0x17, 0x00, 0x02, 0x04,
  0x00, 0x09, 0x11, 0x00, 0x02, 0x00, 0x02, 0x86, 0x93, 0x00, 0x07, 0x00, 0x46, 0x09, 0x21, 0x00,
  0x02, 0x86, 0x93, 0x09, 0x2F, 0x00, 0x04, 0x00, 0x01, 0x00, 0x06, 0x09, 0x3F, 0x00, 0x0C, 0x00,
  0x00, 0x20, 0x00, 0x00, 0x01, 0x42, 0x28, 0x00, 0x00, 0x00, 0x00, 0x09, 0x24, 0x00, 0x04, 0x00,
  0x02, 0x4B, 0xC4, 0x09, 0x27, 0x00, 0x10, 0x00, 0x0E, 0x03, 0x94, 0x00, 0x53, 0x00, 0x70, 0x00,
  0x4F, 0x20, 0x82, 0x00, 0x20, 0x00, 0x00, 0x09, 0x17, 0x00, 0x02, 0x04, 0x00, 0x09, 0x11, 0x00,
  0x02, 0x00, 0x02, 0x86, 0xAC, 0x00, 0x07, 0x00, 0x46, 0x09, 0x21, 0x00, 0x02, 0x86, 0xAC, 0x09,
  0x2F, 0x00, 0x04, 0x00, 0x01, 0x00, 0x06, 0x09, 0x3F, 0x00, 0x0C, 0x00, 0x00, 0x20, 0x00, 0x00,
  0x01, 0x42, 0x28, 0x00, 0x00, 0x00, 0x00, 0x09, 0x24, 0x00, 0x04, 0x00, 0x02, 0xE0, 0x18, 0x09,
  0x27, 0x00, 0x10, 0x00, 0x0E, 0x03, 0x94, 0x00, 0x54, 0x00, 0x65, 0x00, 0x6D, 0x00, 0x70, 0x00,
  0x20, 0x00, 0x00, 0x09, 0x17, 0x00, 0x02, 0x03, 0x01, 0x09, 0x11, 0x00, 0x02, 0x00, 0x02, 0x86,
  0xC5, 0x00, 0x07, 0x00, 0x46, 0x09, 0x21, 0x00, 0x02, 0x86, 0xC5, 0x09, 0x2F, 0x00, 0x04, 0x00,
  0x01, 0x00, 0x06, 0x09, 0x3F, 0x00, 0x0C, 0x00, 0x00, 0x20, 0x00, 0x00, 0x01, 0x42, 0x28, 0x00,
  0x00, 0x00, 0x00, 0x09, 0x24, 0x00, 0x04, 0x00, 0x02, 0xF0, 0xE3, 0x09, 0x27, 0x00, 0x10, 0x00,
  0x0E, 0x00, 0x50, 0x00, 0x50, 0x00, 0x56, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x00, 0x09,
  0x17, 0x00, 0x02, 0x03, 0x00, 0x09, 0x11, 0x00, 0x02, 0x00, 0x01, 0x86, 0xDE, 0x00, 0x07, 0x00,
  0x46, 0x09, 0x21, 0x00, 0x02, 0x86, 0xDE, 0x09, 0x2F, 0x00, 0x04, 0x00, 0x01, 0x00, 0x06, 0x09,
  0x3F, 0x00, 0x0C, 0x00, 0x00, 0x20, 0x00, 0x00, 0x01, 0x42, 0x28, 0x00, 0x00, 0x00, 0x00, 0x09,
  0x24, 0x00, 0x04, 0x00, 0x02, 0xF0, 0x6C, 0x09, 0x27, 0x00, 0x10, 0x00, 0x0E, 0x00, 0x53, 0x00,
  0x70, 0x00, 0x2D, 0x00, 0x76, 0x00, 0x4F, 0x20, 0x82, 0x00, 0x00, 0x09, 0x17, 0x00, 0x02, 0x04,
  0x00, 0x09, 0x11, 0x00, 0x02, 0x00, 0x02, 0x87, 0x1E, 0x00, 0x06, 0x00, 0x40, 0x09, 0x21, 0x00,
  0x02, 0x87, 0x1E, 0x09, 0x2F, 0x00, 0x04, 0x00, 0x01, 0x00, 0x06, 0x09, 0x3F, 0x00, 0x0C, 0x00,
  0x00, 0x20, 0x00, 0x00, 0x05, 0x52, 0x28, 0x00, 0x00, 0x00, 0x00, 0x09, 0x24, 0x00, 0x04, 0x00,
  0x02, 0x4A, 0x24, 0x09, 0x27, 0x00, 0x10, 0x00, 0x0E, 0x00, 0x50, 0x00, 0x41, 0x00, 0x57, 0x00,
  0x50, 0x00, 0x20, 0x00, 0x20, 0x00, 0x00, 0x09, 0x11, 0x00, 0x02, 0x00, 0x03, 0x00, 0x01, 0x00,
  0x03, 0x01, 0x0E, 0x86, 0x9D, 0x00, 0x09, 0x00, 0x5A, 0x09, 0x21, 0x00, 0x02, 0x86, 0x9D, 0x09,
  0x2F, 0x00, 0x04, 0x00, 0x01, 0x00, 0x06, 0x09, 0x3F, 0x00, 0x0C, 0x00, 0x00, 0x20, 0x00, 0x00,
  0x01, 0x42, 0x28, 0x00, 0x00, 0x00, 0x00, 0x09, 0x24, 0x00, 0x04, 0x00, 0x02, 0x4B, 0xB8, 0x09,
  0x27, 0x00, 0x10, 0x00, 0x0E, 0x00, 0x53, 0x00, 0x70, 0x00, 0x4F, 0x20, 0x82, 0x00, 0x20, 0x00,
  0x20, 0x00, 0x00, 0x09, 0x17, 0x00, 0x02, 0x03, 0x00, 0x09, 0x11, 0x00, 0x02, 0x00, 0x06, 0xF0,
  0x08, 0x00, 0x02, 0x06, 0x40, 0x09, 0x50, 0x00, 0x0A, 0x4B, 0xB8, 0x00, 0x00, 0x02, 0x20, 0xFF,
  0x00, 0x03, 0xD6, 0x86, 0xA6, 0x00, 0x07, 0x00, 0x4E, 0x09, 0x21, 0x00, 0x02, 0x86, 0xA6, 0x09,
  0x2F, 0x00, 0x04, 0x00, 0x01, 0x00, 0x06, 0x09, 0x3F, 0x00, 0x0C, 0x00, 0x00, 0x20, 0x00, 0x00,
  0x01, 0x42, 0x28, 0x00, 0x00, 0x00, 0x00, 0x09, 0x24, 0x00, 0x04, 0x00, 0x02, 0x48, 0x22, 0x09,
  0x27, 0x00, 0x10, 0x00, 0x0E, 0x00, 0x50, 0x00, 0x75, 0x00, 0x6C, 0x00, 0x73, 0x00, 0x65, 0x00,
  0x20, 0x00, 0x00, 0x09, 0x11, 0x00, 0x02, 0x00, 0x06, 0x09, 0x50, 0x00, 0x0A, 0x48, 0x22, 0x00,
  0x01, 0x0A, 0xA0, 0x00, 0x00, 0x00, 0x3C, 0x86, 0xAD, 0x00, 0x08, 0x00, 0x54, 0x09, 0x21, 0x00,
  0x02, 0x86, 0xAD, 0x09, 0x2F, 0x00, 0x04, 0x00, 0x01, 0x00, 0x06, 0x09, 0x3F, 0x00, 0x0C, 0x00,
  0x00, 0x20, 0x00, 0x00, 0x01, 0x42, 0x28, 0x00, 0x00, 0x00, 0x00, 0x09, 0x24, 0x00, 0x04, 0x00,
  0x02, 0x4B, 0xB0, 0x09, 0x27, 0x00, 0x10, 0x00, 0x0E, 0x00, 0x50, 0x00, 0x65, 0x00, 0x72, 0x00,
  0x66, 0x00, 0x20, 0x00, 0x20, 0x00, 0x00, 0x09, 0x17, 0x00, 0x02, 0x02, 0x01, 0x09, 0x11, 0x00,
  0x02, 0x00, 0x06, 0x09, 0x50, 0x00, 0x0A, 0x4B, 0xB0, 0x00, 0x00, 0x02, 0x00, 0xFF, 0x00, 0x00,
  0x17, 0x1C, 0xEC, 0xC1,
  // Second message
  0xC0, 0x11, 0x01, 0x03, 0xE2, 0xE1, 0x00, 0x00, 0x02, 0x00, 0x05, 0x03, 0xDA, 0x02, 0x02, 0x00,
  0x05, 0x00, 0x07, 0x03, 0xD2, 0x00, 0x21, 0x00, 0x00, 0x00, 0x00, 0xF1, 0x3B, 0x03, 0xC8, 0x00,
  0x03, 0x00, 0x00, 0x00, 0xC9, 0x33, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00,
  0x01, 0x00, 0x06, 0x00, 0x00, 0x00, 0x01, 0x03, 0xAE, 0x00, 0x01, 0x00, 0x0A, 0x03, 0xA8, 0x87,
  0x09, 0x00, 0x0A, 0x00, 0x82, 0x09, 0x21, 0x00, 0x02, 0x87, 0x09, 0x09, 0x2F, 0x00, 0x04, 0x00,
  0x01, 0x00, 0x06, 0x09, 0x3F, 0x00, 0x0C, 0x00, 0x00, 0x20, 0x00, 0x00, 0x01, 0x52, 0x28, 0x01,
  0x03, 0x00, 0x00, 0x09, 0x24, 0x00, 0x04, 0x00, 0x02, 0x4A, 0x04, 0x09, 0x27, 0x00, 0x10, 0x00,
  0x0E, 0x00, 0x4E, 0x00, 0x42, 0x00, 0x50, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x00, 0x09,
  0x11, 0x00, 0x02, 0x00, 0x05, 0x09, 0x90, 0x00, 0x08, 0x20, 0x14, 0x06, 0x24, 0x14, 0x03, 0x06,
  0x00, 0xF2, 0x37, 0x00, 0x04, 0x00, 0x00, 0x9C, 0x40, 0xF9, 0x98, 0x00, 0x04, 0x00, 0xB8, 0x91,
  0x00, 0x09, 0x4B, 0x00, 0x22, 0x00, 0x03, 0x00, 0x1E, 0x4A, 0x05, 0x00, 0x00, 0x0F, 0x20, 0x00,
  0x00, 0x00, 0x7A, 0x4A, 0x06, 0x00, 0x00, 0x0F, 0x20, 0x00, 0x00, 0x00, 0x52, 0x4A, 0x07, 0x00,
  0x00, 0x0F, 0x20, 0x00, 0x00, 0x00, 0x5B, 0x87, 0x0C, 0x00, 0x0A, 0x00, 0x68, 0x09, 0x21, 0x00,
  0x02, 0x87, 0x0C, 0x09, 0x2F, 0x00, 0x04, 0x00, 0x01, 0x00, 0x06, 0x09, 0x3F, 0x00, 0x0C, 0x00,
  0x00, 0x20, 0x00, 0x00, 0x01, 0x52, 0x28, 0x00, 0x01, 0x00, 0x00, 0x09, 0x24, 0x00, 0x04, 0x00,
  0x02, 0xF0, 0xE5, 0x09, 0x27, 0x00, 0x10, 0x00, 0x0E, 0x00, 0x50, 0x00, 0x75, 0x00, 0x6C, 0x00,
  0x73, 0x00, 0x65, 0x00, 0x20, 0x00, 0x00, 0x09, 0x17, 0x00, 0x02, 0x03, 0x00, 0x09, 0x11, 0x00,
  0x02, 0x00, 0x05, 0x09, 0x90, 0x00, 0x08, 0x20, 0x14, 0x06, 0x24, 0x14, 0x03, 0x06, 0x00, 0xF9,
  0x98, 0x00, 0x04, 0x00, 0xB8, 0x91, 0x00, 0x09, 0x50, 0x00, 0x0A, 0xF0, 0xE5, 0x00, 0x00, 0x0A,
  0xA0, 0x00, 0x00, 0x00, 0x3C, 0x87, 0x3C, 0x00, 0x07, 0x00, 0x4E, 0x09, 0x21, 0x00, 0x02, 0x87,
  0x3C, 0x09, 0x2F, 0x00, 0x04, 0x00, 0x01, 0x00, 0x06, 0x09, 0x3F, 0x00, 0x0C, 0x00, 0x00, 0x20,
  0x00, 0x00, 0x01, 0x42, 0x28, 0x00, 0x00, 0x00, 0x00, 0x09, 0x24, 0x00, 0x04, 0x00, 0x02, 0x41,
  0x82, 0x09, 0x27, 0x00, 0x10, 0x00, 0x0E, 0x00, 0x48, 0x00, 0x52, 0x00, 0x20, 0x00, 0x20, 0x00,
  0x20, 0x00, 0x20, 0x00, 0x00, 0x09, 0x11, 0x00, 0x02, 0x00, 0x02, 0x09, 0x50, 0x00, 0x0A, 0x41,
  0x82, 0x00, 0x00, 0x0A, 0xA0, 0x00, 0x00, 0x00, 0x3C, 0x87, 0x43, 0x00, 0x07, 0x00, 0x4E, 0x09,
  0x21, 0x00, 0x02, 0x87, 0x43, 0x09, 0x2F, 0x00, 0x04, 0x00, 0x01, 0x00, 0x06, 0x09, 0x3F, 0x00,
  0x0C, 0x00, 0x00, 0x20, 0x00, 0x00, 0x01, 0x42, 0x28, 0x00, 0x00, 0x00, 0x00, 0x09, 0x24, 0x00,
  0x04, 0x00, 0x02, 0x50, 0x0A, 0x09, 0x27, 0x00, 0x10, 0x00, 0x0E, 0x00, 0x52, 0x00, 0x52, 0x00,
  0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x00, 0x09, 0x11, 0x00, 0x02, 0x00, 0x07, 0x09,
  0x50, 0x00, 0x0A, 0x50, 0x0A, 0x00, 0x00, 0x0A, 0xE0, 0x00, 0x00, 0x00, 0x14, 0x87, 0x48, 0x00,
  0x08, 0x00, 0xC8, 0x09, 0x21, 0x00, 0x02, 0x87, 0x48, 0x09, 0x2F, 0x00, 0x04, 0x00, 0x01, 0x00,
  0x06, 0x09, 0x3F, 0x00, 0x0C, 0x00, 0x00, 0x20, 0x00, 0x00, 0x01, 0x42, 0x28, 0x01, 0x0C, 0x00,
  0x00, 0x09, 0x24, 0x00, 0x04, 0x00, 0x02, 0x03, 0x00, 0x09, 0x27, 0x00, 0x10, 0x00, 0x0E, 0x00,
  0x53, 0x00, 0x54, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x00, 0x09, 0x11, 0x00,
  0x02, 0x00, 0x02, 0x09, 0x4B, 0x00, 0x7C, 0x00, 0x0C, 0x00, 0x78, 0x03, 0x01, 0x00, 0x00, 0x05,
  0x12, 0xFF, 0x00, 0x00, 0x00, 0x03, 0x02, 0x00, 0x00, 0x05, 0x12, 0xFF, 0x00, 0x00, 0x00, 0x03,
  0x3D, 0x00, 0x00, 0x05, 0x12, 0xFF, 0x00, 0x00, 0x00, 0x03, 0x3E, 0x00, 0x00, 0x05, 0x12, 0xFF,
  0x00, 0x00, 0x00, 0x03, 0x3F, 0x00, 0x00, 0x05, 0x12, 0xFF, 0x00, 0x00, 0x00, 0x03, 0x40, 0x00,
  0x00, 0x05, 0x12, 0xFF, 0x00, 0x00, 0x00, 0x03, 0x03, 0x00, 0x00, 0x05, 0x12, 0xFF, 0x00, 0x00,
  0x00, 0x03, 0x04, 0x00, 0x00, 0x05, 0x12, 0xFF, 0x00, 0x00, 0x00, 0x03, 0x05, 0x00, 0x00, 0x05,
  0x12, 0xFF, 0x00, 0x00, 0x00, 0x03, 0x06, 0x00, 0x00, 0x05, 0x12, 0xFF, 0x00, 0x00, 0x00, 0x03,
  0x07, 0x00, 0x00, 0x05, 0x12, 0xFF, 0x00, 0x00, 0x00, 0x03, 0x08, 0x00, 0x00, 0x05, 0x12, 0xFF,
  0x00, 0x00, 0x00, 0x09, 0x91, 0x00, 0x04, 0x00, 0xC7, 0xB1, 0x00, 0x87, 0x4E, 0x00, 0x03, 0x00,
  0x1E, 0x09, 0x21, 0x00, 0x02, 0x87, 0x4E, 0x09, 0x2F, 0x00, 0x04, 0x00, 0x01, 0x00, 0x06, 0x09,
  0x3F, 0x00, 0x0C, 0x00, 0x00, 0x20, 0x00, 0x00, 0x01, 0x24, 0x00, 0x01, 0x0C, 0x00, 0x80, 0x87,
  0x50, 0x00, 0x06, 0x00, 0x40, 0x09, 0x21, 0x00, 0x02, 0x87, 0x50, 0x09, 0x2F, 0x00, 0x04, 0x00,
  0x01, 0x00, 0x06, 0x09, 0x3F, 0x00, 0x0C, 0x00, 0x00, 0x20, 0x00, 0x00, 0x05, 0x42, 0x28, 0x00,
  0x00, 0x00, 0x00, 0x09, 0x24, 0x00, 0x04, 0x00, 0x02, 0xF0, 0x3D, 0x09, 0x27, 0x00, 0x10, 0x00,
  0x0E, 0x00, 0x53, 0x00, 0x54, 0x00, 0x69, 0x00, 0x6E, 0x00, 0x64, 0x00, 0x78, 0x00, 0x00, 0x09,
  0x11, 0x00, 0x02, 0x00, 0x02, 0x87, 0x55, 0x00, 0x06, 0x00, 0x40, 0x09, 0x21, 0x00, 0x02, 0x87,
  0x55, 0x09, 0x2F, 0x00, 0x04, 0x00, 0x01, 0x00, 0x06, 0x09, 0x3F, 0x00, 0x0C, 0x00, 0x00, 0x20,
  0x00, 0x00, 0x01, 0x42, 0x28, 0x00, 0x00, 0x00, 0x00, 0x09, 0x24, 0x00, 0x04, 0x00, 0x02, 0x42,
  0x61, 0x09, 0x27, 0x00, 0x10, 0x00, 0x0E, 0x00, 0x50, 0x00, 0x56, 0x00, 0x43, 0x00, 0x20, 0x00,
  0x20, 0x00, 0x20, 0x00, 0x00, 0x09, 0x11, 0x00, 0x02, 0x00, 0x02, 0x87, 0x62, 0x00, 0x06, 0x00,
  0x40, 0x09, 0x21, 0x00, 0x02, 0x87, 0x62, 0x09, 0x2F, 0x00, 0x04, 0x00, 0x01, 0x00, 0x06, 0x09,
  0x3F, 0x00, 0x0C, 0x00, 0x00, 0x20, 0x00, 0x00, 0x01, 0x42, 0x28, 0x00, 0x00, 0x00, 0x00, 0x09,
  0x24, 0x00, 0x04, 0x00, 0x02, 0x3F, 0x20, 0x09, 0x27, 0x00, 0x10, 0x00, 0x0E, 0x00, 0x51, 0x00,
  0x54, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x00, 0x09, 0x11, 0x00, 0x02, 0x00,
  0x02, 0x87, 0x64, 0x00, 0x06, 0x00, 0x40, 0x09, 0x21, 0x00, 0x02, 0x87, 0x64, 0x09, 0x2F, 0x00,
  0x04, 0x00, 0x01, 0x00, 0x06, 0x09, 0x3F, 0x00, 0x0C, 0x00, 0x00, 0x20, 0x00, 0x00, 0x01, 0x42,
  0x28, 0x00, 0x00, 0x00, 0x00, 0x09, 0x24, 0x00, 0x04, 0x00, 0x02, 0x3F, 0x24, 0x09, 0x27, 0x00,
  0x10, 0x00, 0x0E, 0x00, 0x51, 0x00, 0x54, 0x00, 0x63, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00,
  0x00, 0x09, 0x11, 0x00, 0x02, 0x00, 0x02, 0xEF, 0x34, 0xC1,
  // Third message
  0xC0, 0x11, 0x01, 0x02, 0xEC, 0xE1, 0x00, 0x00, 0x02, 0x00, 0x05, 0x02, 0xE4, 0x02, 0x03, 0x00,
  0x05, 0x00, 0x07, 0x02, 0xDC, 0x00, 0x21, 0x00, 0x00, 0x00, 0x00, 0xF1, 0x3B, 0x02, 0xD2, 0x00,
  0x03, 0x00, 0x00, 0x00, 0xC9, 0x33, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00,
  0x01, 0x00, 0x06, 0x00, 0x00, 0x00, 0x01, 0x02, 0xB8, 0x00, 0x01, 0x00, 0x0A, 0x02, 0xB2, 0x87,
  0x66, 0x00, 0x06, 0x00, 0x40, 0x09, 0x21, 0x00, 0x02, 0x87, 0x66, 0x09, 0x2F, 0x00, 0x04, 0x00,
  0x01, 0x00, 0x06, 0x09, 0x3F, 0x00, 0x0C, 0x00, 0x00, 0x20, 0x00, 0x00, 0x01, 0x42, 0x28, 0x00,
  0x00, 0x00, 0x00, 0x09, 0x24, 0x00, 0x04, 0x00, 0x02, 0xF1, 0x56, 0x09, 0x27, 0x00, 0x10, 0x00,
  0x0E, 0x03, 0x94, 0x00, 0x51, 0x00, 0x54, 0x00, 0x63, 0x00, 0x20, 0x00, 0x20, 0x00, 0x00, 0x09,
  0x11, 0x00, 0x02, 0x00, 0x02, 0x87, 0x68, 0x00, 0x06, 0x00, 0x40, 0x09, 0x21, 0x00, 0x02, 0x87,
  0x68, 0x09, 0x2F, 0x00, 0x04, 0x00, 0x01, 0x00, 0x06, 0x09, 0x3F, 0x00, 0x0C, 0x00, 0x00, 0x20,
  0x00, 0x00, 0x01, 0x42, 0x28, 0x00, 0x00, 0x00, 0x00, 0x09, 0x24, 0x00, 0x04, 0x00, 0x02, 0xF1,
  0x54, 0x09, 0x27, 0x00, 0x10, 0x00, 0x0E, 0x00, 0x51, 0x00, 0x54, 0x00, 0x2D, 0x00, 0x48, 0x00,
  0x52, 0x00, 0x20, 0x00, 0x00, 0x09, 0x11, 0x00, 0x02, 0x00, 0x02, 0x87, 0x6C, 0x00, 0x03, 0x00,
  0x1E, 0x09, 0x21, 0x00, 0x02, 0x87, 0x6C, 0x09, 0x2F, 0x00, 0x04, 0x00, 0x01, 0x00, 0x06, 0x09,
  0x3F, 0x00, 0x0C, 0x00, 0x00, 0x20, 0x00, 0x00, 0x01, 0x24, 0x00, 0x00, 0x00, 0x00, 0x80, 0x87,
  0x6E, 0x00, 0x03, 0x00, 0x1E, 0x09, 0x21, 0x00, 0x02, 0x87, 0x6E, 0x09, 0x2F, 0x00, 0x04, 0x00,
  0x01, 0x00, 0x06, 0x09, 0x3F, 0x00, 0x0C, 0x00, 0x00, 0x20, 0x00, 0x00, 0x01, 0x24, 0x00, 0x00,
  0x00, 0x00, 0x80, 0x87, 0x7D, 0xE0, 0x00, 0x07, 0x00, 0x46, 0x09, 0x21, 0x00, 0x02, 0x87, 0x7D,
  0xE0, 0x09, 0x2F, 0x00, 0x04, 0x00, 0x01, 0x00, 0x06, 0x09, 0x3F, 0x00, 0x0C, 0x00, 0x00, 0x20,
  0x00, 0x00, 0x01, 0x42, 0x28, 0x00, 0x00, 0x00, 0x00, 0x09, 0x24, 0x00, 0x04, 0x00, 0x02, 0x4B,
  0x48, 0x09, 0x27, 0x00, 0x10, 0x00, 0x0E, 0x00, 0x54, 0x00, 0x65, 0x00, 0x6D, 0x00, 0x70, 0x00,
  0x20, 0x00, 0x20, 0x00, 0x00, 0x09, 0x17, 0x00, 0x02, 0x02, 0x01, 0x09, 0x11, 0x00, 0x02, 0x00,
  0x0A, 0x88, 0x06, 0x00, 0x07, 0x00, 0x66, 0x09, 0x21, 0x00, 0x02, 0x88, 0x06, 0x09, 0x2F, 0x00,
  0x04, 0x00, 0x01, 0x00, 0x06, 0x09, 0x3F, 0x00, 0x0C, 0x00, 0x00, 0x20, 0x00, 0x00, 0x01, 0x42,
  0x28, 0x01, 0x03, 0x00, 0x00, 0x09, 0x24, 0x00, 0x04, 0x00, 0x02, 0x4A, 0x14, 0x09, 0x27, 0x00,
  0x10, 0x00, 0x0E, 0x00, 0x41, 0x00, 0x42, 0x00, 0x50, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00,
  0x00, 0x09, 0x11, 0x00, 0x02, 0x00, 0x01, 0x09, 0x4B, 0x00, 0x22, 0x00, 0x03, 0x00, 0x1E, 0x4A,
  0x17, 0x00, 0x00, 0x0F, 0x20, 0x00, 0x00, 0x00, 0x5F, 0x4A, 0x15, 0x00, 0x00, 0x0F, 0x20, 0x00,
  0x00, 0x00, 0x78, 0x4A, 0x16, 0x00, 0x00, 0x0F, 0x20, 0x00, 0x00, 0x00, 0x50, 0x88, 0x0D, 0x00,
  0x07, 0x00, 0x4E, 0x09, 0x21, 0x00, 0x02, 0x88, 0x0D, 0x09, 0x2F, 0x00, 0x04, 0x00, 0x01, 0x00,
  0x06, 0x09, 0x3F, 0x00, 0x0C, 0x00, 0x00, 0x20, 0x00, 0x00, 0x01, 0x42, 0x28, 0x00, 0x00, 0x00,
  0x00, 0x09, 0x24, 0x00, 0x04, 0x80, 0x03, 0x54, 0x02, 0x09, 0x27, 0x00, 0x10, 0x00, 0x0E, 0x00,
  0x50, 0x00, 0x75, 0x00, 0x6C, 0x00, 0x73, 0x00, 0x65, 0x00, 0x20, 0x00, 0x00, 0x09, 0x11, 0x00,
  0x02, 0x00, 0x01, 0x09, 0x50, 0x00, 0x0A, 0x48, 0x0A, 0x00, 0x01, 0x0A, 0xA0, 0x00, 0x00, 0x00,
  0x3C, 0x88, 0x2D, 0x00, 0x06, 0x00, 0x40, 0x09, 0x21, 0x00, 0x02, 0x88, 0x2D, 0x09, 0x2F, 0x00,
  0x04, 0x00, 0x01, 0x00, 0x06, 0x09, 0x3F, 0x00, 0x0C, 0x00, 0x00, 0x20, 0x00, 0x00, 0x01, 0x42,
  0x28, 0x01, 0x03, 0x00, 0x00, 0x09, 0x24, 0x00, 0x04, 0x00, 0x02, 0x4A, 0x44, 0x09, 0x27, 0x00,
  0x10, 0x00, 0x0E, 0x00, 0x43, 0x00, 0x56, 0x00, 0x50, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00,
  0x00, 0x09, 0x11, 0x00, 0x02, 0x00, 0x04, 0x88, 0x34, 0x00, 0x06, 0x00, 0x40, 0x09, 0x21, 0x00,
  0x02, 0x88, 0x34, 0x09, 0x2F, 0x00, 0x04, 0x00, 0x01, 0x00, 0x06, 0x09, 0x3F, 0x00, 0x0C, 0x00,
  0x00, 0x20, 0x00, 0x00, 0x01, 0x42, 0x28, 0x00, 0x00, 0x00, 0x00, 0x09, 0x24, 0x00, 0x04, 0x80,
  0x03, 0x54, 0x06, 0x09, 0x27, 0x00, 0x10, 0x00, 0x0E, 0x00, 0x50, 0x00, 0x75, 0x00, 0x6C, 0x00,
  0x73, 0x00, 0x65, 0x00, 0x20, 0x00, 0x00, 0x09, 0x11, 0x00, 0x02, 0x00, 0x04, 0x88, 0x54, 0x00,
  0x06, 0x00, 0x40, 0x09, 0x21, 0x00, 0x02, 0x88, 0x54, 0x09, 0x2F, 0x00, 0x04, 0x00, 0x01, 0x00,
  0x06, 0x09, 0x3F, 0x00, 0x0C, 0x00, 0x00, 0x20, 0x00, 0x00, 0x01, 0x42, 0x28, 0x01, 0x03, 0x00,
  0x00, 0x09, 0x24, 0x00, 0x04, 0x00, 0x02, 0x4A, 0x1C, 0x09, 0x27, 0x00, 0x10, 0x00, 0x0E, 0x00,
  0x50, 0x00, 0x41, 0x00, 0x50, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x00, 0x09, 0x11, 0x00,
  0x02, 0x00, 0x03, 0x08, 0x09, 0xC1,
  // fourth message
  0xC0, 0x11, 0x01, 0x01, 0xF0, 0xE1, 0x00, 0x00, 0x02, 0x00, 0x05, 0x01, 0xE8, 0x03, 0x04, 0x00,
  0x05, 0x00, 0x07, 0x01, 0xE0, 0x00, 0x21, 0x00, 0x00, 0x00, 0x00, 0xF1, 0x3B, 0x01, 0xD6, 0x00,
  0x03, 0x00, 0x00, 0x00, 0xC9, 0x33, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00,
  0x01, 0x00, 0x06, 0x00, 0x00, 0x00, 0x01, 0x01, 0xBC, 0x00, 0x01, 0x00, 0x06, 0x01, 0xB6, 0x88,
  0x5B, 0x00, 0x06, 0x00, 0x40, 0x09, 0x21, 0x00, 0x02, 0x88, 0x5B, 0x09, 0x2F, 0x00, 0x04, 0x00,
  0x01, 0x00, 0x06, 0x09, 0x3F, 0x00, 0x0C, 0x00, 0x00, 0x20, 0x00, 0x00, 0x01, 0x42, 0x28, 0x00,
  0x00, 0x00, 0x00, 0x09, 0x24, 0x00, 0x04, 0x80, 0x03, 0x54, 0x05, 0x09, 0x27, 0x00, 0x10, 0x00,
  0x0E, 0x00, 0x50, 0x00, 0x75, 0x00, 0x6C, 0x00, 0x73, 0x00, 0x65, 0x00, 0x20, 0x00, 0x00, 0x09,
  0x11, 0x00, 0x02, 0x00, 0x03, 0x88, 0x94, 0x00, 0x07, 0x00, 0x46, 0x09, 0x21, 0x00, 0x02, 0x88,
  0x94, 0x09, 0x2F, 0x00, 0x04, 0x00, 0x01, 0x00, 0x06, 0x09, 0x3F, 0x00, 0x0C, 0x00, 0x00, 0x20,
  0x00, 0x00, 0x01, 0x42, 0x28, 0x01, 0x02, 0x00, 0x00, 0x09, 0x24, 0x00, 0x04, 0x00, 0x02, 0x50,
  0xAC, 0x09, 0x27, 0x00, 0x10, 0x00, 0x0E, 0x00, 0x43, 0x00, 0x4F, 0x20, 0x82, 0x00, 0x20, 0x00,
  0x20, 0x00, 0x20, 0x00, 0x00, 0x09, 0x17, 0x00, 0x02, 0x03, 0x00, 0x09, 0x11, 0x00, 0x02, 0x00,
  0x07, 0x88, 0x9A, 0x00, 0x07, 0x00, 0x46, 0x09, 0x21, 0x00, 0x02, 0x88, 0x9A, 0x09, 0x2F, 0x00,
  0x04, 0x00, 0x01, 0x00, 0x06, 0x09, 0x3F, 0x00, 0x0C, 0x00, 0x00, 0x20, 0x00, 0x00, 0x01, 0x42,
  0x28, 0x00, 0x00, 0x00, 0x00, 0x09, 0x24, 0x00, 0x04, 0x00, 0x02, 0x50, 0x12, 0x09, 0x27, 0x00,
  0x10, 0x00, 0x0E, 0x00, 0x61, 0x00, 0x77, 0x00, 0x52, 0x00, 0x52, 0x00, 0x20, 0x00, 0x20, 0x00,
  0x00, 0x09, 0x17, 0x00, 0x02, 0x03, 0x00, 0x09, 0x11, 0x00, 0x02, 0x00, 0x07, 0x89, 0x0E, 0x00,
  0x07, 0x00, 0x46, 0x09, 0x21, 0x00, 0x02, 0x89, 0x0E, 0x09, 0x2F, 0x00, 0x04, 0x00, 0x01, 0x00,
  0x06, 0x09, 0x3F, 0x00, 0x0C, 0x00, 0x00, 0x20, 0x00, 0x00, 0x01, 0x42, 0x28, 0x00, 0x00, 0x00,
  0x00, 0x09, 0x24, 0x00, 0x04, 0x00, 0x02, 0xE0, 0x14, 0x09, 0x27, 0x00, 0x10, 0x00, 0x0E, 0x00,
  0x54, 0x00, 0x62, 0x00, 0x6C, 0x00, 0x6F, 0x00, 0x6F, 0x00, 0x64, 0x00, 0x00, 0x09, 0x17, 0x00,
  0x02, 0x02, 0x01, 0x09, 0x11, 0x00, 0x02, 0x00, 0x03, 0x89, 0x24, 0x00, 0x06, 0x00, 0x40, 0x09,
  0x21, 0x00, 0x02, 0x89, 0x24, 0x09, 0x2F, 0x00, 0x04, 0x00, 0x01, 0x00, 0x06, 0x09, 0x3F, 0x00,
  0x0C, 0x00, 0x00, 0x20, 0x00, 0x00, 0x01, 0xD2, 0x28, 0x00, 0x00, 0x00, 0x00, 0x09, 0x24, 0x00,
  0x04, 0x00, 0x02, 0x4B, 0x04, 0x09, 0x27, 0x00, 0x10, 0x00, 0x0E, 0x00, 0x43, 0x00, 0x2E, 0x00,
  0x4F, 0x00, 0x2E, 0x00, 0x20, 0x00, 0x20, 0x00, 0x00, 0x09, 0x11, 0x00, 0x02, 0x00, 0x03, 0x89,
  0x26, 0x00, 0x06, 0x00, 0x40, 0x09, 0x21, 0x00, 0x02, 0x89, 0x26, 0x09, 0x2F, 0x00, 0x04, 0x00,
  0x01, 0x00, 0x06, 0x09, 0x3F, 0x00, 0x0C, 0x00, 0x00, 0x20, 0x00, 0x00, 0x01, 0xD2, 0x28, 0x00,
  0x00, 0x00, 0x00, 0x09, 0x24, 0x00, 0x04, 0x00, 0x02, 0x49, 0x0C, 0x09, 0x27, 0x00, 0x10, 0x00,
  0x0E, 0x00, 0x43, 0x00, 0x2E, 0x00, 0x49, 0x00, 0x2E, 0x00, 0x20, 0x00, 0x20, 0x00, 0x00, 0x09,
  0x11, 0x00, 0x02, 0x00, 0x03, 0x0D, 0x4A, 0xC1,
  // Last message
  0xC0, 0x11, 0x01, 0x00, 0x32, 0xE1, 0x00, 0x00, 0x02, 0x00, 0x02, 0x00, 0x2A, 0x00, 0x05, 0x00,
  0x07, 0x00, 0x24, 0x00, 0x21, 0x00, 0x00, 0x00, 0x00, 0xF1, 0x3B, 0x00, 0x1A, 0x00, 0x03, 0x00,
  0x00, 0x00, 0xC9, 0x33, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x01, 0x00,
  0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xD4, 0xCF, 0xC1
};

static uint8_t ksimulate_rtsa_obs_val[] = {
  0xC0, 0x11, 0x01, 0x02, 0x64, 0xE1, 0x00, 0x00, 0x02, 0x00, 0x02, 0x02, 0x5C, 0x00, 0x01, 0x00,
  0x07, 0x02, 0x56, 0x00, 0x21, 0x00, 0x00, 0x00, 0x00, 0xF1, 0x3B, 0x02, 0x4C, 0x00, 0x04, 0x00,
  0x00, 0x00, 0xC8, 0xF0, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x01, 0x00,
  0x09, 0x00, 0x00, 0x00, 0x02, 0x02, 0x32, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00,
  0x03, 0x02, 0x26, 0x07, 0x37, 0x00, 0x01, 0x01, 0x0A, 0x09, 0x6E, 0x01, 0x06, 0x01, 0x02, 0x00,
  0x00, 0x01, 0x00, 0x1F, 0xFF, 0x20, 0x00, 0x20, 0x00, 0x20, 0x01, 0x20, 0x01, 0x20, 0x02, 0x20,
  0x02, 0x20, 0x03, 0x20, 0x03, 0x20, 0x04, 0x20, 0x04, 0x20, 0x05, 0x20, 0x05, 0x20, 0x06, 0x20,
  0x06, 0x20, 0x07, 0x20, 0x08, 0x20, 0x08, 0x20, 0x09, 0x20, 0x09, 0x20, 0x0A, 0x20, 0x0B, 0x20,
  0x0B, 0x20, 0x0C, 0x20, 0x0D, 0x20, 0x0E, 0x20, 0x0F, 0x20, 0x10, 0x20, 0x11, 0x20, 0x12, 0x20,
  0x13, 0x20, 0x14, 0x20, 0x15, 0x20, 0x17, 0x20, 0x18, 0x20, 0x19, 0x20, 0x1A, 0x20, 0x1B, 0x20,
  0x1B, 0x20, 0x1C, 0x20, 0x1C, 0x20, 0x1D, 0x20, 0x1D, 0x20, 0x1D, 0x20, 0x1C, 0x20, 0x1C, 0x20,
  0x1B, 0x20, 0x1A, 0x20, 0x1A, 0x20, 0x19, 0x20, 0x18, 0x20, 0x17, 0x20, 0x16, 0x20, 0x16, 0x20,
  0x15, 0x20, 0x14, 0x20, 0x12, 0x20, 0x10, 0x20, 0x0E, 0x20, 0x0C, 0x20, 0x09, 0x20, 0x07, 0x20,
  0x04, 0x20, 0x01, 0x1F, 0xFE, 0x1F, 0xFC, 0x1F, 0xF9, 0x1F, 0xF7, 0x1F, 0xF5, 0x1F, 0xF4, 0x1F,
  0xF3, 0x1F, 0xF1, 0x1F, 0xF0, 0x1F, 0xF0, 0x1F, 0xEF, 0x1F, 0xEF, 0x1F, 0xEF, 0x1F, 0xEF, 0x1F,
  0xEF, 0x1F, 0xEF, 0x1F, 0xEF, 0x1F, 0xEF, 0x1F, 0xEF, 0x1F, 0xEF, 0x1F, 0xEF, 0x1F, 0xEF, 0x1F,
  0xF0, 0x1F, 0xF0, 0x1F, 0xF0, 0x1F, 0xF0, 0x1F, 0xF0, 0x1F, 0xF0, 0x1F, 0xF0, 0x1F, 0xF0, 0x1F,
  0xF0, 0x1F, 0xF1, 0x1F, 0xF1, 0x1F, 0xF1, 0x1F, 0xF1, 0x1F, 0xF1, 0x1F, 0xF1, 0x1F, 0xF1, 0x1F,
  0xF1, 0x1F, 0xF1, 0x1F, 0xF1, 0x1F, 0xF1, 0x1F, 0xF1, 0x1F, 0xF1, 0x1F, 0xF1, 0x1F, 0xF1, 0x1F,
  0xF2, 0x1F, 0xF2, 0x1F, 0xF2, 0x1F, 0xF2, 0x1F, 0xF2, 0x1F, 0xF2, 0x1F, 0xF2, 0x1F, 0xF2, 0x1F,
  0xF2, 0x1F, 0xF2, 0x1F, 0xF2, 0x1F, 0xF2, 0x1F, 0xF2, 0x1F, 0xF2, 0x1F, 0xF2, 0x1F, 0xF2, 0x1F,
  0xF2, 0x1F, 0xF2, 0x06, 0xA2, 0x00, 0x0D, 0x00, 0xE0, 0x09, 0x21, 0x00, 0x02, 0x06, 0xA2, 0x09,
  0x2F, 0x00, 0x04, 0x00, 0x01, 0x00, 0x09, 0x09, 0x3F, 0x00, 0x0C, 0x00, 0x00, 0x08, 0x00, 0x00,
  0x01, 0x42, 0x80, 0x00, 0x00, 0x00, 0x00, 0x09, 0x6D, 0x00, 0x06, 0x00, 0x20, 0x10, 0x0C, 0x80,
  0x00, 0x09, 0x8D, 0x00, 0x04, 0x00, 0x00, 0x00, 0x40, 0x09, 0x24, 0x00, 0x04, 0x00, 0x02, 0x4B,
  0xB4, 0x09, 0x27, 0x00, 0x10, 0x00, 0x0E, 0x00, 0x50, 0x00, 0x6C, 0x00, 0x65, 0x00, 0x74, 0x00,
  0x68, 0x00, 0x20, 0x00, 0x00, 0x09, 0x96, 0x00, 0x02, 0x02, 0x00, 0x09, 0x11, 0x00, 0x02, 0x00,
  0x06, 0x09, 0x40, 0x00, 0x02, 0x00, 0x00, 0x09, 0x6F, 0x00, 0x0C, 0x00, 0x7F, 0xFF, 0xFF, 0x00,
  0x7F, 0xFF, 0xFF, 0x00, 0x00, 0x0F, 0xFF, 0x09, 0x1A, 0x00, 0x24, 0x00, 0x04, 0x00, 0x20, 0x00,
  0x7F, 0xFF, 0xFF, 0x04, 0x00, 0x00, 0x00, 0x00, 0x7F, 0xFF, 0xFF, 0x06, 0x00, 0x00, 0x01, 0x00,
  0x7F, 0xFF, 0xFF, 0x0A, 0x00, 0x00, 0x01, 0x00, 0x7F, 0xFF, 0xFF, 0x0C, 0x00, 0x00, 0x00, 0x09,
  0x6E, 0x00, 0x46, 0x4B, 0xB4, 0x00, 0x00, 0x00, 0x40, 0x04, 0x11, 0x04, 0x11, 0x04, 0x12, 0x04,
  0x13, 0x04, 0x13, 0x04, 0x13, 0x04, 0x14, 0x04, 0x14, 0x04, 0x15, 0x04, 0x17, 0x04, 0x1A, 0x04,
  0x1E, 0x04, 0x23, 0x04, 0x2A, 0x04, 0x30, 0x04, 0x35, 0x04, 0x3B, 0x04, 0x43, 0x04, 0x4C, 0x04,
  0x54, 0x04, 0x5B, 0x04, 0x61, 0x04, 0x66, 0x04, 0x6A, 0x04, 0x6D, 0x04, 0x73, 0x04, 0x7D, 0x5D,
  0x04, 0x89, 0x04, 0x97, 0x04, 0xA6, 0x04, 0xB5, 0x04, 0xC4, 0x07, 0x41, 0x00, 0x01, 0x00, 0x2A,
  0x09, 0x6E, 0x00, 0x26, 0x50, 0x00, 0x00, 0x00, 0x00, 0x20, 0x08, 0xFB, 0x08, 0xFF, 0x09, 0x03,
  0x09, 0x06, 0x09, 0x08, 0x09, 0x09, 0x09, 0x09, 0x09, 0x07, 0x09, 0x05, 0x09, 0x02, 0x08, 0xFE,
  0x08, 0xFA, 0x08, 0xF6, 0x08, 0xF3, 0x08, 0xF1, 0x08, 0xEF, 0x81, 0xA3, 0xC1
};

static uint8_t ksimulate_connect_indication[] = {
  0x00, 0x00, 0x01, 0x00, 0x00, 0x01, 0x01, 0xC2, 0x00, 0x00, 0x00, 0x00, 0x01, 0xBC, 0x00, 0x23,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF4, 0x00, 0x0D, 0x17, 0x01, 0xAE, 0x00, 0x0B, 0x01, 0xAA,
  0x09, 0x20, 0x00, 0x04, 0x00, 0x03, 0x00, 0x00, 0x09, 0x86, 0x00, 0x04, 0x00, 0x01, 0x11, 0x4D,
  0x09, 0x37, 0x00, 0x08, 0x06, 0x08, 0x06, 0x08, 0x00, 0x01, 0x00, 0x0B, 0xF1, 0x5A, 0x00, 0x04,
  0x00, 0x00, 0x00, 0x02, 0xF1, 0x36, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0xF2, 0x7C, 0x00, 0x1A,
  0x00, 0x01, 0x80, 0x00, 0x00, 0x01, 0x00, 0x12, 0xF1, 0x00, 0x00, 0x0E, 0x00, 0x09, 0xFB, 0x6E,
  0x76, 0x41, 0x0A, 0x01, 0x80, 0x2B, 0xFF, 0xFF, 0xFF, 0x00, 0xF1, 0x35, 0x00, 0x22, 0x00, 0x4D,
  0x00, 0x33, 0x00, 0x33, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0xF1, 0x00, 0x00, 0x0E, 0x00, 0x09, 0xFB, 0x6E, 0x76, 0x41, 0x0A, 0x01, 0x80, 0x2B, 0xFF, 0xFF,
  0xFF, 0x00, 0xF1, 0x01, 0x00, 0x2C, 0x00, 0x05, 0x00, 0x28, 0x00, 0x01, 0x00, 0x03, 0x5D, 0xC0,
  0x00, 0x00, 0x00, 0x02, 0x00, 0x03, 0x5D, 0xC0, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x5E, 0x29,
  0x00, 0x00, 0x00, 0x05, 0x00, 0x01, 0x5E, 0x29, 0x00, 0x00, 0x00, 0x08, 0x00, 0x01, 0x82, 0x35,
  0x00, 0x00, 0x09, 0x2D, 0x00, 0xDC, 0x00, 0x06, 0x00, 0x64, 0x00, 0x01, 0x00, 0x08, 0x00, 0x0C,
  0x44, 0x45, 0x38, 0x34, 0x33, 0x38, 0x39, 0x31, 0x32, 0x38, 0x00, 0x09, 0x00, 0x02, 0x00, 0x08,
  0x00, 0x0E, 0x4D, 0x38, 0x30, 0x30, 0x37, 0x41, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x03, 0x00, 0x08, 0x00, 0x08, 0x20, 0x42, 0x2E, 0x30, 0x30, 0x2E, 0x32, 0x33, 0x00, 0x05,
  0x00, 0x78, 0x00, 0x08, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x00, 0x02, 0x00, 0x58,
  0x00, 0x0E, 0x53, 0x2D, 0x4D, 0x34, 0x30, 0x34, 0x36, 0x2D, 0x31, 0x37, 0x30, 0x31, 0x41, 0x20,
  0x00, 0x04, 0x00, 0x58, 0x00, 0x08, 0x47, 0x2E, 0x30, 0x31, 0x2E, 0x37, 0x32, 0x20, 0x00, 0x07,
  0x00, 0x86, 0x00, 0x01, 0x00, 0x08, 0x00, 0x0C, 0x44, 0x45, 0x38, 0x34, 0x33, 0x38, 0x39, 0x31,
  0x32, 0x38, 0x00, 0x09, 0x00, 0x02, 0x00, 0x08, 0x00, 0x0E, 0x4D, 0x38, 0x30, 0x30, 0x37, 0x41,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x08, 0x00, 0x08, 0x20, 0x42,
  0x2E, 0x30, 0x30, 0x2E, 0x32, 0x33, 0x00, 0x05, 0x00, 0x78, 0x00, 0x08, 0x2D, 0x2D, 0x2D, 0x2D,
  0x2D, 0x2D, 0x2D, 0x2D, 0x00, 0x02, 0x00, 0x58, 0x00, 0x0E, 0x53, 0x2D, 0x4D, 0x34, 0x30, 0x34,
  0x36, 0x2D, 0x31, 0x37, 0x30, 0x31, 0x41, 0x20, 0x00, 0x04, 0x00, 0x58, 0x00, 0x08, 0x47, 0x2E,
  0x30, 0x31, 0x2E, 0x37, 0x32, 0x20, 0x00, 0x02, 0x00, 0x58, 0x00, 0x0E, 0x53, 0x2D, 0x4D, 0x34,
  0x30, 0x34, 0x09, 0x28, 0x00, 0x14, 0x00, 0x08, 0x50, 0x68, 0x69, 0x6C, 0x69, 0x70, 0x73, 0x00,
  0x00, 0x07, 0x4D, 0x38, 0x30, 0x30, 0x37, 0x41, 0x00, 0x00
};

PhilipsIntellivueMP70Simulator::PhilipsIntellivueMP70Simulator(
  RS232ReadInterface* interface)
  : DeviceSimulator(interface),
  _numeric_seconds_since_epoch(0),
  _rtsa_seconds_since_epoch(0),
  _alarm_seconds_since_epoch(0),
  _ext_nu_done(true),
  _ext_rtsa_done(true),
  _ext_alarm_done(true),
  _simulator_state(unassociated),
  _is_lan_simulator(false),
  _socket(nullptr)
{
  _simulation_pfds = new (std::nothrow) FILE*[kMaxNumberOfFilePointers]();
}

PhilipsIntellivueMP70Simulator::~PhilipsIntellivueMP70Simulator()
{
  delete [] _simulation_pfds;
  _simulation_pfds = 0;
}

std::string PhilipsIntellivueMP70Simulator::convert_data_to_hex_string(
  uint8_t* bytes, int length)
{
  int ix = 0;
  unsigned int ilinecount = 0;
  uint8_t* pend = bytes + length;
  std::stringstream ss;
  std::string uppercase_str;

  while (bytes < pend)
  {
    // Not yet at the end of the data, so show another line of
    // hex encoded values

    // Show byte count in column 1
    unsigned int line_number = 16 * ilinecount++;

    ss << std::endl << std::setfill('0') << std::setw(4) << std::hex
      << line_number << "\t";

    // Show 8 bytes
    for (ix = 0; (ix < 8) && (bytes < pend); ix++)
    {
      ss << std::setfill('0') << std::setw(2) << std::hex
        << static_cast<unsigned int>(*bytes) << " ";
      bytes++;
    }

    // Space character separates first 8 bytes from second 8 bytes
    ss << " ";

    // Show next 8 bytes
    for (ix = 0; (ix < 8) && (bytes < pend); ix++)
    {
      ss << std::setfill('0') << std::setw(2) << std::hex
        << static_cast<unsigned int>(*bytes) << " ";
      bytes++;
    }
  }

  for (unsigned int ix = 0; ix < ss.str().length(); ix++)
    uppercase_str += std::toupper(ss.str().at(ix));
  return uppercase_str;
}

DicesRcPhilipsIntellivueSimulatorMP70 PhilipsIntellivueMP70Simulator::
WriteBytes(
  uint8_t* output_buffer,
  const size_t length)
{
  static const char* sfn = "PhilipsIntellivueMP70Simulator::WriteBytes() ";

  std::lock_guard<std::mutex> lock(_write_mutex);

  if (!_is_lan_simulator)
  {
    LOG4CPLUS_INFO(root_logger, "Writing " << length << " bytes to serial "
      "port.");
    DicesRcBaseComm rs232_status = _rs232->Send(output_buffer, length);
    if (rs232_status != DicesRcBaseComm::OK)
    {
      LOG4CPLUS_ERROR(root_logger, sfn << " " << DicesRcBaseCommStatusMessage::
        DicesRcBaseCommToString(rs232_status));
      return DicesRcPhilipsIntellivueSimulatorMP70::SERIAL_PORT_WRITE_FAIL;
    }
  }
  else
  {
    if (!_socket)
    {
      LOG4CPLUS_ERROR(root_logger, sfn << "Member variable _socket is a "
        "null pointer. Unable to write bytes.");
      return DicesRcPhilipsIntellivueSimulatorMP70::FAIL;
    }
    LOG4CPLUS_INFO(root_logger, "Writing " << length << " bytes to lan "
      "port.");
    DicesRcBaseComm socket_status = _socket->Send(output_buffer, length);
    if (socket_status != DicesRcBaseComm::OK)
    {
      LOG4CPLUS_ERROR(root_logger, sfn << DicesRcBaseCommStatusMessage::
        DicesRcBaseCommToString(socket_status));
      return DicesRcPhilipsIntellivueSimulatorMP70::FAIL;
    }
  }

  // Mutex is released when lock goes out of scope.
  return DicesRcPhilipsIntellivueSimulatorMP70::OK;
}

DicesRcPhilipsIntellivueSimulatorMP70 PhilipsIntellivueMP70Simulator::
ExtendedNumericThreadFunction()
{
  _ext_nu_done = false;
  DicesRcPhilipsIntellivueSimulatorMP70 status =
    DicesRcPhilipsIntellivueSimulatorMP70::OK;

  while (!_ext_nu_done && _simulator_state == associated && !terminate_simulator)
  {
    long long current_milliseconds_since_epoch = std::chrono::duration_cast<
      std::chrono::milliseconds>(std::chrono::system_clock::now().
      time_since_epoch()).count();
    long long current_seconds_since_epoch = current_milliseconds_since_epoch
      / 1000;

    if ((current_seconds_since_epoch - _numeric_seconds_since_epoch) < 20)
    {
      if (_data_file_name.empty())
      {
        status = WriteBytes(ksimulate_numeric_observed_value,
          sizeof(ksimulate_numeric_observed_value));
        if (status != DicesRcPhilipsIntellivueSimulatorMP70::OK) break;
      }
      else
      {
        uint8_t buff[kMaxFileRecordBufferSize] = {0};
        status = SearchSimulationFileForResponse(
          reinterpret_cast<uint8_t*>(&buff),
          kMaxFileRecordBufferSize,
          _simulation_pfds[6],
          numeric_group_all);
        if (status != DicesRcPhilipsIntellivueSimulatorMP70::OK) break;
      }
    }
    std::this_thread::sleep_for(std::chrono::seconds(1));
  }
  _ext_nu_done = true;
  return status;
}

DicesRcPhilipsIntellivueSimulatorMP70 PhilipsIntellivueMP70Simulator::
ExtendedRTSAThreadFunction()
{
  _ext_rtsa_done = false;
  DicesRcPhilipsIntellivueSimulatorMP70 status =
    DicesRcPhilipsIntellivueSimulatorMP70::OK;

  while (!_ext_rtsa_done && _simulator_state == associated && !terminate_simulator)
  {
    for(int ix = 0; ix < 4; ix++)
    {
      long long current_milliseconds_since_epoch = std::chrono::duration_cast<
        std::chrono::milliseconds>(std::chrono::system_clock::now().
        time_since_epoch()).count();
      long long current_seconds_since_epoch = current_milliseconds_since_epoch
        / 1000;

      if ((current_seconds_since_epoch - _rtsa_seconds_since_epoch) < 20)
      {
        if (_data_file_name.empty())
        {
          status = WriteBytes(ksimulate_rtsa_obs_val,
            sizeof(ksimulate_rtsa_obs_val));
          if (status != DicesRcPhilipsIntellivueSimulatorMP70::OK) break;
        }
        else
        {
          uint8_t buff[kMaxFileRecordBufferSize] = {0};
          status = SearchSimulationFileForResponse(
            reinterpret_cast<uint8_t*>(&buff),
            kMaxFileRecordBufferSize,
            _simulation_pfds[8],
            rtsa_group_all);
          if (status != DicesRcPhilipsIntellivueSimulatorMP70::OK) break;
        }
      }
    }
    std::this_thread::sleep_for(std::chrono::milliseconds(1000));
  }
  _ext_rtsa_done = true;
  return status;
}

DicesRcPhilipsIntellivueSimulatorMP70 PhilipsIntellivueMP70Simulator::
ExtendedAlarmThreadFunction()
{
  _ext_alarm_done = false;
  DicesRcPhilipsIntellivueSimulatorMP70 status =
    DicesRcPhilipsIntellivueSimulatorMP70::OK;

  while (!_ext_alarm_done && _simulator_state == associated && !terminate_simulator)
  {
    long long current_milliseconds_since_epoch = std::chrono::duration_cast<
      std::chrono::milliseconds>(std::chrono::system_clock::now().
      time_since_epoch()).count();
    long long current_seconds_since_epoch = current_milliseconds_since_epoch
      / 1000;

    if ((current_seconds_since_epoch - _alarm_seconds_since_epoch) < 20)
    {
      if (_data_file_name.empty())
      {
        status = WriteBytes(ksimulate_al_mon,
          sizeof(ksimulate_al_mon));
        if (status != DicesRcPhilipsIntellivueSimulatorMP70::OK) break;
      }
      else
      {
        uint8_t buff[kMaxFileRecordBufferSize] = {0};
        status = SearchSimulationFileForResponse(
          reinterpret_cast<uint8_t*>(&buff),
          kMaxFileRecordBufferSize,
          _simulation_pfds[6],
          alarm_result);
        if (status != DicesRcPhilipsIntellivueSimulatorMP70::OK) break;
      }
    }
    std::this_thread::sleep_for(std::chrono::seconds(1));
  }
  _ext_alarm_done = true;
  return status;
}

DicesRcPhilipsIntellivueSimulatorMP70 PhilipsIntellivueMP70Simulator::
ReadSimulationFileTimestamp(FILE* fd)
{
  static const char* sfn = "PhilipsIntellivueMP70Simulator::"
    "ReadSimulationFileTimestamp()";
  const size_t timestamp_size = 23;
  char timestamp[timestamp_size] = { 0 };
  size_t nbytes = 0;

  if (!fd)
  {
    LOG4CPLUS_DEBUG(root_logger, sfn << " fd is a null pointer.");
    return DicesRcPhilipsIntellivueSimulatorMP70::FUNCTION_ARGUMENT_IS_NULL;
  }

  // Read timestamp from file.
  nbytes = fread(reinterpret_cast<char*>(&timestamp),
    1,
    timestamp_size,
    fd);

  if (nbytes != timestamp_size)
  {
    if (feof(fd))
    {
      LOG4CPLUS_INFO(root_logger, sfn << " End of file reached.");
      return DicesRcPhilipsIntellivueSimulatorMP70::END_OF_FILE;
    }

    LOG4CPLUS_ERROR(root_logger, sfn << " Unable to read timestamp from "
      "simulation file");
    return DicesRcPhilipsIntellivueSimulatorMP70::FILE_READ_FAIL;
  }

  std::string timestamp_str;
  for (size_t ix = 0; ix < timestamp_size; ix++)
    timestamp_str += timestamp[ix];

  return DicesRcPhilipsIntellivueSimulatorMP70::OK;
}

DicesRcPhilipsIntellivueSimulatorMP70 PhilipsIntellivueMP70Simulator::
ReadSimulationFileData(uint8_t* buffer, const ssize_t buffer_length, FILE* fd, ssize_t* total_number_of_bytes)
{
  static const char* sfn = "PhilipsIntellivueMP70Simulator::"
    "ReadSimulationFileData()";
  DicesRcPhilipsIntellivueSimulatorMP70 status =
    DicesRcPhilipsIntellivueSimulatorMP70::OK;
  static const size_t count = 1;

  if (!buffer)
  {
    LOG4CPLUS_DEBUG(root_logger, sfn << " buffer is a null pointer");
    return DicesRcPhilipsIntellivueSimulatorMP70::FUNCTION_ARGUMENT_IS_NULL;
  }

  if (!fd)
  {
    LOG4CPLUS_DEBUG(root_logger, sfn << " fd is a null pointer");
    return DicesRcPhilipsIntellivueSimulatorMP70::FUNCTION_ARGUMENT_IS_NULL;
  }

  if (!total_number_of_bytes)
  {
    LOG4CPLUS_DEBUG(root_logger, sfn << " total_number_of_bytes is a null "
      "pointer.");
    return DicesRcPhilipsIntellivueSimulatorMP70::FUNCTION_ARGUMENT_IS_NULL;
  }

  *total_number_of_bytes = 0;

  memset(buffer, 0, buffer_length);

  // Read the response up until end of frame.
  for (size_t ix = 0;; ix++)
  {
    if (buffer_length < *total_number_of_bytes + count)
    {
      LOG4CPLUS_ERROR(root_logger, sfn << "Not enough bytes in buffer to hold " << *total_number_of_bytes + count << " bytes");
      return DicesRcPhilipsIntellivueSimulatorMP70::FILE_READ_FAIL;
    }

    size_t nbytes = fread(&buffer[ix], 1, count, fd);
    if (nbytes != count)
    {
      if (feof(fd))
      {
        LOG4CPLUS_INFO(root_logger, sfn << " End of file reached.");
        return DicesRcPhilipsIntellivueSimulatorMP70::END_OF_FILE;
      }

      LOG4CPLUS_ERROR(root_logger, sfn << " Unable to read data from "
        "simulation file");
      return DicesRcPhilipsIntellivueSimulatorMP70::FILE_READ_FAIL;
    }

    // Should be adding 1. No size problem here.
    *total_number_of_bytes += static_cast<ssize_t>(nbytes);

    // Check for end of frame
    if ((static_cast<char>(buffer[ix])) == (char)kEOF)
      break;
  }

  return status;
}

DicesRcPhilipsIntellivueSimulatorMP70 PhilipsIntellivueMP70Simulator::
ReadSimulationFileRecord(uint8_t* buffer, const ssize_t buffer_length, FILE* fd, ssize_t* total_number_of_bytes)
{
  static const char* sfn = "PhilipsIntellivueMP70Simulator::"
    "ReadSimulationFileRecord()";
  DicesRcPhilipsIntellivueSimulatorMP70 status =
    DicesRcPhilipsIntellivueSimulatorMP70::OK;

  if (!buffer)
  {
    LOG4CPLUS_DEBUG(root_logger, sfn << " buffer is a null pointer");
    return DicesRcPhilipsIntellivueSimulatorMP70::FUNCTION_ARGUMENT_IS_NULL;
  }

  if (!fd)
  {
    LOG4CPLUS_DEBUG(root_logger, sfn << " fd is a null pointer.");
    return DicesRcPhilipsIntellivueSimulatorMP70::FUNCTION_ARGUMENT_IS_NULL;
  }

  if (!total_number_of_bytes)
  {
    LOG4CPLUS_DEBUG(root_logger, sfn << " total_number_of_bytes is a null "
      "pointer.");
    return DicesRcPhilipsIntellivueSimulatorMP70::FUNCTION_ARGUMENT_IS_NULL;
  }

  *total_number_of_bytes = 0;

  // Read timestamp
  status = ReadSimulationFileTimestamp(fd);
  if (status != DicesRcPhilipsIntellivueSimulatorMP70::OK) return status;

  // Read the response up until end of frame.
  status = ReadSimulationFileData(buffer, buffer_length, fd, total_number_of_bytes);
  if (status != DicesRcPhilipsIntellivueSimulatorMP70::OK) return status;

  return status;
}

DicesRcPhilipsIntellivueSimulatorMP70 PhilipsIntellivueMP70Simulator::
OpenSimulationFile(const char* filename, FILE** pfd)
{
  static const char* sfn = "PhilipsIntellivueMP70Simulator::"
    "OpenSimulationFile()";
  if (!filename)
  {
    LOG4CPLUS_ERROR(root_logger, sfn << " Function argument filename is a "
      "pointer to null.");
    return DicesRcPhilipsIntellivueSimulatorMP70::FUNCTION_ARGUMENT_IS_NULL;
  }

  if (!pfd)
  {
    LOG4CPLUS_ERROR(root_logger, sfn << " Function argument fd is a "
      "pointer to null.");
    return DicesRcPhilipsIntellivueSimulatorMP70::FUNCTION_ARGUMENT_IS_NULL;
  }

  // Open simulation file for reading
  *pfd = fopen(filename, "r");
  if (!(*pfd))
  {
    LOG4CPLUS_ERROR(root_logger, sfn << " Unable to open simulation file.");
    return DicesRcPhilipsIntellivueSimulatorMP70::OPEN_FILE_FAIL;
  }
  return DicesRcPhilipsIntellivueSimulatorMP70::OK;
}

DicesRcPhilipsIntellivueSimulatorMP70 PhilipsIntellivueMP70Simulator::
IsSerialOrLanSimulationFile(uint8_t* buffer, const ssize_t buffer_length, FILE* fd)
{
  static const char* sfn = "PhilipsIntellivueMP70Simulator::"
    "IsSerialOrLanSimulationFile() ";

  if (!buffer)
  {
    LOG4CPLUS_DEBUG(root_logger, sfn << " buffer is a null pointer");
    return DicesRcPhilipsIntellivueSimulatorMP70::FUNCTION_ARGUMENT_IS_NULL;
  }

  if (!fd)
  {
    LOG4CPLUS_ERROR(root_logger, sfn << "Function argument fd is a null "
      "pointer.");
    return DicesRcPhilipsIntellivueSimulatorMP70::FUNCTION_ARGUMENT_IS_NULL;
  }

  DicesRcPhilipsIntellivueSimulatorMP70 status = ReadSimulationFileTimestamp(
    fd);
  if (status != DicesRcPhilipsIntellivueSimulatorMP70::OK)
  {
    LOG4CPLUS_ERROR(root_logger, sfn
      << DicesRcPhilipsIntellivueSimulatorMP70StatusMessage::
      DicesRcPhilipsIntellivueSimulatorMP70ToString(status));
    return status;
  }

  const size_t kread_count = 1;
  if (buffer_length < kread_count)
  {
    LOG4CPLUS_DEBUG(root_logger, sfn << " Not enough bytes in buffer to read " << kread_count << " byte");
    return DicesRcPhilipsIntellivueSimulatorMP70::FUNCTION_ARGUMENT_IS_NULL;
  }

  size_t nbytes = fread(&buffer[0], 1, kread_count, fd);
  if (nbytes != kread_count)
  {
    if (feof(fd))
    {
      LOG4CPLUS_INFO(root_logger, sfn << "End of file reached.");
      rewind(fd);
      return DicesRcPhilipsIntellivueSimulatorMP70::END_OF_FILE;
    }

    LOG4CPLUS_ERROR(root_logger, sfn << "Unable to read data from "
      "simulation file");
    rewind(fd);
    return DicesRcPhilipsIntellivueSimulatorMP70::FILE_READ_FAIL;
  }

  rewind(fd);

  LOG4CPLUS_INFO(root_logger, sfn << "First byte of first response is value "
    "(hex): " << std::hex << static_cast<int>(buffer[0]));

  if (buffer[0] == kBOF)
  {
    LOG4CPLUS_INFO(root_logger, sfn << "Found serial simulation data");
    return DicesRcPhilipsIntellivueSimulatorMP70::IS_SERIAL_SIM_DATA_FILE;
  }
  else
  {
    LOG4CPLUS_INFO(root_logger, sfn << "Found lan simulation data");
    return DicesRcPhilipsIntellivueSimulatorMP70::IS_LAN_SIM_DATA_FILE;
  }

  return DicesRcPhilipsIntellivueSimulatorMP70::FAIL;
}

DicesRcPhilipsIntellivueSimulatorMP70 PhilipsIntellivueMP70Simulator::
SearchSimulationFileForResponse(uint8_t* buffer, const ssize_t buffer_length, FILE* fd, response_type response)
{
  static const char* sfn = "PhilipsIntellivueMP70Simulator::"
    "SearchSimulationFileForResponse()";

  if (!buffer)
  {
    LOG4CPLUS_DEBUG(root_logger, sfn << " buffer is a null pointer");
    return DicesRcPhilipsIntellivueSimulatorMP70::FUNCTION_ARGUMENT_IS_NULL;
  }

  if (!fd)
  {
    LOG4CPLUS_DEBUG(root_logger, sfn << " fd is a null pointer.");
    return DicesRcPhilipsIntellivueSimulatorMP70::FUNCTION_ARGUMENT_IS_NULL;
  }

  DicesRcPhilipsIntellivueSimulatorMP70 status =
    DicesRcPhilipsIntellivueSimulatorMP70::OK;
  int eof_counter = 0;
  bool is_linked_result = false;
  intellivue_serial serial_converter;

  while (1)
  {
    ssize_t number_of_bytes = 0;

    if (_is_lan_simulator)
    {
      status = ReadLanSimulationFileRecord(buffer, buffer_length, fd, &number_of_bytes);
    }
    else
    {
      status = ReadSimulationFileRecord(buffer, buffer_length, fd, &number_of_bytes);
    }
    if (status != DicesRcPhilipsIntellivueSimulatorMP70::OK)
    {
      if (status == DicesRcPhilipsIntellivueSimulatorMP70::END_OF_FILE)
      {
        eof_counter++;
        rewind(fd);
        if (eof_counter == kEndOfFileMaxLimit)
        {
          std::string msg;
          switch (response)
          {
            case association_response:
              msg = "association response";
              break;
            case mds_create_event_result:
              msg = "mds create event result";
              break;
            case mds_result:
              msg = "mds result";
              break;
            case set_rtsa_priority_list:
              msg = "set RTSA priority list result";
              break;
            case numeric_group_static:
              msg = "numeric static group result";
              break;
            case numeric_group_all:
              msg = "numeric all group result";
              break;
            case rtsa_group_static:
              msg = "RTSA static group result";
              break;
            case rtsa_group_all:
              msg = "RTSA all group result";
              break;
            case alarm_result:
              msg = "Alarm result, alarm monitor group";
              break;
          }
          // Reached eof twice. this response is not in file
          LOG4CPLUS_WARN(root_logger, sfn << " The sample data file doesn't "
            "contain the " << msg);
          break;
        }
        continue;
      }
      else
      {
        break;
      }
    }

    bool torf = false;
    is_linked_result = false; // Reset
    ssize_t unwrapped_number_of_bytes = number_of_bytes;

    uint8_t temp_buff[kMaxFileRecordBufferSize] = { 0 };
    memcpy(temp_buff, buffer, number_of_bytes);

    if (!_is_lan_simulator)
    {
      // Unwrap the serial message.
      serial_converter.unwrap_serial_msg(temp_buff,
        &unwrapped_number_of_bytes);
    }

    switch (response)
    {
      case association_response:
        IsAssociationResponse(temp_buff, unwrapped_number_of_bytes, &torf);
        break;
      case mds_create_event_result:
        IsMDSCreateEventResult(temp_buff, unwrapped_number_of_bytes, &torf);
        break;
      case mds_result:
        IsSinglePollDataResult(temp_buff, unwrapped_number_of_bytes, &torf,
          mds_result);
        break;
      case pat_demo_result:
        IsSinglePollDataResult(temp_buff, unwrapped_number_of_bytes, &torf,
          pat_demo_result);
        break;
      case set_rtsa_priority_list:
        IsSetRTSAPriorityListResult(temp_buff, unwrapped_number_of_bytes,
          &torf);
        break;
      case rtsa_group_static:
        IsExtendedPollDataResult(temp_buff, unwrapped_number_of_bytes, &torf,
          rtsa_group_static);
        if (torf)
          IsLinkedResult(temp_buff, unwrapped_number_of_bytes,
          &is_linked_result);
        break;
      case rtsa_group_all:
        IsExtendedPollDataResult(temp_buff, unwrapped_number_of_bytes, &torf,
          rtsa_group_all);
        if (torf)
          IsLinkedResult(temp_buff, unwrapped_number_of_bytes,
          &is_linked_result);
        break;
      case numeric_group_static:
        IsExtendedPollDataResult(temp_buff, unwrapped_number_of_bytes, &torf,
          numeric_group_static);
        if (torf)
          IsLinkedResult(temp_buff, unwrapped_number_of_bytes,
          &is_linked_result);
        break;
      case numeric_group_all:
        IsExtendedPollDataResult(temp_buff, unwrapped_number_of_bytes, &torf,
          numeric_group_all);
        if (torf)
          IsLinkedResult(temp_buff, unwrapped_number_of_bytes,
          &is_linked_result);
        break;
      case alarm_result:
        IsExtendedPollDataResult(temp_buff, unwrapped_number_of_bytes, &torf,
          alarm_result);
        if (torf)
          IsLinkedResult(temp_buff, unwrapped_number_of_bytes,
          &is_linked_result);
        break;
    }

    if (is_linked_result)
    {
      LOG4CPLUS_INFO(root_logger, "LINKED");
    }

    if (torf)
    {
      LOG4CPLUS_INFO(root_logger, "Writing bytes: "
        << convert_data_to_hex_string(buffer, number_of_bytes));
      status = WriteBytes(buffer, number_of_bytes);
      if (status != DicesRcPhilipsIntellivueSimulatorMP70::OK) return status;

      // Determines if we should stay in the loop and continue reading the
      // linked result.
      if (!is_linked_result) break; // Exit function successfully
    }
  }
  return status;
}

DicesRcPhilipsIntellivueSimulatorMP70 PhilipsIntellivueMP70Simulator::
IsLinkedResult(
  uint8_t* bytes,
  ssize_t length,
  bool* torf)
{
  static const char* sfn = "PhilipsIntellivueMP70Simulator::"
    "IsLinkedResult()";

  if (!bytes)
  {
    LOG4CPLUS_ERROR(root_logger, sfn << " Function argument bytes is null");
    return DicesRcPhilipsIntellivueSimulatorMP70::FUNCTION_ARGUMENT_IS_NULL;
  }

  if (!torf)
  {
    LOG4CPLUS_ERROR(root_logger, sfn << " Function argument torf is null");
    return DicesRcPhilipsIntellivueSimulatorMP70::FUNCTION_ARGUMENT_IS_NULL;
  }

  *torf = false;

  // Parse session header
  intellivue::SessionHeader session_header;
  session_header.type = bytes[0];
  session_header.length[0] = static_cast<uint8_t>(bytes[1]);

  // Handle the command based on the type
  if (static_cast<int>(session_header.type) == 0xE1)
  {
    int iindex = 0;
    intellivue::SPpdu sppdu;
    intellivue::ROapdus roapdus;

    sppdu.session_id = bytes2u16(reinterpret_cast<uint8_t*>(
      &bytes[iindex]));
    sppdu.p_context_id = bytes2u16(reinterpret_cast<uint8_t*>(
      &bytes[iindex + 2]));
    iindex += 4;

    roapdus.ro_type = bytes2u16(reinterpret_cast<uint8_t*>(
      &bytes[iindex]));
    roapdus.length = bytes2u16(reinterpret_cast<uint8_t*>(
      &bytes[iindex + 2]));
    iindex += 4;

    if (static_cast<int>(roapdus.ro_type) != ROLRS_APDU)
      return DicesRcPhilipsIntellivueSimulatorMP70::OK;

    *torf = true;
  }
  return DicesRcPhilipsIntellivueSimulatorMP70::OK;
}

DicesRcPhilipsIntellivueSimulatorMP70 PhilipsIntellivueMP70Simulator::
HandleAssociationRequest()
{
  // Received association request
  // TODO This may become more complex in the future
  static const char* sfn = "PhilipsIntellivueMP70Simulator::"
    "HandleAssociationRequest()";
  DicesRcPhilipsIntellivueSimulatorMP70 status =
    DicesRcPhilipsIntellivueSimulatorMP70::OK;

  if (_data_file_name.empty())
  {
    // Use program generated data
    LOG4CPLUS_INFO(root_logger, "Sending program generated association "
      "response");
    status = WriteBytes(ksimulate_association_response,
      sizeof(ksimulate_association_response));
    if (status != DicesRcPhilipsIntellivueSimulatorMP70::OK) return status;

    LOG4CPLUS_INFO(root_logger, "Sending program generated MDS create event "
      "report");
    status = WriteBytes(ksimulate_mds_create_event_report,
      sizeof(ksimulate_mds_create_event_report));
    if (status != DicesRcPhilipsIntellivueSimulatorMP70::OK) return status;
  }
  else
  {
    // Read responses from file.
    LOG4CPLUS_INFO(root_logger, "Sending file association response");
    uint8_t buff[kMaxFileRecordBufferSize] = {0};
    status = SearchSimulationFileForResponse(
      reinterpret_cast<uint8_t*>(&buff),
      kMaxFileRecordBufferSize,
      _simulation_pfds[0],
      association_response);

    LOG4CPLUS_INFO(root_logger, "Sending file MDS create event report");
    uint8_t buff2[kMaxFileRecordBufferSize] = {0};
    status = SearchSimulationFileForResponse(
      reinterpret_cast<uint8_t*>(&buff2),
      kMaxFileRecordBufferSize,
      _simulation_pfds[1],
      mds_create_event_result);
  }

  return status;
}

DicesRcPhilipsIntellivueSimulatorMP70 PhilipsIntellivueMP70Simulator::
IsConnectIndicationMessage(
  uint8_t* buffer,
  const ssize_t buffer_length,
  ssize_t length,
  bool* torf)
{
  static const char* sfn = "PhilipsIntellivueMP70Simulator::"
    "IsConnectIndicationMessage() ";
  if (!buffer)
  {
    LOG4CPLUS_ERROR(root_logger, sfn << " Function argument buffer is null");
    return DicesRcPhilipsIntellivueSimulatorMP70::FUNCTION_ARGUMENT_IS_NULL;
  }

  if (!torf)
  {
    LOG4CPLUS_ERROR(root_logger, sfn << " Function argument torf is null");
    return DicesRcPhilipsIntellivueSimulatorMP70::FUNCTION_ARGUMENT_IS_NULL;
  }
  *torf = false;

  if (length > buffer_length)
  {
    LOG4CPLUS_ERROR(root_logger, sfn << "length out of bounds");
    return DicesRcPhilipsIntellivueSimulatorMP70::CORRUPT_DATA;
  }

  if (length < 1)
  {
    LOG4CPLUS_ERROR(root_logger, sfn << "length is not long enough to "
      "parse first byte");
    return DicesRcPhilipsIntellivueSimulatorMP70::CORRUPT_DATA;
  }

  switch (buffer[0])
  {
      // Data Export Command Protocol
    case 0xE1:
      *torf = false;
      break;
      // Association Response types
    case CN_SPDU_SI:
      *torf = false;
      break;
    case AC_SPDU_SI:
      *torf = false;
      break;
    case RF_SPDU_SI:
      *torf = false;
      break;
    case FN_SPDU_SI:
      *torf = false;
      break;
    case DN_SPDU_SI:
      *torf = false;
      break;
    case AB_SPDU_SI:
      *torf = false;
      break;
    default:
      *torf = true;
      break;
  }
  return DicesRcPhilipsIntellivueSimulatorMP70::OK;
}

DicesRcPhilipsIntellivueSimulatorMP70 PhilipsIntellivueMP70Simulator::
IsAssociationResponse(uint8_t* bytes,
  ssize_t length,
  bool* torf)
{
  static const char* sfn = "PhilipsIntellivueMP70Simulator::"
    "IsAssociationResponse()";

  if (!bytes)
  {
    LOG4CPLUS_ERROR(root_logger, sfn << " Function argument bytes is null");
    return DicesRcPhilipsIntellivueSimulatorMP70::FUNCTION_ARGUMENT_IS_NULL;
  }

  if (!torf)
  {
    LOG4CPLUS_ERROR(root_logger, sfn << " Function argument torf is null");
    return DicesRcPhilipsIntellivueSimulatorMP70::FUNCTION_ARGUMENT_IS_NULL;
  }

  *torf = false;

  if (length < 2)
  {
    LOG4CPLUS_ERROR(root_logger, sfn << " length is not long enough to "
      "parse SessionHeader");
    return DicesRcPhilipsIntellivueSimulatorMP70::CORRUPT_DATA;
  }

  // Parse session header
  intellivue::SessionHeader session_header;
  session_header.type = bytes[0];
  session_header.length[0] = static_cast<uint8_t>(bytes[1]);

  // Handle the command based on the type
  if (session_header.type == AC_SPDU_SI) *torf = true;
  else *torf = false;

  return DicesRcPhilipsIntellivueSimulatorMP70::OK;
}

DicesRcPhilipsIntellivueSimulatorMP70 PhilipsIntellivueMP70Simulator::
IsMDSCreateEventResult(uint8_t* bytes,
  ssize_t length,
  bool* torf)
{
  static const char* sfn = "PhilipsIntellivueMP70Simulator::"
    "IsMDSCreateEventResult()";

  if (!bytes)
  {
    LOG4CPLUS_ERROR(root_logger, sfn << " Function argument bytes is null");
    return DicesRcPhilipsIntellivueSimulatorMP70::FUNCTION_ARGUMENT_IS_NULL;
  }

  if (!torf)
  {
    LOG4CPLUS_ERROR(root_logger, sfn << " Function argument torf is null");
    return DicesRcPhilipsIntellivueSimulatorMP70::FUNCTION_ARGUMENT_IS_NULL;
  }

  *torf = false;

  if (length < 2)
  {
    LOG4CPLUS_ERROR(root_logger, sfn << " length is not long enough to "
      "parse SessionHeader");
    return DicesRcPhilipsIntellivueSimulatorMP70::CORRUPT_DATA;
  }

  // Parse session header
  intellivue::SessionHeader session_header;
  session_header.type = bytes[0];
  session_header.length[0] = static_cast<uint8_t>(bytes[1]);

  // Handle the command based on the type
  if (static_cast<int>(session_header.type) == 0xE1)
  {
    int iindex = 0;
    intellivue::SPpdu sppdu;
    intellivue::ROapdus roapdus;
    intellivue::ROIVapdu roivapdu;

    if (length < 8)
    {
      LOG4CPLUS_ERROR(root_logger, sfn << " length is not long enough to "
        "parse SPpdu and ROapdus");
      return DicesRcPhilipsIntellivueSimulatorMP70::CORRUPT_DATA;
    }

    sppdu.session_id = bytes2u16(reinterpret_cast<uint8_t*>(
      &bytes[iindex]));
    sppdu.p_context_id = bytes2u16(reinterpret_cast<uint8_t*>(
      &bytes[iindex + 2]));
    iindex += 4;

    roapdus.ro_type = bytes2u16(reinterpret_cast<uint8_t*>(
      &bytes[iindex]));
    roapdus.length = bytes2u16(reinterpret_cast<uint8_t*>(
      &bytes[iindex + 2]));
    iindex += 4;

    if ((length - iindex) < roapdus.length)
    {
      LOG4CPLUS_ERROR(root_logger, sfn << " length is not long enough to "
        "parse RORSapdu");
      return DicesRcPhilipsIntellivueSimulatorMP70::CORRUPT_DATA;
    }

    if (static_cast<int>(roapdus.ro_type) != ROIV_APDU)
      return DicesRcPhilipsIntellivueSimulatorMP70::OK;

    roivapdu.invoke_id = bytes2u16(reinterpret_cast<uint8_t*>(
      &bytes[iindex]));
    roivapdu.command_type = bytes2u16(reinterpret_cast<uint8_t*>(
      &bytes[iindex + 2]));
    roivapdu.length = bytes2u16(reinterpret_cast<uint8_t*>(
      &bytes[iindex + 4]));
    iindex += 6;

    if (static_cast<int>(roivapdu.command_type) != CMD_CONFIRMED_EVENT_REPORT)
      return DicesRcPhilipsIntellivueSimulatorMP70::OK;

    LOG4CPLUS_INFO(root_logger, "Found MDS Create Event Result" << std::endl
      << convert_data_to_hex_string(reinterpret_cast<uint8_t*>(bytes), length));
    *torf = true; // Found it
  }
  else *torf = false;

  return DicesRcPhilipsIntellivueSimulatorMP70::OK;
}

DicesRcPhilipsIntellivueSimulatorMP70 PhilipsIntellivueMP70Simulator::
IsSinglePollDataResult(uint8_t* bytes,
  ssize_t length,
  bool* torf,
  response_type response)
{
  static const char* sfn = "PhilipsIntellivueMP70Simulator::"
    "IsSinglePollDataResult() ";

  if (!bytes)
  {
    LOG4CPLUS_ERROR(root_logger, sfn << "Function argument bytes is null");
    return DicesRcPhilipsIntellivueSimulatorMP70::FUNCTION_ARGUMENT_IS_NULL;
  }

  if (!torf)
  {
    LOG4CPLUS_ERROR(root_logger, sfn << "Function argument torf is null");
    return DicesRcPhilipsIntellivueSimulatorMP70::FUNCTION_ARGUMENT_IS_NULL;
  }

  *torf = false;

  if (length < 2)
  {
    LOG4CPLUS_ERROR(root_logger, sfn << "length is not long enough to "
      "parse SessionHeader");
    return DicesRcPhilipsIntellivueSimulatorMP70::CORRUPT_DATA;
  }

  // Parse session header
  intellivue::SessionHeader session_header;
  session_header.type = bytes[0];
  session_header.length[0] = static_cast<uint8_t>(bytes[1]);

  // Handle the command based on the type
  if (static_cast<int>(session_header.type) == 0xE1)
  {
    int iindex = 0;
    intellivue::SPpdu sppdu;
    intellivue::ROapdus roapdus;
    intellivue::RORSapdu rorsapdu;
    intellivue::ActionResult act_result;
    intellivue::PollMdibDataReply poll_reply;

    if (length < 8)
    {
      LOG4CPLUS_ERROR(root_logger, sfn << "length is not long enough to "
        "parse SPpdu and ROapdus");
      return DicesRcPhilipsIntellivueSimulatorMP70::CORRUPT_DATA;
    }

    sppdu.session_id = bytes2u16(reinterpret_cast<uint8_t*>(
      &bytes[iindex]));
    sppdu.p_context_id = bytes2u16(reinterpret_cast<uint8_t*>(
      &bytes[iindex + 2]));
    iindex += 4;

    roapdus.ro_type = bytes2u16(reinterpret_cast<uint8_t*>(
      &bytes[iindex]));
    roapdus.length = bytes2u16(reinterpret_cast<uint8_t*>(
      &bytes[iindex + 2]));
    iindex += 4;

    if ((length - iindex) < roapdus.length)
    {
      LOG4CPLUS_ERROR(root_logger, sfn << "length is not long enough to "
        "parse RORSapdu");
      return DicesRcPhilipsIntellivueSimulatorMP70::CORRUPT_DATA;
    }

    if (static_cast<int>(roapdus.ro_type) != RORS_APDU)
      return DicesRcPhilipsIntellivueSimulatorMP70::OK;

    rorsapdu.invoke_id = bytes2u16(reinterpret_cast<uint8_t*>(
      &bytes[iindex]));
    rorsapdu.command_type = bytes2u16(reinterpret_cast<uint8_t*>(
      &bytes[iindex + 2]));
    rorsapdu.length = bytes2u16(reinterpret_cast<uint8_t*>(
      &bytes[iindex + 4]));
    iindex += 6;

    if ((length - iindex) < rorsapdu.length)
    {
      LOG4CPLUS_ERROR(root_logger, sfn << "length is not long enough to "
        "parse ActionResult");
      return DicesRcPhilipsIntellivueSimulatorMP70::CORRUPT_DATA;
    }

    if (static_cast<int>(rorsapdu.command_type) != CMD_CONFIRMED_ACTION)
      return DicesRcPhilipsIntellivueSimulatorMP70::OK;

    act_result.managed_object.m_obj_class =
      bytes2u16(reinterpret_cast<uint8_t*>(&bytes[iindex]));
    act_result.managed_object.m_obj_inst.context_id =
      bytes2u16(reinterpret_cast<uint8_t*>(&bytes[iindex + 2]));
    act_result.managed_object.m_obj_inst.handle =
      bytes2u16(reinterpret_cast<uint8_t*>(&bytes[iindex + 4]));
    act_result.action_type = bytes2u16(reinterpret_cast<uint8_t*>(
      &bytes[iindex + 6]));
    act_result.length = bytes2u16(reinterpret_cast<uint8_t*>(
      &bytes[iindex + 8]));
    iindex += 10;

    if ((length - iindex) < act_result.length)
    {
      LOG4CPLUS_ERROR(root_logger, sfn << "length is not long enough to "
        "parse PollMdibDataReply");
      return DicesRcPhilipsIntellivueSimulatorMP70::CORRUPT_DATA;
    }

    if (static_cast<int>(act_result.managed_object.m_obj_class)
      != NOM_MOC_VMS_MDS
      || static_cast<int>(act_result.action_type) != NOM_ACT_POLL_MDIB_DATA)
      return DicesRcPhilipsIntellivueSimulatorMP70::OK;

    poll_reply.poll_number = bytes2u16(reinterpret_cast<uint8_t*>(
      &bytes[iindex]));
    poll_reply.rel_time_stamp = bytes2u32(reinterpret_cast<uint8_t*>(
      &bytes[iindex + 2]));
    poll_reply.abs_time_stamp.century = bytes[iindex + 6];
    poll_reply.abs_time_stamp.year = bytes[iindex + 7];
    poll_reply.abs_time_stamp.month = bytes[iindex + 8];
    poll_reply.abs_time_stamp.day = bytes[iindex + 9];
    poll_reply.abs_time_stamp.hour = bytes[iindex + 10];
    poll_reply.abs_time_stamp.minute = bytes[iindex + 11];
    poll_reply.abs_time_stamp.second = bytes[iindex + 12];
    poll_reply.abs_time_stamp.sec_fractions = bytes[iindex + 13];
    poll_reply.polled_obj_type.partition =
      bytes2u16(reinterpret_cast<uint8_t*>(&bytes[iindex + 14]));
    poll_reply.polled_obj_type.code = bytes2u16(reinterpret_cast<uint8_t*>(
      &bytes[iindex + 16]));
    poll_reply.polled_attr_grp = bytes2u16(reinterpret_cast<uint8_t*>(
      &bytes[iindex + 18]));
    iindex += 20;

    if (static_cast<int>(poll_reply.polled_obj_type.partition) != NOM_PART_OBJ)
      return DicesRcPhilipsIntellivueSimulatorMP70::OK;

    switch (response)
    {
      case mds_result:
        if (static_cast<int>(poll_reply.polled_obj_type.code)
          != NOM_MOC_VMS_MDS)
          return DicesRcPhilipsIntellivueSimulatorMP70::OK;
        LOG4CPLUS_INFO(root_logger, sfn << "Found MDS Result"
          << std::endl << convert_data_to_hex_string(
          reinterpret_cast<uint8_t*>(bytes),
          length));
        break;
      case pat_demo_result:
        if (static_cast<int>(poll_reply.polled_obj_type.code)
          != NOM_MOC_PT_DEMOG)
          return DicesRcPhilipsIntellivueSimulatorMP70::OK;
        LOG4CPLUS_INFO(root_logger, sfn << "Found Patient Demographics Result"
          << std::endl << convert_data_to_hex_string(
          reinterpret_cast<uint8_t*>(bytes),
          length));
        break;
      case alarm_result:
        if (static_cast<int>(poll_reply.polled_obj_type.code)
          != NOM_MOC_VMO_AL_MON)
          return DicesRcPhilipsIntellivueSimulatorMP70::OK;
        LOG4CPLUS_INFO(root_logger, sfn << "Found Alarm Result"
          << std::endl << convert_data_to_hex_string(
          reinterpret_cast<uint8_t*>(bytes),
          length));
        break;
      default:
        LOG4CPLUS_WARN(root_logger, sfn << "response type is not a single "
          "poll data command");
        return DicesRcPhilipsIntellivueSimulatorMP70::OK;
        break;
    }

    *torf = true; // Found it
  }
  else *torf = false;

  return DicesRcPhilipsIntellivueSimulatorMP70::OK;
}

DicesRcPhilipsIntellivueSimulatorMP70 PhilipsIntellivueMP70Simulator::
IsSetRTSAPriorityListResult(uint8_t* bytes,
  ssize_t length,
  bool* torf)
{
  static const char* sfn = "PhilipsIntellivueMP70Simulator::"
    "IsSetRTSAPriorityListResult()";

  if (!bytes)
  {
    LOG4CPLUS_ERROR(root_logger, sfn << " Function argument bytes is null");
    return DicesRcPhilipsIntellivueSimulatorMP70::FUNCTION_ARGUMENT_IS_NULL;
  }

  if (!torf)
  {
    LOG4CPLUS_ERROR(root_logger, sfn << " Function argument torf is null");
    return DicesRcPhilipsIntellivueSimulatorMP70::FUNCTION_ARGUMENT_IS_NULL;
  }

  *torf = false;

  if (length < 2)
  {
    LOG4CPLUS_ERROR(root_logger, sfn << " length is not long enough to "
      "parse SessionHeader");
    return DicesRcPhilipsIntellivueSimulatorMP70::CORRUPT_DATA;
  }

  // Parse session header
  intellivue::SessionHeader session_header;
  session_header.type = bytes[0];
  session_header.length[0] = static_cast<uint8_t>(bytes[1]);

  // Handle the command based on the type
  if (static_cast<int>(session_header.type) == 0xE1)
  {
    int iindex = 0;
    intellivue::SPpdu sppdu;
    intellivue::ROapdus roapdus;
    intellivue::RORSapdu rorsapdu;
    intellivue::SetResult set_result;
    intellivue::AttributeList att_list;

    if (length < 8)
    {
      LOG4CPLUS_ERROR(root_logger, sfn << " length is not long enough to "
        "parse SPpdu and ROapdus");
      return DicesRcPhilipsIntellivueSimulatorMP70::CORRUPT_DATA;
    }

    sppdu.session_id = bytes2u16(reinterpret_cast<uint8_t*>(
      &bytes[iindex]));
    sppdu.p_context_id = bytes2u16(reinterpret_cast<uint8_t*>(
      &bytes[iindex + 2]));
    iindex += 4;

    roapdus.ro_type = bytes2u16(reinterpret_cast<uint8_t*>(
      &bytes[iindex]));
    roapdus.length = bytes2u16(reinterpret_cast<uint8_t*>(
      &bytes[iindex + 2]));
    iindex += 4;

    if ((length - iindex) < roapdus.length)
    {
      LOG4CPLUS_ERROR(root_logger, sfn << " length is not long enough to "
        "parse RORSapdu");
      return DicesRcPhilipsIntellivueSimulatorMP70::CORRUPT_DATA;
    }

    if (static_cast<int>(roapdus.ro_type) != RORS_APDU)
      return DicesRcPhilipsIntellivueSimulatorMP70::OK;

    rorsapdu.invoke_id = bytes2u16(reinterpret_cast<uint8_t*>(
      &bytes[iindex]));
    rorsapdu.command_type = bytes2u16(reinterpret_cast<uint8_t*>(
      &bytes[iindex + 2]));
    rorsapdu.length = bytes2u16(reinterpret_cast<uint8_t*>(
      &bytes[iindex + 4]));
    iindex += 6;

    if ((length - iindex) < rorsapdu.length)
    {
      LOG4CPLUS_ERROR(root_logger, sfn << " length is not long enough to "
        "parse SetResult");
      return DicesRcPhilipsIntellivueSimulatorMP70::CORRUPT_DATA;
    }

    if (static_cast<int>(rorsapdu.command_type) != CMD_CONFIRMED_SET)
      return DicesRcPhilipsIntellivueSimulatorMP70::OK;

    set_result.managed_object.m_obj_class =
      bytes2u16(reinterpret_cast<uint8_t*>(&bytes[iindex]));
    set_result.managed_object.m_obj_inst.context_id =
      bytes2u16(reinterpret_cast<uint8_t*>(&bytes[iindex + 2]));
    set_result.managed_object.m_obj_inst.handle =
      bytes2u16(reinterpret_cast<uint8_t*>(&bytes[iindex + 4]));
    iindex += 6;

    if (static_cast<int>(set_result.managed_object.m_obj_class)
      != NOM_MOC_VMS_MDS)
      return DicesRcPhilipsIntellivueSimulatorMP70::OK;

    att_list.count = bytes2u16(reinterpret_cast<uint8_t*>(
      &bytes[iindex]));
    att_list.length = bytes2u16(reinterpret_cast<uint8_t*>(
      &bytes[iindex + 2]));
    att_list.value[0].attribute_id = bytes2u16(reinterpret_cast<uint8_t*>(
      &bytes[iindex + 4]));
    att_list.value[0].length = bytes2u16(reinterpret_cast<uint8_t*>(
      &bytes[iindex + 6]));

    if (static_cast<int>(att_list.value[0].attribute_id) !=
      NOM_ATTR_POLL_RTSA_PRIO_LIST)
      return DicesRcPhilipsIntellivueSimulatorMP70::OK;

    LOG4CPLUS_INFO(root_logger, sfn << " Found Set RTSA priority list result"
      << std::endl << convert_data_to_hex_string(
      reinterpret_cast<uint8_t*>(bytes), length));

    *torf = true; // Found it
  }
  else *torf = false;

  return DicesRcPhilipsIntellivueSimulatorMP70::OK;
}

DicesRcPhilipsIntellivueSimulatorMP70 PhilipsIntellivueMP70Simulator::
IsExtendedPollDataResult(uint8_t* bytes,
  ssize_t length,
  bool* torf,
  response_type response)
{
  static const char* sfn = "PhilipsIntellivueMP70Simulator::"
    "IsExtendedPollDataResult()";

  if (!bytes)
  {
    LOG4CPLUS_ERROR(root_logger, sfn << " Function argument bytes is null");
    return DicesRcPhilipsIntellivueSimulatorMP70::FUNCTION_ARGUMENT_IS_NULL;
  }

  if (!torf)
  {
    LOG4CPLUS_ERROR(root_logger, sfn << " Function argument torf is null");
    return DicesRcPhilipsIntellivueSimulatorMP70::FUNCTION_ARGUMENT_IS_NULL;
  }

  *torf = false;

  if (length < 2)
  {
    LOG4CPLUS_ERROR(root_logger, sfn << " length is not long enough to "
      "parse SessionHeader");
    return DicesRcPhilipsIntellivueSimulatorMP70::CORRUPT_DATA;
  }

  // Parse session header
  intellivue::SessionHeader session_header;
  session_header.type = bytes[0];
  session_header.length[0] = static_cast<uint8_t>(bytes[1]);

  // Handle the command based on the type
  if (static_cast<int>(session_header.type) == 0xE1)
  {
    int iindex = 0;
    intellivue::SPpdu sppdu;
    intellivue::ROapdus roapdus;
    intellivue::RORSapdu rorsapdu;
    intellivue::ROLRSapdu rolrsapdu;
    intellivue::ActionResult act_result;
    intellivue::PollMdibDataReplyExt poll_reply_ext;

    if (length < 8)
    {
      LOG4CPLUS_ERROR(root_logger, sfn << " length is not long enough to "
        "parse SPpdu and ROapdus");
      return DicesRcPhilipsIntellivueSimulatorMP70::CORRUPT_DATA;
    }

    sppdu.session_id = bytes2u16(reinterpret_cast<uint8_t*>(
      &bytes[iindex]));
    sppdu.p_context_id = bytes2u16(reinterpret_cast<uint8_t*>(
      &bytes[iindex + 2]));
    iindex += 4;

    roapdus.ro_type = bytes2u16(reinterpret_cast<uint8_t*>(
      &bytes[iindex]));
    roapdus.length = bytes2u16(reinterpret_cast<uint8_t*>(
      &bytes[iindex + 2]));
    iindex += 4;

    if ((length - iindex) < roapdus.length)
    {
      LOG4CPLUS_ERROR(root_logger, sfn << " length is not long enough to "
        "parse RORSapdu or ROLRSapdu");
      return DicesRcPhilipsIntellivueSimulatorMP70::CORRUPT_DATA;
    }

    switch (roapdus.ro_type)
    {
      case RORS_APDU:
        rorsapdu.invoke_id = bytes2u16(reinterpret_cast<uint8_t*>(
          &bytes[iindex]));
        rorsapdu.command_type = bytes2u16(reinterpret_cast<uint8_t*>(
          &bytes[iindex + 2]));
        rorsapdu.length = bytes2u16(reinterpret_cast<uint8_t*>(
          &bytes[iindex + 4]));
        iindex += 6;

        if ((length - iindex) < rorsapdu.length)
        {
          LOG4CPLUS_ERROR(root_logger, sfn << " length is not long enough to "
            "parse ActionResult");
          return DicesRcPhilipsIntellivueSimulatorMP70::CORRUPT_DATA;
        }

        if (static_cast<int>(rorsapdu.command_type) != CMD_CONFIRMED_ACTION)
          return DicesRcPhilipsIntellivueSimulatorMP70::OK;
        break;
      case ROLRS_APDU:
        rolrsapdu.linked_id.state = bytes[iindex];
        rolrsapdu.linked_id.count = bytes[iindex + 1];
        rolrsapdu.invoke_id = bytes2u16(reinterpret_cast<uint8_t*>(
          &bytes[iindex + 2]));
        rolrsapdu.command_type = bytes2u16(reinterpret_cast<uint8_t*>(
          &bytes[iindex + 4]));
        rolrsapdu.length = bytes2u16(reinterpret_cast<uint8_t*>(
          &bytes[iindex + 6]));
        iindex += 8;

        if ((length - iindex) < rolrsapdu.length)
        {
          LOG4CPLUS_ERROR(root_logger, sfn << " length is not long enough to "
            "parse ActionResult");
          return DicesRcPhilipsIntellivueSimulatorMP70::CORRUPT_DATA;
        }

        if (static_cast<int>(rolrsapdu.command_type) != CMD_CONFIRMED_ACTION)
          return DicesRcPhilipsIntellivueSimulatorMP70::OK;
        break;
      default:
        return DicesRcPhilipsIntellivueSimulatorMP70::OK;
        break;
    }

    act_result.managed_object.m_obj_class =
      bytes2u16(reinterpret_cast<uint8_t*>(&bytes[iindex]));
    act_result.managed_object.m_obj_inst.context_id =
      bytes2u16(reinterpret_cast<uint8_t*>(&bytes[iindex + 2]));
    act_result.managed_object.m_obj_inst.handle =
      bytes2u16(reinterpret_cast<uint8_t*>(&bytes[iindex + 4]));
    act_result.action_type = bytes2u16(reinterpret_cast<uint8_t*>(
      &bytes[iindex + 6]));
    act_result.length = bytes2u16(reinterpret_cast<uint8_t*>(
      &bytes[iindex + 8]));
    iindex += 10;

    if ((length - iindex) < act_result.length)
    {
      LOG4CPLUS_ERROR(root_logger, sfn << " length is not long enough to "
        "parse PollMdibDataReplyExt");
      return DicesRcPhilipsIntellivueSimulatorMP70::CORRUPT_DATA;
    }

    // Check class and action type
    if (static_cast<int>(act_result.managed_object.m_obj_class)
      != NOM_MOC_VMS_MDS)
      return DicesRcPhilipsIntellivueSimulatorMP70::OK;
    if (static_cast<int>(act_result.action_type)
      != NOM_ACT_POLL_MDIB_DATA_EXT)
      return DicesRcPhilipsIntellivueSimulatorMP70::OK;

    poll_reply_ext.poll_number = bytes2u16(reinterpret_cast<uint8_t*>(
      &bytes[iindex]));
    poll_reply_ext.sequence_no = bytes2u16(reinterpret_cast<uint8_t*>(
      &bytes[iindex + 2]));
    poll_reply_ext.rel_time_stamp = bytes2u32(reinterpret_cast<uint8_t*>(
      &bytes[iindex + 4]));
    poll_reply_ext.abs_time_stamp.century = bytes[iindex + 8];
    poll_reply_ext.abs_time_stamp.year = bytes[iindex + 9];
    poll_reply_ext.abs_time_stamp.month = bytes[iindex + 10];
    poll_reply_ext.abs_time_stamp.day = bytes[iindex + 11];
    poll_reply_ext.abs_time_stamp.hour = bytes[iindex + 12];
    poll_reply_ext.abs_time_stamp.minute = bytes[iindex + 13];
    poll_reply_ext.abs_time_stamp.second = bytes[iindex + 14];
    poll_reply_ext.abs_time_stamp.sec_fractions = bytes[iindex + 15];
    poll_reply_ext.polled_obj_type.partition =
      bytes2u16(reinterpret_cast<uint8_t*>(&bytes[iindex + 16]));
    poll_reply_ext.polled_obj_type.code =
      bytes2u16(reinterpret_cast<uint8_t*>(&bytes[iindex + 18]));
    poll_reply_ext.polled_attr_grp = bytes2u16(reinterpret_cast<uint8_t*>(
      &bytes[iindex + 20]));
    iindex += 22;

    switch (response)
    {
      case rtsa_group_static:
        // Check for SA code and static group    
        if (static_cast<int>(poll_reply_ext.polled_obj_type.code)
          != NOM_MOC_VMO_METRIC_SA_RT
          || static_cast<int>(poll_reply_ext.polled_attr_grp)
          != NOM_ATTR_GRP_VMO_STATIC)
          return DicesRcPhilipsIntellivueSimulatorMP70::OK;

        LOG4CPLUS_INFO(root_logger, sfn << " Found RTSA static group result"
          << std::endl << convert_data_to_hex_string(
          reinterpret_cast<uint8_t*>(bytes), length));
        break;
      case rtsa_group_all:
        // Check for SA code and static group    
        if (static_cast<int>(poll_reply_ext.polled_obj_type.code)
          != NOM_MOC_VMO_METRIC_SA_RT
          || static_cast<int>(poll_reply_ext.polled_attr_grp) != 0)
          return DicesRcPhilipsIntellivueSimulatorMP70::OK;

        LOG4CPLUS_INFO(root_logger, sfn << " Found RTSA all group result"
          << std::endl << convert_data_to_hex_string(
          reinterpret_cast<uint8_t*>(bytes), length));
        break;
      case numeric_group_static:
        // Check for numeric code and static group    
        if (static_cast<int>(poll_reply_ext.polled_obj_type.code)
          != NOM_MOC_VMO_METRIC_NU
          || static_cast<int>(poll_reply_ext.polled_attr_grp)
          != NOM_ATTR_GRP_VMO_STATIC)
          return DicesRcPhilipsIntellivueSimulatorMP70::OK;

        LOG4CPLUS_INFO(root_logger, sfn << " Found numeric static group result"
          << std::endl << convert_data_to_hex_string(
          reinterpret_cast<uint8_t*>(bytes), length));
        break;
      case numeric_group_all:
        // Check for numeric code and static group    
        if (static_cast<int>(poll_reply_ext.polled_obj_type.code)
          != NOM_MOC_VMO_METRIC_NU
          || static_cast<int>(poll_reply_ext.polled_attr_grp) != 0)
          return DicesRcPhilipsIntellivueSimulatorMP70::OK;

        LOG4CPLUS_INFO(root_logger, sfn << " Found numeric all group result"
          << std::endl << convert_data_to_hex_string(
          reinterpret_cast<uint8_t*>(bytes), length));
        break;
      case alarm_result:
        // Check for alarm code and group
        if (static_cast<int>(poll_reply_ext.polled_obj_type.code)
          != NOM_MOC_VMO_AL_MON
          || static_cast<int>(poll_reply_ext.polled_attr_grp)
          != NOM_ATTR_GRP_AL_MON)
          return DicesRcPhilipsIntellivueSimulatorMP70::OK;

        LOG4CPLUS_INFO(root_logger, sfn << " Found alarm result, alarm monitor group"
          << std::endl << convert_data_to_hex_string(
          reinterpret_cast<uint8_t*>(bytes), length));
        break;
    }
    *torf = true; // Found it
  }
  else *torf = false;

  return DicesRcPhilipsIntellivueSimulatorMP70::OK;
}

DicesRcPhilipsIntellivueSimulatorMP70 PhilipsIntellivueMP70Simulator::
HandleDataExportCommand(uint8_t* input_buffer, int length)
{
  // Received data export command
  static const char* sfn = "PhilipsIntellivueMP70Simulator::"
    "HandleDataExportCommand()";
  int iindex = 0;
  intellivue::SPpdu sppdu;
  intellivue::ROIVapdu roiv_apdu;
  intellivue::SetArgument set_arg;
  intellivue::ActionArgument act_arg;
  std::stringstream output_ss;
  DicesRcPhilipsIntellivueSimulatorMP70 status =
    DicesRcPhilipsIntellivueSimulatorMP70::OK;

  sppdu.session_id = bytes2u16(
    reinterpret_cast<uint8_t*>(&input_buffer[iindex]));
  sppdu.p_context_id = bytes2u16(
    reinterpret_cast<uint8_t*>(&input_buffer[iindex + 2]));
  output_ss << "SPpdu\tsession_id: " << sppdu.session_id
    << std::endl << "\t\tp_context_id: " << sppdu.p_context_id
    << std::endl;
  iindex += 4;

  intellivue::ROapdus roapdus;
  roapdus.ro_type = bytes2u16(reinterpret_cast<uint8_t*>(
    &input_buffer[iindex]));
  roapdus.length = bytes2u16(reinterpret_cast<uint8_t*>(
    &input_buffer[iindex + 2]));
  output_ss << "ROapdus\tro_type: " << roapdus.ro_type
    << std::endl << "\t\tlength: " << roapdus.length << std::endl;
  iindex += 4;

  switch (roapdus.ro_type)
  {
    case ROIV_APDU:
      roiv_apdu.invoke_id = bytes2u16(
        reinterpret_cast<uint8_t*>(&input_buffer[iindex]));
      roiv_apdu.command_type = bytes2u16(
        reinterpret_cast<uint8_t*>(&input_buffer[iindex + 2]));
      roiv_apdu.length = bytes2u16(
        reinterpret_cast<uint8_t*>(&input_buffer[iindex + 4]));
      output_ss << "ROIVapdu\tinvoke_id: "
        << roiv_apdu.invoke_id << std::endl
        << "\t\tcommand_type: " << roiv_apdu.command_type << std::endl
        << "\t\tlength: " << roiv_apdu.length << std::endl;
      iindex += 6;

      switch (roiv_apdu.command_type)
      {
        case CMD_EVENT_REPORT: break;
        case CMD_CONFIRMED_EVENT_REPORT: break;
        case CMD_GET: break;
        case CMD_SET: break;
        case CMD_CONFIRMED_SET:
        {
          set_arg.managed_object.m_obj_class = bytes2u16(
            reinterpret_cast<uint8_t*>(&input_buffer[iindex]));
          set_arg.managed_object.m_obj_inst.context_id = bytes2u16(
            reinterpret_cast<uint8_t*>(&input_buffer[iindex + 2]));
          set_arg.managed_object.m_obj_inst.handle = bytes2u16(
            reinterpret_cast<uint8_t*>(&input_buffer[iindex + 4]));
          set_arg.scope = bytes2u32(
            reinterpret_cast<uint8_t*>(&input_buffer[iindex + 6]));
          // TODO modification list
          output_ss << "SetArgument" << std::endl
            << "managed_object\tm_obj_class: "
            << set_arg.managed_object.m_obj_class << std::endl
            << "\t\tcontext_id: "
            << set_arg.managed_object.m_obj_inst.context_id << std::endl
            << "\t\thandle: " << set_arg.managed_object.m_obj_inst.handle
            << std::endl
            << "u_32\t\tscope: " << set_arg.scope << std::endl;
          iindex += 10;

          LOG4CPLUS_INFO(root_logger, "Sending Set priority list result");
          if (_data_file_name.empty())
          {
            status = WriteBytes(ksimulate_set_priority_list_result,
              sizeof(ksimulate_set_priority_list_result));
            if (status != DicesRcPhilipsIntellivueSimulatorMP70::OK)
              return status;
          }
          else
          {
            uint8_t buff[kMaxFileRecordBufferSize] = {0};
            status = SearchSimulationFileForResponse(
              reinterpret_cast<uint8_t*>(&buff),
              kMaxFileRecordBufferSize,
              _simulation_pfds[3],
              set_rtsa_priority_list);
          }
        }
          break;
        case CMD_CONFIRMED_ACTION:
        {
          act_arg.managed_object.m_obj_class = bytes2u16(
            reinterpret_cast<uint8_t*>(&input_buffer[iindex]));
          act_arg.managed_object.m_obj_inst.context_id = bytes2u16(
            reinterpret_cast<uint8_t*>(&input_buffer[iindex + 2]));
          act_arg.managed_object.m_obj_inst.handle = bytes2u16(
            reinterpret_cast<uint8_t*>(&input_buffer[iindex + 4]));
          act_arg.scope = bytes2u32(
            reinterpret_cast<uint8_t*>(&input_buffer[iindex + 6]));
          act_arg.action_type = bytes2u16(
            reinterpret_cast<uint8_t*>(&input_buffer[iindex + 10]));
          act_arg.length = bytes2u16(
            reinterpret_cast<uint8_t*>(&input_buffer[iindex + 12]));
          output_ss << "ActionArgument" << std::endl
            << "managed_object\tm_obj_class: "
            << act_arg.managed_object.m_obj_class << std::endl
            << "\t\tcontext_id: "
            << act_arg.managed_object.m_obj_inst.context_id << std::endl
            << "\t\thandle: "
            << act_arg.managed_object.m_obj_inst.handle << std::endl
            << "u_32\t\tscope: " << act_arg.scope << std::endl
            << "OIDType\t\taction_type: " << act_arg.action_type << std::endl
            << "u_16\t\tlength: " << act_arg.length << std::endl;
          iindex += 14;
        }
          break;
        default:
          LOG4CPLUS_WARN(root_logger, sfn << " Unknown command_type ("
            << roiv_apdu.command_type << ")");
          break;
      }

      if (roiv_apdu.command_type == CMD_CONFIRMED_ACTION)
      {
        if (act_arg.action_type == NOM_ACT_POLL_MDIB_DATA)
        {
          intellivue::PollMdibDataReq poll_data_req;
          poll_data_req.poll_number = bytes2u16(
            reinterpret_cast<uint8_t*>(&input_buffer[iindex]));
          poll_data_req.polled_obj_type.partition = bytes2u16(
            reinterpret_cast<uint8_t*>(&input_buffer[iindex + 2]));
          poll_data_req.polled_obj_type.code = bytes2u16(
            reinterpret_cast<uint8_t*>(&input_buffer[iindex + 4]));
          poll_data_req.polled_attr_grp = bytes2u16(
            reinterpret_cast<uint8_t*>(&input_buffer[iindex + 6]));
          output_ss << "PollMdibDataReq" << std::endl
            << "u_16\t\tpoll_number: "
            << poll_data_req.poll_number << std::endl
            << "TYPE\t\tpartition: "
            << poll_data_req.polled_obj_type.partition << std::endl
            << "\t\tcode: " << poll_data_req.polled_obj_type.code << std::endl
            << "OIDType\t\tpolled_attr_grp: "
            << poll_data_req.polled_attr_grp << std::endl;
          iindex += 8;

          LOG4CPLUS_INFO(root_logger, output_ss.str());

          switch (poll_data_req.polled_obj_type.code)
          {
            case NOM_MOC_VMS_MDS:
              LOG4CPLUS_INFO(root_logger, "Sending MDS"
                << std::endl << std::endl);

              if (_data_file_name.empty())
              {
                status = WriteBytes(ksimulate_mds,
                  sizeof(ksimulate_mds));
                if (status != DicesRcPhilipsIntellivueSimulatorMP70::OK)
                  return status;
              }
              else
              {
                uint8_t buff[kMaxFileRecordBufferSize] = {0};
                status = SearchSimulationFileForResponse(
                  reinterpret_cast<uint8_t*>(&buff),
                  kMaxFileRecordBufferSize,
                  _simulation_pfds[2],
                  mds_result);
              }

              break;
            case NOM_MOC_VMO_AL_MON:
              LOG4CPLUS_INFO(root_logger, "Sending Alert Monitor"
                << std::endl << std::endl);

              if (_data_file_name.empty())
              {
                status = WriteBytes(ksimulate_al_mon,
                  sizeof(ksimulate_al_mon));
                if (status != DicesRcPhilipsIntellivueSimulatorMP70::OK)
                  return status;
              }
              else
              {
                uint8_t buff[kMaxFileRecordBufferSize] = {0};
                status = SearchSimulationFileForResponse(
                  reinterpret_cast<uint8_t*>(&buff),
                  kMaxFileRecordBufferSize,
                  _simulation_pfds[3],
                  alarm_result);
              }
              break;
            case NOM_MOC_PT_DEMOG:
              LOG4CPLUS_INFO(root_logger, "Sending patient demographics"
                << std::endl << std::endl);

              if (_data_file_name.empty())
              {
                status = WriteBytes(ksimulate_pat_demog,
                  sizeof(ksimulate_pat_demog));
                if (status != DicesRcPhilipsIntellivueSimulatorMP70::OK)
                  return status;
              }
              else
              {
                uint8_t buff[kMaxFileRecordBufferSize] = {0};
                status = SearchSimulationFileForResponse(
                  reinterpret_cast<uint8_t*>(&buff),
                  kMaxFileRecordBufferSize,
                  _simulation_pfds[4],
                  pat_demo_result);
              }
              break;
            default:
              LOG4CPLUS_WARN(root_logger, sfn << " Unknown code ("
                << poll_data_req.polled_obj_type.code << ")");
              break;

          }
        }
        else if (act_arg.action_type == NOM_ACT_POLL_MDIB_DATA_EXT)
        {
          intellivue::PollMdibDataReqExt poll_data_req_ext;
          poll_data_req_ext.poll_number = bytes2u16(
            reinterpret_cast<uint8_t*>(&input_buffer[iindex]));
          poll_data_req_ext.polled_obj_type.partition = bytes2u16(
            reinterpret_cast<uint8_t*>(&input_buffer[iindex + 2]));
          poll_data_req_ext.polled_obj_type.code = bytes2u16(
            reinterpret_cast<uint8_t*>(&input_buffer[iindex + 4]));
          poll_data_req_ext.polled_attr_grp = bytes2u16(
            reinterpret_cast<uint8_t*>(&input_buffer[iindex + 6]));
          // TODO  AttributeList poll_ext_attr;
          output_ss << "PollMdibDataReqExt" << std::endl
            << "u_16\t\tpoll_number: "
            << poll_data_req_ext.poll_number << std::endl
            << "TYPE\t\tpartition: "
            << poll_data_req_ext.polled_obj_type.partition << std::endl
            << "\t\tcode: "
            << poll_data_req_ext.polled_obj_type.code << std::endl
            << "OIDType\t\tpolled_attr_grp: "
            << poll_data_req_ext.polled_attr_grp << std::endl;
          iindex += 8;

          LOG4CPLUS_INFO(root_logger, output_ss.str());

          switch (poll_data_req_ext.polled_obj_type.code)
          {
            case NOM_MOC_VMO_METRIC_NU:
            {
              switch (poll_data_req_ext.polled_attr_grp)
              {
                case NOM_ATTR_GRP_VMO_STATIC:
                  LOG4CPLUS_INFO(root_logger, "Sending Numeric static"
                    << std::endl << std::endl);

                  if (_data_file_name.empty())
                  {
                    status = WriteBytes(ksimulate_numeric_static_linked,
                      sizeof(ksimulate_numeric_static_linked));
                    if (status != DicesRcPhilipsIntellivueSimulatorMP70::OK)
                      return status;
                  }
                  else
                  {
                    uint8_t buff[kMaxFileRecordBufferSize] = {0};
                    status = SearchSimulationFileForResponse(
                      reinterpret_cast<uint8_t*>(&buff),
                      kMaxFileRecordBufferSize,
                      _simulation_pfds[5],
                      numeric_group_static);
                  }
                  break;
                case 0: // All attribute groups
                {
                  long long numeric_milliseconds_since_epoch =
                    std::chrono::duration_cast<std::chrono::milliseconds>(
                    std::chrono::system_clock::now(). time_since_epoch()).
                    count();
                  _numeric_seconds_since_epoch =
                    numeric_milliseconds_since_epoch / 1000;

                  LOG4CPLUS_INFO(root_logger, "Received Numeric observed "
                    "value request at " << _numeric_seconds_since_epoch
                    << " (secs since epoch). Sending Numeric observed values"
                    << std::endl << std::endl);

                  if (_ext_nu_done)
                  {
                    std::thread ext_numeric_thread(
                      &PhilipsIntellivueMP70Simulator::
                      ExtendedNumericThreadFunction, this);

                    // Let the thread finish on it's own
                    ext_numeric_thread.detach();
                  }
                }
                  break;
                default:
                  LOG4CPLUS_WARN(root_logger,
                    sfn << " Unknown attribute group ("
                    << poll_data_req_ext.polled_attr_grp << ")");
                  break;
              }
            }
              break;
            case NOM_MOC_VMO_METRIC_SA_RT:
            {
              switch (poll_data_req_ext.polled_attr_grp)
              {
                case NOM_ATTR_GRP_VMO_STATIC:
                  LOG4CPLUS_INFO(root_logger, "Sending RTSA static"
                    << std::endl << std::endl);
                  if (_data_file_name.empty())
                  {
                    status = WriteBytes(ksimulate_rtsa_static,
                      sizeof(ksimulate_rtsa_static));
                    if (status != DicesRcPhilipsIntellivueSimulatorMP70::OK)
                      return status;
                  }
                  else
                  {
                    uint8_t buff[kMaxFileRecordBufferSize] = {0};
                    status = SearchSimulationFileForResponse(
                      reinterpret_cast<uint8_t*>(&buff),
                      kMaxFileRecordBufferSize,
                      _simulation_pfds[7],
                      rtsa_group_static);
                  }
                  break;
                case 0: // All attribute groups
                {
                  long long rtsa_milliseconds_since_epoch =
                    std::chrono::duration_cast<std::chrono::milliseconds>(
                    std::chrono::system_clock::now(). time_since_epoch()).
                    count();
                  _rtsa_seconds_since_epoch =
                    rtsa_milliseconds_since_epoch / 1000;

                  LOG4CPLUS_INFO(root_logger, "Received RTSA observed "
                    "value request at " << rtsa_milliseconds_since_epoch
                    << " (secs since epoch). Sending RTSA observed values"
                    << std::endl << std::endl);

                  if (_ext_rtsa_done)
                  {
                    std::thread ext_rtsa_thread(
                      &PhilipsIntellivueMP70Simulator::
                      ExtendedRTSAThreadFunction,
                      this);

                    // Let the thread finish on it's own
                    ext_rtsa_thread.detach();
                  }
                }
                  break;
                default:
                  LOG4CPLUS_WARN(root_logger,
                    sfn << " Unknown attribute group ("
                    << poll_data_req_ext.polled_attr_grp << ")");
                  break;
              }
            }
              break;
            case NOM_MOC_VMO_AL_MON:
            {
              switch (poll_data_req_ext.polled_attr_grp)
              {
                case NOM_ATTR_GRP_AL_MON:
                {
                  long long alarm_milliseconds_since_epoch =
                    std::chrono::duration_cast<std::chrono::milliseconds>(
                    std::chrono::system_clock::now(). time_since_epoch()).
                    count();
                  _alarm_seconds_since_epoch =
                    alarm_milliseconds_since_epoch / 1000;

                  LOG4CPLUS_INFO(root_logger, "Received Alarm observed "
                    "request at " << alarm_milliseconds_since_epoch
                    << " (secs since epoch).");

                  if (_ext_alarm_done)
                  {
                    std::thread ext_alarm_thread(
                      &PhilipsIntellivueMP70Simulator::
                      ExtendedAlarmThreadFunction,
                      this);

                    // Let the thread finish on it's own
                    ext_alarm_thread.detach();
                  }
                }
                  break;
                default:
                  LOG4CPLUS_WARN(root_logger,
                    sfn << " Unknown attribute group ("
                    << poll_data_req_ext.polled_attr_grp << ")");
                  break;
              }
            }
              break;
            default:
              break;
          }
        }
      }
      break;
    case RORS_APDU: break;
    case ROER_APDU: break;
    case ROLRS_APDU: break;
    default:
      LOG4CPLUS_WARN(root_logger, sfn << " Unknown ro_type ("
        << roapdus.ro_type << ")");
      break;
  }
  return DicesRcPhilipsIntellivueSimulatorMP70::OK;
}

DicesRcPhilipsIntellivueSimulatorMP70 PhilipsIntellivueMP70Simulator::
RunSimulator(int argc, char** argv)
{
  static const char* sfn = "PhilipsIntellivueMP70Simulator::RunSimulator() ";

  if (!argv)
  {
    LOG4CPLUS_ERROR(root_logger, sfn << "Function argument argv is a null "
      "pointer.");
    return DicesRcPhilipsIntellivueSimulatorMP70::FUNCTION_ARGUMENT_IS_NULL;
  }

  DicesRcDeviceSimulator dev_sim_stat = ParseCommandLine(argc, argv);
  if (dev_sim_stat != DicesRcDeviceSimulator::OK)
  {
    LOG4CPLUS_ERROR(root_logger, sfn << DicesRcDeviceSimulatorStatusMessage::
      DicesRcDeviceSimulatorToString(dev_sim_stat));
    return DicesRcPhilipsIntellivueSimulatorMP70::PARSE_CMD_LINE_FAIL;
  }

  DicesRcPhilipsIntellivueSimulatorMP70 status =
    DicesRcPhilipsIntellivueSimulatorMP70::OK;

  // By default run serial simulator.
  DicesRcPhilipsIntellivueSimulatorMP70 sim_status =
    DicesRcPhilipsIntellivueSimulatorMP70::IS_SERIAL_SIM_DATA_FILE;

  if (!_data_file_name.empty())
  {
    // Open all file handles.
    LOG4CPLUS_INFO(root_logger, "Creating " << kMaxNumberOfFilePointers
      << " file handles for " << _data_file_name);
    for (int ix = 0; ix < kMaxNumberOfFilePointers; ix++)
    {
      LOG4CPLUS_INFO(root_logger, "Creating handle #" << ix);
      status = OpenSimulationFile(_data_file_name.c_str(),
        &_simulation_pfds[ix]);
      if (status != DicesRcPhilipsIntellivueSimulatorMP70::OK) return status;
    }

    uint8_t buffer[kMaxFileRecordBufferSize] = {0};

    // Determine if simulation data file contains serial or lan data.
    sim_status = IsSerialOrLanSimulationFile(reinterpret_cast<uint8_t*>(&buffer), kMaxFileRecordBufferSize, _simulation_pfds[0]);
    switch (sim_status)
    {
      case DicesRcPhilipsIntellivueSimulatorMP70::IS_LAN_SIM_DATA_FILE:
        LOG4CPLUS_INFO(root_logger, sfn << "Running lan simulator");
        _is_lan_simulator = true;
        break;
      case DicesRcPhilipsIntellivueSimulatorMP70::IS_SERIAL_SIM_DATA_FILE:
        LOG4CPLUS_INFO(root_logger, sfn << "Running serial simulator");
        _is_lan_simulator = false;
        break;
      default: // NOTE: The status should never be OK.
        LOG4CPLUS_ERROR(root_logger,
          DicesRcPhilipsIntellivueSimulatorMP70StatusMessage::
          DicesRcPhilipsIntellivueSimulatorMP70ToString(status));
        return sim_status;
        break;
    }
  }

  // TODO This simulator will not simulate LAN data generated by program.
  // Only read by file.

  if (sim_status == DicesRcPhilipsIntellivueSimulatorMP70::IS_SERIAL_SIM_DATA_FILE)
  {
    status = RunSerialSimulator();
  }
  else if (sim_status == DicesRcPhilipsIntellivueSimulatorMP70::IS_LAN_SIM_DATA_FILE)
  {
    if (_network_interface.empty())
    {
      _network_interface = "eth0";
      LOG4CPLUS_INFO(root_logger, sfn << "Using default network interface name: " << _network_interface);
    }
    status = RunLanSimulator();
  }

  if (!_data_file_name.empty())
  {
    for (int ix = 0; ix < kMaxNumberOfFilePointers; ix++)
    {
      int file_status = fclose(_simulation_pfds[ix]);
      if (!file_status)
      {
        if (file_status == EOF)
        {
          LOG4CPLUS_WARN(root_logger, sfn << " Failed to close file stream");
          status = DicesRcPhilipsIntellivueSimulatorMP70::CLOSE_FILE_FAIL;
        }
      }
    }
  }
  return status;
}

DicesRcPhilipsIntellivueSimulatorMP70 PhilipsIntellivueMP70Simulator::RunSerialSimulator()
{
  static const char* sfn = "PhilipsIntellivueMP70Simulator::"
    "RunSerialSimulator() ";
  uint8_t input_buffer[kMaxReceiveBufferSize] = { 0 };
  intellivue_serial serial_converter;
  DicesRcPhilipsIntellivueSimulatorMP70 status =
    DicesRcPhilipsIntellivueSimulatorMP70::OK;

  DicesRcDeviceSimulator dev_sim_stat = OpenRS232Port();
  if (dev_sim_stat != DicesRcDeviceSimulator::OK)
  {
    LOG4CPLUS_ERROR(root_logger, sfn << DicesRcDeviceSimulatorStatusMessage::
      DicesRcDeviceSimulatorToString(dev_sim_stat));
    return DicesRcPhilipsIntellivueSimulatorMP70::SERIAL_PORT_OPEN_FAIL;
  }

  DicesRcBaseComm rs232_status = _rs232->Flush();
  if (rs232_status != DicesRcBaseComm::OK)
  {
    LOG4CPLUS_WARN(root_logger, sfn << " " << DicesRcBaseCommStatusMessage::
      DicesRcBaseCommToString(rs232_status));
  }

  while (kbhit_util::kbhit() != kAsciiEsc)
  {
    ssize_t nbytes = 0;

    // Give up control of CPU
    std::this_thread::sleep_for(std::chrono::seconds(0));

    // Zero the buffer
    memset(input_buffer, 0x0, kMaxReceiveBufferSize);

    // Try to read command.
    DicesRcBaseComm rs232_status = _rs232->Read(
      input_buffer,
      kMaxReceiveBufferSize,
      &nbytes);
    if (rs232_status != DicesRcBaseComm::OK)
    {
      LOG4CPLUS_WARN(root_logger, sfn << " " << DicesRcBaseCommStatusMessage::
        DicesRcBaseCommToString(rs232_status));
    }

    // Make sure the session header can be parsed.
    if (nbytes < 2) continue;

    // Unwrap the serial message.
    serial_converter.unwrap_serial_msg(
      reinterpret_cast<uint8_t*>(input_buffer),
      &nbytes);

    // Display unwrapped serial message
    LOG4CPLUS_INFO(root_logger, convert_data_to_hex_string(
      reinterpret_cast<uint8_t*>(input_buffer),
      nbytes));

    // Parse session header
    intellivue::SessionHeader session_header;
    session_header.type = input_buffer[0];
    session_header.length[0] = static_cast<uint8_t>(input_buffer[1]);

    // Handle the command based on the type
    switch (session_header.type)
    {
      case CN_SPDU_SI:
        status = HandleAssociationRequest();
        LOG4CPLUS_INFO(root_logger,
          DicesRcPhilipsIntellivueSimulatorMP70StatusMessage::
          DicesRcPhilipsIntellivueSimulatorMP70ToString(status));
        _simulator_state = associated;
        break;
      case AC_SPDU_SI:
        LOG4CPLUS_WARN(root_logger, sfn << " Unable to process AC_SPDU_SI "
          "session accept command");
        break;
      case RF_SPDU_SI:
        LOG4CPLUS_WARN(root_logger, sfn << " Unable to process AC_SPDU_SI "
          "session refuse command");
        break;
      case FN_SPDU_SI:
        _simulator_state = unassociated;
        break;
      case DN_SPDU_SI:
        LOG4CPLUS_WARN(root_logger, sfn << " Unable to process DN_SPDU_SI "
          "session disconnect command");
        break;
      case AB_SPDU_SI:
        LOG4CPLUS_WARN(root_logger, sfn << " Unable to process AB_SPDU_SI "
          "session abort command");
        break;
      case 0xE1:
        status = HandleDataExportCommand(
          reinterpret_cast<uint8_t*>(input_buffer), nbytes);
        break;
      default:
        LOG4CPLUS_WARN(root_logger, sfn << " Unknown session header type "
          << session_header.type);
        break;
    }
    // something bad happened
    if (status != DicesRcPhilipsIntellivueSimulatorMP70::OK) break;
  }

  LOG4CPLUS_INFO(root_logger, "Exiting...");

  rs232_status = _rs232->Flush();
  if (rs232_status != DicesRcBaseComm::OK)
  {
    LOG4CPLUS_WARN(root_logger, sfn << " " << DicesRcBaseCommStatusMessage::
      DicesRcBaseCommToString(rs232_status));
  }

  rs232_status = _rs232->Close();
  if (rs232_status != DicesRcBaseComm::OK)
  {
    LOG4CPLUS_WARN(root_logger, sfn << " " << DicesRcBaseCommStatusMessage::
      DicesRcBaseCommToString(rs232_status));
  }
}

DicesRcPhilipsIntellivueSimulatorMP70 PhilipsIntellivueMP70Simulator::
RunLanSimulator()
{
  static const char* sfn = "PhilipsIntellivueMP70Simulator::"
    "RunLanSimulator() ";

  DicesRcPhilipsIntellivueSimulatorMP70 status =
    DicesRcPhilipsIntellivueSimulatorMP70::OK;
  DicesRcBaseComm socket_status = DicesRcBaseComm::OK;
  uint8_t input_buffer[kMaxReceiveBufferSize] = { 0 };
  SocketReadImplInterface socket_impl;
  bool escape_pressed = false;

  _socket = new (std::nothrow) Socket(&socket_impl);
  if (!_socket)
  {
    LOG4CPLUS_ERROR(root_logger, sfn << "Failed to create DicesSocket");
    return DicesRcPhilipsIntellivueSimulatorMP70::FAIL;
  }

  std::string ip_addr;
  std::string bcast_addr;

  // TODO Make interface name configurable

  while(!escape_pressed && (status == DicesRcPhilipsIntellivueSimulatorMP70::OK
        || status == DicesRcPhilipsIntellivueSimulatorMP70::IP_ADDR_INFO_NOT_FOUND))
  {
    if (kbhit_util::kbhit() == kAsciiEsc)
    {
      escape_pressed = true;
      continue;
    }
    terminate_simulator = false; // Reset

    LOG4CPLUS_INFO(root_logger, "Waiting for iterface " << _network_interface << " address info to open socket...");

    status = DicesRcPhilipsIntellivueSimulatorMP70::IP_ADDR_INFO_NOT_FOUND;
    while (!escape_pressed && status == DicesRcPhilipsIntellivueSimulatorMP70::IP_ADDR_INFO_NOT_FOUND)
    {
      status = LookUpIpAddrInfo(_network_interface, &ip_addr, &bcast_addr);
      if (status != DicesRcPhilipsIntellivueSimulatorMP70::IP_ADDR_INFO_FOUND
          && status != DicesRcPhilipsIntellivueSimulatorMP70::IP_ADDR_INFO_NOT_FOUND)
      {
        LOG4CPLUS_ERROR(root_logger, sfn <<
                        DicesRcPhilipsIntellivueSimulatorMP70StatusMessage::
                        DicesRcPhilipsIntellivueSimulatorMP70ToString(status));
        delete _socket;
        _socket = nullptr;
        return DicesRcPhilipsIntellivueSimulatorMP70::FAIL;
      }
      std::this_thread::sleep_for(std::chrono::seconds(0));

      if (kbhit_util::kbhit() == kAsciiEsc)
      {
        escape_pressed = true;
        continue;
      }
    }
    if (escape_pressed) continue;

    _socket->set_ip_address(ip_addr);
    _socket->set_port_number(kprotocol_udp_port);
    _socket->set_enable_bind_socket(true);

    socket_status = _socket->Open();
    if (socket_status != DicesRcBaseComm::OK)
    {
      LOG4CPLUS_ERROR(root_logger, sfn << DicesRcBaseCommStatusMessage::
                      DicesRcBaseCommToString(socket_status));
      delete _socket;
      _socket = nullptr;
      return DicesRcPhilipsIntellivueSimulatorMP70::FAIL;
    }

    LOG4CPLUS_INFO(root_logger, "Opened socket");

    // Start thread to broadcast connect indication messages.
    std::thread thread_connect_indication(
          &PhilipsIntellivueMP70Simulator::BroadcastConnectIndicationMessage,
          this);

    while (!escape_pressed)
    {
      if (kbhit_util::kbhit() == kAsciiEsc)
      {
        escape_pressed = true;
        continue;
      }

      status = LookUpIpAddrInfo(_network_interface, &ip_addr, &bcast_addr);
      if (status == DicesRcPhilipsIntellivueSimulatorMP70::IP_ADDR_INFO_NOT_FOUND)
      {
        LOG4CPLUS_WARN(root_logger, "connection lost, restarting");
        break;
      }

      ssize_t nbytes = 0;

      // Give up control of CPU
      std::this_thread::sleep_for(std::chrono::seconds(0));

      // Zero the buffer
      memset(input_buffer, 0x0, kMaxReceiveBufferSize);

      // Try to read command.
      DicesRcBaseComm socket_status = _socket->Read(
            input_buffer,
            kMaxReceiveBufferSize,
            &nbytes);
      if (socket_status != DicesRcBaseComm::OK)
      {
        LOG4CPLUS_WARN(root_logger, sfn << DicesRcBaseCommStatusMessage::
                       DicesRcBaseCommToString(socket_status));
      }

      // Make sure the session header can be parsed.
      if (nbytes < 2) continue;

      // Display unwrapped serial message
      LOG4CPLUS_INFO(root_logger, sfn << "Received bytes: "
                     << convert_data_to_hex_string(
                       reinterpret_cast<uint8_t*>(input_buffer),
                       nbytes));

      // Parse session header
      intellivue::SessionHeader session_header;
      session_header.type = input_buffer[0];
      session_header.length[0] = static_cast<uint8_t>(input_buffer[1]);

      // Handle the command based on the type
      switch (session_header.type)
      {
        case CN_SPDU_SI:
          status = HandleAssociationRequest();
          LOG4CPLUS_INFO(root_logger,
                         DicesRcPhilipsIntellivueSimulatorMP70StatusMessage::
                         DicesRcPhilipsIntellivueSimulatorMP70ToString(status));
          _simulator_state = associated;
          break;
        case AC_SPDU_SI:
          LOG4CPLUS_WARN(root_logger, sfn << " Unable to process AC_SPDU_SI "
                                             "session accept command");
          break;
        case RF_SPDU_SI:
          LOG4CPLUS_WARN(root_logger, sfn << " Unable to process AC_SPDU_SI "
                                             "session refuse command");
          break;
        case FN_SPDU_SI:
          _simulator_state = unassociated;
          break;
        case DN_SPDU_SI:
          LOG4CPLUS_WARN(root_logger, sfn << " Unable to process DN_SPDU_SI "
                                             "session disconnect command");
          break;
        case AB_SPDU_SI:
          LOG4CPLUS_WARN(root_logger, sfn << " Unable to process AB_SPDU_SI "
                                             "session abort command");
          break;
        case 0xE1:
          status = HandleDataExportCommand(
                reinterpret_cast<uint8_t*>(input_buffer), nbytes);
          break;
        default:
          LOG4CPLUS_WARN(root_logger, sfn << " Unknown session header type "
                         << session_header.type);
          break;
      }
      // something bad happened
      if (status != DicesRcPhilipsIntellivueSimulatorMP70::OK) break;
    }

    LOG4CPLUS_INFO(root_logger, "Terminating threads...");
    terminate_simulator = true;

    // Wait a bit for threads to recognize termination flag
    std::this_thread::sleep_for(std::chrono::seconds(2));

    // Join threads
    thread_connect_indication.join();

    LOG4CPLUS_INFO(root_logger, "Joined threads");

    // Close socket
    socket_status = _socket->Close();
    if (socket_status != DicesRcBaseComm::OK)
    {
      LOG4CPLUS_WARN(root_logger, sfn << DicesRcBaseCommStatusMessage::
                     DicesRcBaseCommToString(socket_status));
    }
    LOG4CPLUS_INFO(root_logger, "Closed Socket");
  }

  LOG4CPLUS_INFO(root_logger, "Exiting...");
  delete _socket;
  _socket = nullptr;
}

void PhilipsIntellivueMP70Simulator::BroadcastConnectIndicationMessage()
{
  static const char* sfn = "PhilipsIntellivueMP70Simulator::"
    "BroadcastConnectIndicationMessage() ";

  const int kinvalid_socket_fd = -1;
  const int kattribute_list_pos = 28; // ConnectIndInfo AttributeList position
  const unsigned int kmax_timeouts = 100;
  const int kmaximum_send_period_secs = 64;
  const int kmaximum_fd_rewind_count = 2;
  const std::chrono::seconds kone_sec(1);
  const std::chrono::microseconds kone_tenth_sec(100000);
  const int kfd_index = 9;

  int socket_fd = kinvalid_socket_fd;

  while (terminate_simulator == false)
  {
    // Close socket if it is open.
    if (socket_fd != kinvalid_socket_fd)
    {
      close(socket_fd);
      socket_fd = kinvalid_socket_fd;
    }

    // Open socket
    errno = 0;
    socket_fd = socket(AF_INET, SOCK_DGRAM, 0);
    if (socket_fd == kinvalid_socket_fd)
    {
      LOG4CPLUS_WARN(root_logger, sfn << "Failed to open socket. "
        << strerror(errno));
      return;
    }

    LOG4CPLUS_INFO(root_logger, sfn << "opened socket");
    // TODO I am not able to set these options in DicesSocket tool, otherwise
    // I would've used it.

    // Set socket options
    int enable_broadcast = 1;
    errno = 0;
    if (setsockopt(
      socket_fd,
      SOL_SOCKET,
      SO_BROADCAST,
      &enable_broadcast,
      sizeof(enable_broadcast)) == -1)
    {
      LOG4CPLUS_WARN(root_logger, sfn << "Failed to set socket options. "
        << strerror(errno));
      return;
    }
    LOG4CPLUS_INFO(root_logger, sfn << "set options on socket");
    std::string ip_addr;
    std::string bcast_addr;


    // TODO Make interface name configurable
    DicesRcPhilipsIntellivueSimulatorMP70 status = DicesRcPhilipsIntellivueSimulatorMP70::IP_ADDR_INFO_NOT_FOUND;
    while(status  == DicesRcPhilipsIntellivueSimulatorMP70::IP_ADDR_INFO_NOT_FOUND)
    {
      status = LookUpIpAddrInfo(
            _network_interface,
            &ip_addr,
            &bcast_addr);
      if (status != DicesRcPhilipsIntellivueSimulatorMP70::IP_ADDR_INFO_NOT_FOUND
          && status != DicesRcPhilipsIntellivueSimulatorMP70::IP_ADDR_INFO_FOUND)
      {
        LOG4CPLUS_ERROR(root_logger, sfn <<
                        DicesRcPhilipsIntellivueSimulatorMP70StatusMessage::
                        DicesRcPhilipsIntellivueSimulatorMP70ToString(status));
        return;
      }
      std::this_thread::sleep_for(std::chrono::seconds(0));
    }

    LOG4CPLUS_INFO(root_logger, sfn << "ready to send");
    // Prepare socket destination address.
    struct sockaddr_in addr = { 0 };
    addr.sin_family = AF_INET;
    addr.sin_addr.s_addr = inet_addr(bcast_addr.c_str());
    addr.sin_port = htons(kconnect_indication_port);
    socklen_t slen = sizeof(addr);

    // Convert IP address string to four byte array.
    intellivue::IPAddress int_ip_addr = { 0 };
    status = ConvertStringIpAddrToIntellivueIPAddress(
      ip_addr,
      &int_ip_addr);
    if (status != DicesRcPhilipsIntellivueSimulatorMP70::OK)
    {
      LOG4CPLUS_ERROR(root_logger, sfn <<
        DicesRcPhilipsIntellivueSimulatorMP70StatusMessage::
        DicesRcPhilipsIntellivueSimulatorMP70ToString(status));
      return;
    }

    LOG4CPLUS_INFO(root_logger, sfn << "Searching log file for connect "
      "indication message.");

    uint8_t buffer[kMaxFileRecordBufferSize] = {0};

    ssize_t total_number_of_bytes = 0;
    int rewind_count = 0;
    while (rewind_count < kmaximum_fd_rewind_count)
    {

      status = ReadLanSimulationFileRecord(
        reinterpret_cast<uint8_t*>(buffer),
        kMaxFileRecordBufferSize,
        _simulation_pfds[kfd_index],
        &total_number_of_bytes);
      if (status != DicesRcPhilipsIntellivueSimulatorMP70::OK)
      {
        if (status == DicesRcPhilipsIntellivueSimulatorMP70::END_OF_FILE)
        {
          rewind(_simulation_pfds[kfd_index]);
          rewind_count++;
          continue;
        }
        else
        {
          LOG4CPLUS_ERROR(root_logger, sfn <<
            DicesRcPhilipsIntellivueSimulatorMP70StatusMessage::
            DicesRcPhilipsIntellivueSimulatorMP70ToString(status));
          return;
        }
      }

      // Checks to see if record buffer contains a connect indication message.
      bool found_message = false;
      status = IsConnectIndicationMessage(
        reinterpret_cast<uint8_t*>(buffer),
        kMaxFileRecordBufferSize,
        total_number_of_bytes,
        &found_message);
      if (status != DicesRcPhilipsIntellivueSimulatorMP70::OK)
      {
        LOG4CPLUS_ERROR(root_logger, sfn <<
          DicesRcPhilipsIntellivueSimulatorMP70StatusMessage::
          DicesRcPhilipsIntellivueSimulatorMP70ToString(status));
        return;
      }
      if (found_message)
      {
        LOG4CPLUS_WARN(root_logger, sfn << "Found connect "
          "indication message in log file.");
        break;
      }
    }

    // If file descriptor rewinds twice, then we couldn't find message.
    if (rewind_count == kmaximum_fd_rewind_count)
    {
      LOG4CPLUS_WARN(root_logger, sfn << "Unable to find connect "
        "indication message in log file. Using canned message.");

      // Copy static message into buffer.
      memmove(
        buffer,
        ksimulate_connect_indication,
        sizeof(ksimulate_connect_indication));
      total_number_of_bytes = sizeof(ksimulate_connect_indication);
    }

    int ava_position = 0;

    // Search ConnectIndInfo AttributeList for
    // attribute_id NOM_ATTR_NET_ADDR_INFO
    status = FindPositionOfAttributeInAttributeList(
      &buffer[kattribute_list_pos],
      total_number_of_bytes,
      NOM_ATTR_NET_ADDR_INFO,
      &ava_position);
    if (status != DicesRcPhilipsIntellivueSimulatorMP70::OK)
    {
      LOG4CPLUS_ERROR(root_logger, sfn <<
        DicesRcPhilipsIntellivueSimulatorMP70StatusMessage::
        DicesRcPhilipsIntellivueSimulatorMP70ToString(status));
      return;
    }
    if (ava_position < 0)
    {
      LOG4CPLUS_WARN(root_logger, sfn << "Connect indication message doesn't "
        "contain the expected attribute_id (" << NOM_ATTR_NET_ADDR_INFO
        << ") in AtributeList. Sending message anyways.");
    }
    else
    {
      ava_position += kattribute_list_pos;

      // Check length needed.
      const int kbytes_needed_for_ip_addr = sizeof(intellivue::OIDType)
        + sizeof(uint16_t)
        + sizeof(intellivue::MACAddress)
        + sizeof(intellivue::IPAddress);

      if (total_number_of_bytes < ava_position + kbytes_needed_for_ip_addr)
      {
        LOG4CPLUS_WARN(root_logger, sfn << "Corrupt data, not enough bytes "
          "in connect indication message to reset IP address.");
      }
      else
      {
        // Skip to IP address in this AVAType.
        ava_position += sizeof(intellivue::OIDType); // Skip attribute_id 
        ava_position += sizeof(uint16_t); // Skip length
        ava_position += sizeof(intellivue::MACAddress); // Skip MAC address.

        LOG4CPLUS_INFO(root_logger, sfn << "Replacing ip address "
          << static_cast<int>(buffer[ava_position]) << "." <<
          static_cast<int>(buffer[ava_position + 1]) << "." <<
          static_cast<int>(buffer[ava_position + 2]) << "." <<
          static_cast<int>(buffer[ava_position + 3]) << " with "
          << static_cast<int>(int_ip_addr.value[0]) << "." <<
          static_cast<int>(int_ip_addr.value[1]) << "." <<
          static_cast<int>(int_ip_addr.value[2]) << "." <<
          static_cast<int>(int_ip_addr.value[3]));

        // Replace IP address with our own.
        buffer[ava_position] = int_ip_addr.value[0];
        buffer[ava_position + 1] = int_ip_addr.value[1];
        buffer[ava_position + 2] = int_ip_addr.value[2];
        buffer[ava_position + 3] = int_ip_addr.value[3];
      }
    }

    LOG4CPLUS_INFO(root_logger, sfn << "Sending bytes: "
      << convert_data_to_hex_string(buffer, total_number_of_bytes));

    ssize_t total_nbytes = 0;
    unsigned int timeout_counter = 0;

    while (total_nbytes < sizeof(ksimulate_connect_indication))
    {
      errno = 0;
      ssize_t nbytes = sendto(
        socket_fd,
        buffer,
        total_number_of_bytes,
        0,
        reinterpret_cast<const struct sockaddr *>(&addr),
        slen);
      if (nbytes < 0)
      {
        LOG4CPLUS_ERROR(root_logger, sfn << "sendto() error "
          << strerror(errno));

        if (errno == ENOTCONN || errno == EPIPE)
        {
          // Something happened to the connection. Let's see if it gets
          // resolved.
          break;
        }
        else if (errno == EAGAIN)
        {
          // TODO I didn't realize a non blocking socket could timeout with
          // EAGAIN where it would normally block and wait. Try to send buffer
          // for about 10 seconds. If ten seconds is reached, return with
          // failure.
          timeout_counter++;
          if (timeout_counter >= kmax_timeouts)
          {
            LOG4CPLUS_ERROR(root_logger, sfn << " Failed to sendto() Maximum "
              "number of timeouts reached.");
            return;
          }
          // Sleep for one tenth of a second.
          std::this_thread::sleep_for(kone_tenth_sec);
        }
        else
        {
          // Must be something serious.
          return;
        }
      }
      else
      {
        total_nbytes += nbytes;
      }
    }

    // Send connect indication message every maximum send period.
    for (int ix = 0; ix < kmaximum_send_period_secs; ix++)
    {
      // Check flag every second
      if (terminate_simulator == true) break;
      std::this_thread::sleep_for(kone_sec);
    }
  }

  // Close socket if it is open.
  if (socket_fd != kinvalid_socket_fd)
  {
    close(socket_fd);
    socket_fd = kinvalid_socket_fd;
  }
}

DicesRcPhilipsIntellivueSimulatorMP70 PhilipsIntellivueMP70Simulator::
LookUpIpAddrInfo(
  const std::string& iface_name,
  std::string* ip_addr,
  std::string* bcast_addr)
{
  static const char* sfn = "PhilipsIntellivueMP70Simulator::"
    "LookUpIpAddrInfo() ";
  if (!ip_addr)
  {
    LOG4CPLUS_ERROR(root_logger, sfn << "Function argument ip_addr is a "
      "null pointer.");
    return DicesRcPhilipsIntellivueSimulatorMP70::FUNCTION_ARGUMENT_IS_NULL;
  }

  if (!bcast_addr)
  {
    LOG4CPLUS_ERROR(root_logger, sfn << "Function argument bcast_addr is a "
      "null pointer.");
    return DicesRcPhilipsIntellivueSimulatorMP70::FUNCTION_ARGUMENT_IS_NULL;
  }

  // Clear strings before starting.
  *ip_addr = "";
  *bcast_addr = "";

  struct ifaddrs* if_addr_struct = nullptr;
  struct ifaddrs* if_addr = nullptr;
  void* ptmp_addr = nullptr;

  errno = 0;
  if (getifaddrs(&if_addr_struct) == -1)
  {
    LOG4CPLUS_ERROR(root_logger, sfn << "Failed to get interface addresses. "
      << strerror(errno));
    return DicesRcPhilipsIntellivueSimulatorMP70::FAIL;
  }

  DicesRcPhilipsIntellivueSimulatorMP70 status = DicesRcPhilipsIntellivueSimulatorMP70::IP_ADDR_INFO_NOT_FOUND;
  for (
    if_addr = if_addr_struct;
    if_addr != nullptr;
    if_addr = if_addr->ifa_next)
  {
    if (!if_addr->ifa_addr) continue;

    // Compares interface name with the one that we want to use.
    if (strcmp(_network_interface.c_str(), if_addr->ifa_name) != 0) continue;

    // Checks for IP4
    if (if_addr->ifa_addr->sa_family == AF_INET)
    {
      // Gets valid ip address
      ptmp_addr = &(reinterpret_cast<struct sockaddr_in *>(
        if_addr->ifa_addr))->sin_addr;
      char ip_addr_buf[INET_ADDRSTRLEN] = { 0 };

      errno = 0;
      if (inet_ntop(AF_INET, ptmp_addr, ip_addr_buf, INET_ADDRSTRLEN)
        == nullptr)
      {
        LOG4CPLUS_ERROR(root_logger, sfn << "Failed to convert ip address to "
          "human readable form. " << strerror(errno));
        return DicesRcPhilipsIntellivueSimulatorMP70::FAIL;
      }

      *ip_addr = ip_addr_buf;

      if (if_addr->ifa_flags & IFF_BROADCAST)
      {
        // Gets valid broadcast address
        void* ptmp_bcast_addr = &(reinterpret_cast<struct sockaddr_in *>(
          if_addr->ifa_dstaddr))->sin_addr;
        char bcast_addr_buf[INET_ADDRSTRLEN] = { 0 };

        errno = 0;
        if (inet_ntop(AF_INET, ptmp_bcast_addr, bcast_addr_buf, INET_ADDRSTRLEN)
          == nullptr)
        {
          LOG4CPLUS_ERROR(root_logger, sfn << "Failed to convert broadcast "
            "address to human readable form. " << strerror(errno));
          return DicesRcPhilipsIntellivueSimulatorMP70::FAIL;
        }
        *bcast_addr = bcast_addr_buf;
      }

      status = DicesRcPhilipsIntellivueSimulatorMP70::IP_ADDR_INFO_FOUND;
    }
  }
  if (if_addr_struct != nullptr) freeifaddrs(if_addr_struct);

  return status;
}

DicesRcPhilipsIntellivueSimulatorMP70 PhilipsIntellivueMP70Simulator::
ConvertStringIpAddrToIntellivueIPAddress(
  const std::string& ip_addr,
  intellivue::IPAddress* intellivue_ip_addr)
{
  static const char* sfn = "PhilipsIntellivueMP70Simulator::"
    "ConvertStringIpAddrToIntellivueIPAddress() ";

  if (!intellivue_ip_addr)
  {
    LOG4CPLUS_ERROR(root_logger, sfn << "Function argument intellivue_ip_addr "
      "is a null pointer.");
    return DicesRcPhilipsIntellivueSimulatorMP70::FUNCTION_ARGUMENT_IS_NULL;
  }

  std::string temp_str = ip_addr;
  int count = 0;
  while (!temp_str.empty())
  {
    size_t pos = temp_str.find_first_of('.');
    std::string value;
    if (pos != std::string::npos)
    {
      value = temp_str.substr(0, pos);
      temp_str.erase(0, pos + 1);
    }
    else
    {
      value = temp_str;
      temp_str.erase();
    }

    char* endptr = nullptr;
    errno = 0;
    long int val = strtol(value.c_str(), &endptr, 10);
    if (endptr == value.c_str() || errno != 0)
    {
      LOG4CPLUS_ERROR(root_logger, sfn << "Failed to convert string \""
        << value << "\" to integer. " << strerror(errno));
      return DicesRcPhilipsIntellivueSimulatorMP70::FAIL;
    }
    intellivue_ip_addr->value[count] = static_cast<uint8_t>(val);
    count++;
  }
  return DicesRcPhilipsIntellivueSimulatorMP70::OK;
}

DicesRcPhilipsIntellivueSimulatorMP70 PhilipsIntellivueMP70Simulator::
ReadLanSimulationFileRecord(
  uint8_t* buffer,
  const ssize_t buffer_length,
  FILE* fd,
  ssize_t* total_number_of_bytes)
{
  static const char* sfn = "PhilipsIntellivueMP70Simulator::"
    "ReadLanSimulationFileRecord() ";

  if (!buffer)
  {
    LOG4CPLUS_ERROR(root_logger, sfn << "buffer is a null pointer.");
    return DicesRcPhilipsIntellivueSimulatorMP70::FUNCTION_ARGUMENT_IS_NULL;
  }

  if (!fd)
  {
    LOG4CPLUS_ERROR(root_logger, sfn << "fd is a null pointer.");
    return DicesRcPhilipsIntellivueSimulatorMP70::FUNCTION_ARGUMENT_IS_NULL;
  }

  if (!total_number_of_bytes)
  {
    LOG4CPLUS_ERROR(root_logger, sfn << "total_number_of_bytes is a null "
      "pointer.");
    return DicesRcPhilipsIntellivueSimulatorMP70::FUNCTION_ARGUMENT_IS_NULL;
  }

  *total_number_of_bytes = 0;

  // Read timestamp
  DicesRcPhilipsIntellivueSimulatorMP70 status = ReadSimulationFileTimestamp(
    fd);
  if (status != DicesRcPhilipsIntellivueSimulatorMP70::OK) return status;

  // Read the response up until end of frame.
  status = ReadLanSimulationFileData(buffer, buffer_length, fd, total_number_of_bytes);

  return status;
}

DicesRcPhilipsIntellivueSimulatorMP70 PhilipsIntellivueMP70Simulator::
ReadLanSimulationFileData(
  uint8_t* buffer,
  const ssize_t buffer_length,
  FILE* fd,
  ssize_t* total_number_of_bytes)
{
  static const char* sfn = "PhilipsIntellivueMP70Simulator::"
    "ReadLanSimulationFileData() ";

  if (!buffer)
  {
    LOG4CPLUS_ERROR(root_logger, sfn << "Function argument buffer is a null "
      "pointer.");
    return DicesRcPhilipsIntellivueSimulatorMP70::FUNCTION_ARGUMENT_IS_NULL;
  }

  if (!fd)
  {
    LOG4CPLUS_ERROR(root_logger, sfn << "Function argument fd is a null "
      "pointer.");
    return DicesRcPhilipsIntellivueSimulatorMP70::FUNCTION_ARGUMENT_IS_NULL;
  }

  if (!total_number_of_bytes)
  {
    LOG4CPLUS_ERROR(root_logger, sfn << "Function argument "
      "total_number_of_bytes is a null pointer.");
    return DicesRcPhilipsIntellivueSimulatorMP70::FUNCTION_ARGUMENT_IS_NULL;
  }
  *total_number_of_bytes = 0;

  memset(buffer, 0, buffer_length);

  unsigned char byte = 0;
  int nbytes = 0;
  const int kfirst_eight = 8;

  if (buffer_length < kfirst_eight)
  {
    LOG4CPLUS_ERROR(root_logger, sfn << "Not enough bytes in buffer to hold " << kfirst_eight << " bytes");
    return DicesRcPhilipsIntellivueSimulatorMP70::FAIL;
  }

  // Read the first 8 bytes
  nbytes = fread(&buffer[0], 1, kfirst_eight, fd);
  if (nbytes != kfirst_eight)
  {
    if (feof(fd) && !ferror(fd))
    {
      LOG4CPLUS_INFO(root_logger, sfn << "End of file reached");
      return DicesRcPhilipsIntellivueSimulatorMP70::OK;
    }

    LOG4CPLUS_ERROR(root_logger, sfn << " Unable to read byte from "
      "simulation file");
    return DicesRcPhilipsIntellivueSimulatorMP70::OK;
  }

  *total_number_of_bytes += nbytes;

  bool is_association = false;
  int length = 0;

  DicesRcPhilipsIntellivueSimulatorMP70 status = IsAssociationResponse(
    buffer,
    *total_number_of_bytes,
    &is_association);
  if (status != DicesRcPhilipsIntellivueSimulatorMP70::OK)
  {
    LOG4CPLUS_ERROR(root_logger, sfn <<
      DicesRcPhilipsIntellivueSimulatorMP70StatusMessage::
      DicesRcPhilipsIntellivueSimulatorMP70ToString(status));
    return status;
  }

  // Length is different for association responses.
  if (is_association)
  {
    length = static_cast<int>(buffer[1]);
    length = length - 6;
  }
  else
  {
    length = ntohs(*(reinterpret_cast<uint16_t*>(&buffer[6])));
  }

  if (buffer_length < kfirst_eight + length)
  {
    LOG4CPLUS_ERROR(root_logger, sfn << "Not enough bytes in buffer to hold " <<  kfirst_eight + length << " bytes");
    return DicesRcPhilipsIntellivueSimulatorMP70::FAIL;
  }

  nbytes = fread(
    &buffer[kfirst_eight],
    1,
    static_cast<size_t>(length),
    fd);

  if (nbytes != length)
  {
    if (feof(fd) && !ferror(fd))
    {
      LOG4CPLUS_WARN(root_logger, sfn << "End of file reached");
      return DicesRcPhilipsIntellivueSimulatorMP70::OK;
    }

    LOG4CPLUS_ERROR(root_logger, sfn << " Unable to read byte from "
      "simulation file");
    return DicesRcPhilipsIntellivueSimulatorMP70::FAIL;
  }

  *total_number_of_bytes += nbytes;

  return DicesRcPhilipsIntellivueSimulatorMP70::OK;
}

DicesRcPhilipsIntellivueSimulatorMP70 PhilipsIntellivueMP70Simulator::
FindPositionOfAttributeInAttributeList(
  uint8_t* attribute_list_start,
  int length,
  intellivue::OIDType attribute_id,
  int* position)
{
  static const char* sfn = "PhilipsIntellivueMP70Simulator::"
    "FindPositionOfAttributeInAttributeList() ";

  if (!attribute_list_start)
  {
    LOG4CPLUS_ERROR(root_logger, sfn << "Function argument "
      "attribute_list_start is a null pointer.");
    return DicesRcPhilipsIntellivueSimulatorMP70::FUNCTION_ARGUMENT_IS_NULL;
  }

  if (!position)
  {
    LOG4CPLUS_ERROR(root_logger, sfn << "Function argument position is a null "
      "pointer.");
    return DicesRcPhilipsIntellivueSimulatorMP70::FUNCTION_ARGUMENT_IS_NULL;
  }
  *position = -1;

  if (length < 4)
  {
    LOG4CPLUS_ERROR(root_logger, sfn << "Unable to parse count and length "
      "from AttributeList. Not enough bytes (" << length << ").");
    return DicesRcPhilipsIntellivueSimulatorMP70::FAIL;
  }

  // Parsing AttributeList
  int iindex = 0;
  uint16_t count = ntohs(*(reinterpret_cast<uint16_t*>(
    &attribute_list_start[iindex])));
  iindex += 2;
  uint16_t al_length = ntohs(*(reinterpret_cast<uint16_t*>(
    &attribute_list_start[iindex])));
  iindex += 2;

  for (int ix = 0; ix < count; ix++)
  {
    if (length < iindex + 4)
    {
      LOG4CPLUS_ERROR(root_logger, sfn << "Unable to parse attribute_id "
        "and length from AttributeList. Not enough bytes (" << length << ").");
      return DicesRcPhilipsIntellivueSimulatorMP70::FAIL;
    }
    intellivue::OIDType al_attribute_id = ntohs(*(reinterpret_cast<uint16_t*>(
      &attribute_list_start[iindex])));

    // Checks if this is the attribute we're looking for.
    if (al_attribute_id == attribute_id)
    {
      *position = iindex;
      return DicesRcPhilipsIntellivueSimulatorMP70::OK;
    }
    iindex += 2;

    uint16_t ava_length = ntohs(*(reinterpret_cast<uint16_t*>(
      &attribute_list_start[iindex])));
    iindex += 2;

    if (length < iindex + ava_length)
    {
      LOG4CPLUS_ERROR(root_logger, sfn << "Unable to parse attribute_val "
        "from AttributeList. Not enough bytes (" << length << ").");
      return DicesRcPhilipsIntellivueSimulatorMP70::FAIL;
    }
    iindex += ava_length; // Skip attribute_val.
  }

  return DicesRcPhilipsIntellivueSimulatorMP70::OK;
}
